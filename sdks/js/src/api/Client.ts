/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "./environments";
import * as core from "./core";
import * as JulepApi from "./api";
import { default as URLSearchParams } from "@ungap/url-search-params";
import urlJoin from "url-join";
import * as serializers from "./serialization";
import * as errors from "./errors";

export declare namespace JulepApiClient {
    interface Options {
        environment?: core.Supplier<environments.JulepApiEnvironment | string>;
        apiKey: core.Supplier<string>;
        fetcher?: core.FetchFunction;
    }

    interface RequestOptions {
        timeoutInSeconds?: number;
    }
}

export class JulepApiClient {
    constructor(protected readonly _options: JulepApiClient.Options) {}

    /**
     * List sessions created (use limit/offset pagination to get large number of sessions; sorted by descending order of `created_at`)
     */
    public async listSessions(
        request: JulepApi.ListSessionsRequest = {},
        requestOptions?: JulepApiClient.RequestOptions
    ): Promise<JulepApi.ListSessionsResponse> {
        const { limit, offset } = request;
        const _queryParams = new URLSearchParams();
        if (limit != null) {
            _queryParams.append("limit", limit.toString());
        }

        if (offset != null) {
            _queryParams.append("offset", offset.toString());
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.JulepApiEnvironment.Default,
                "api/sessions"
            ),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            withCredentials: true,
        });
        if (_response.ok) {
            return await serializers.ListSessionsResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.JulepApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.JulepApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.JulepApiTimeoutError();
            case "unknown":
                throw new errors.JulepApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Create a session between an agent and a user
     */
    public async createSession(
        request: JulepApi.CreateSessionRequest,
        requestOptions?: JulepApiClient.RequestOptions
    ): Promise<JulepApi.ResourceCreatedResponse> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.JulepApiEnvironment.Default,
                "api/sessions"
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
            },
            contentType: "application/json",
            body: await serializers.CreateSessionRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            withCredentials: true,
        });
        if (_response.ok) {
            return await serializers.ResourceCreatedResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.JulepApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.JulepApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.JulepApiTimeoutError();
            case "unknown":
                throw new errors.JulepApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * List users created (use limit/offset pagination to get large number of sessions; sorted by descending order of `created_at`)
     */
    public async listUsers(
        request: JulepApi.ListUsersRequest = {},
        requestOptions?: JulepApiClient.RequestOptions
    ): Promise<JulepApi.ListUsersResponse> {
        const { limit, offset } = request;
        const _queryParams = new URLSearchParams();
        if (limit != null) {
            _queryParams.append("limit", limit.toString());
        }

        if (offset != null) {
            _queryParams.append("offset", offset.toString());
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.JulepApiEnvironment.Default,
                "api/users"
            ),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            withCredentials: true,
        });
        if (_response.ok) {
            return await serializers.ListUsersResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.JulepApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.JulepApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.JulepApiTimeoutError();
            case "unknown":
                throw new errors.JulepApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Create a new user
     */
    public async createUser(
        request: JulepApi.CreateUserRequest = {},
        requestOptions?: JulepApiClient.RequestOptions
    ): Promise<JulepApi.ResourceCreatedResponse> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.JulepApiEnvironment.Default,
                "api/users"
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
            },
            contentType: "application/json",
            body: await serializers.CreateUserRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            withCredentials: true,
        });
        if (_response.ok) {
            return await serializers.ResourceCreatedResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.JulepApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.JulepApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.JulepApiTimeoutError();
            case "unknown":
                throw new errors.JulepApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * List agents created (use limit/offset pagination to get large number of sessions; sorted by descending order of `created_at`)
     */
    public async listAgents(
        request: JulepApi.ListAgentsRequest = {},
        requestOptions?: JulepApiClient.RequestOptions
    ): Promise<JulepApi.ListAgentsResponse> {
        const { limit, offset } = request;
        const _queryParams = new URLSearchParams();
        if (limit != null) {
            _queryParams.append("limit", limit.toString());
        }

        if (offset != null) {
            _queryParams.append("offset", offset.toString());
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.JulepApiEnvironment.Default,
                "api/agents"
            ),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            withCredentials: true,
        });
        if (_response.ok) {
            return await serializers.ListAgentsResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.JulepApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.JulepApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.JulepApiTimeoutError();
            case "unknown":
                throw new errors.JulepApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Create a new agent
     */
    public async createAgent(
        request: JulepApi.CreateAgentRequest,
        requestOptions?: JulepApiClient.RequestOptions
    ): Promise<JulepApi.ResourceCreatedResponse> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.JulepApiEnvironment.Default,
                "api/agents"
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
            },
            contentType: "application/json",
            body: await serializers.CreateAgentRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            withCredentials: true,
        });
        if (_response.ok) {
            return await serializers.ResourceCreatedResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.JulepApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.JulepApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.JulepApiTimeoutError();
            case "unknown":
                throw new errors.JulepApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     *
     */
    public async getSession(
        sessionId: string,
        requestOptions?: JulepApiClient.RequestOptions
    ): Promise<JulepApi.Session> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.JulepApiEnvironment.Default,
                `api/sessions/${sessionId}`
            ),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
            },
            contentType: "application/json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            withCredentials: true,
        });
        if (_response.ok) {
            return await serializers.Session.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.JulepApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.JulepApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.JulepApiTimeoutError();
            case "unknown":
                throw new errors.JulepApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     *
     */
    public async updateSession(
        sessionId: string,
        request: JulepApi.UpdateSessionRequest,
        requestOptions?: JulepApiClient.RequestOptions
    ): Promise<JulepApi.ResourceUpdatedResponse> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.JulepApiEnvironment.Default,
                `api/sessions/${sessionId}`
            ),
            method: "PUT",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
            },
            contentType: "application/json",
            body: await serializers.UpdateSessionRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            withCredentials: true,
        });
        if (_response.ok) {
            return await serializers.ResourceUpdatedResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.JulepApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.JulepApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.JulepApiTimeoutError();
            case "unknown":
                throw new errors.JulepApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     *
     */
    public async deleteSession(sessionId: string, requestOptions?: JulepApiClient.RequestOptions): Promise<void> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.JulepApiEnvironment.Default,
                `api/sessions/${sessionId}`
            ),
            method: "DELETE",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
            },
            contentType: "application/json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            withCredentials: true,
        });
        if (_response.ok) {
            return;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.JulepApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.JulepApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.JulepApiTimeoutError();
            case "unknown":
                throw new errors.JulepApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Sorted (created_at descending)
     */
    public async getSuggestions(
        sessionId: string,
        request: JulepApi.GetSuggestionsRequest = {},
        requestOptions?: JulepApiClient.RequestOptions
    ): Promise<JulepApi.GetSuggestionsResponse> {
        const { limit, offset } = request;
        const _queryParams = new URLSearchParams();
        if (limit != null) {
            _queryParams.append("limit", limit.toString());
        }

        if (offset != null) {
            _queryParams.append("offset", offset.toString());
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.JulepApiEnvironment.Default,
                `api/sessions/${sessionId}/suggestions`
            ),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            withCredentials: true,
        });
        if (_response.ok) {
            return await serializers.GetSuggestionsResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.JulepApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.JulepApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.JulepApiTimeoutError();
            case "unknown":
                throw new errors.JulepApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Sorted (created_at ascending)
     */
    public async getHistory(
        sessionId: string,
        request: JulepApi.GetHistoryRequest = {},
        requestOptions?: JulepApiClient.RequestOptions
    ): Promise<JulepApi.GetHistoryResponse> {
        const { limit, offset } = request;
        const _queryParams = new URLSearchParams();
        if (limit != null) {
            _queryParams.append("limit", limit.toString());
        }

        if (offset != null) {
            _queryParams.append("offset", offset.toString());
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.JulepApiEnvironment.Default,
                `api/sessions/${sessionId}/history`
            ),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            withCredentials: true,
        });
        if (_response.ok) {
            return await serializers.GetHistoryResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.JulepApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.JulepApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.JulepApiTimeoutError();
            case "unknown":
                throw new errors.JulepApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     *
     */
    public async chat(
        sessionId: string,
        request: JulepApi.ChatInput,
        requestOptions?: JulepApiClient.RequestOptions
    ): Promise<JulepApi.ChatResponse> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.JulepApiEnvironment.Default,
                `api/sessions/${sessionId}/chat`
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
                Accept: "application/json",
            },
            contentType: "application/json",
            body: await serializers.ChatInput.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            withCredentials: true,
        });
        if (_response.ok) {
            return await serializers.ChatResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.JulepApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.JulepApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.JulepApiTimeoutError();
            case "unknown":
                throw new errors.JulepApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Sorted (created_at descending)
     */
    public async getAgentMemories(
        agentId: string,
        request: JulepApi.GetAgentMemoriesRequest,
        requestOptions?: JulepApiClient.RequestOptions
    ): Promise<JulepApi.GetAgentMemoriesResponse> {
        const { query, types, userId, limit, offset } = request;
        const _queryParams = new URLSearchParams();
        _queryParams.append("query", query);
        if (types != null) {
            if (Array.isArray(types)) {
                for (const _item of types) {
                    _queryParams.append("types", _item);
                }
            } else {
                _queryParams.append("types", types);
            }
        }

        if (userId != null) {
            _queryParams.append("user_id", userId);
        }

        if (limit != null) {
            _queryParams.append("limit", limit.toString());
        }

        if (offset != null) {
            _queryParams.append("offset", offset.toString());
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.JulepApiEnvironment.Default,
                `api/agents/${agentId}/memories`
            ),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            withCredentials: true,
        });
        if (_response.ok) {
            return await serializers.GetAgentMemoriesResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.JulepApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.JulepApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.JulepApiTimeoutError();
            case "unknown":
                throw new errors.JulepApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     *
     */
    public async getUser(userId: string, requestOptions?: JulepApiClient.RequestOptions): Promise<JulepApi.User> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.JulepApiEnvironment.Default,
                `api/users/${userId}`
            ),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
            },
            contentType: "application/json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            withCredentials: true,
        });
        if (_response.ok) {
            return await serializers.User.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.JulepApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.JulepApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.JulepApiTimeoutError();
            case "unknown":
                throw new errors.JulepApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     *
     */
    public async updateUser(
        userId: string,
        request: JulepApi.UpdateUserRequest = {},
        requestOptions?: JulepApiClient.RequestOptions
    ): Promise<JulepApi.ResourceUpdatedResponse> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.JulepApiEnvironment.Default,
                `api/users/${userId}`
            ),
            method: "PUT",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
            },
            contentType: "application/json",
            body: await serializers.UpdateUserRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            withCredentials: true,
        });
        if (_response.ok) {
            return await serializers.ResourceUpdatedResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.JulepApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.JulepApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.JulepApiTimeoutError();
            case "unknown":
                throw new errors.JulepApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     *
     */
    public async deleteUser(userId: string, requestOptions?: JulepApiClient.RequestOptions): Promise<void> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.JulepApiEnvironment.Default,
                `api/users/${userId}`
            ),
            method: "DELETE",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
            },
            contentType: "application/json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            withCredentials: true,
        });
        if (_response.ok) {
            return;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.JulepApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.JulepApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.JulepApiTimeoutError();
            case "unknown":
                throw new errors.JulepApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     *
     */
    public async getAgent(agentId: string, requestOptions?: JulepApiClient.RequestOptions): Promise<JulepApi.Agent> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.JulepApiEnvironment.Default,
                `api/agents/${agentId}`
            ),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
            },
            contentType: "application/json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            withCredentials: true,
        });
        if (_response.ok) {
            return await serializers.Agent.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.JulepApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.JulepApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.JulepApiTimeoutError();
            case "unknown":
                throw new errors.JulepApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     *
     */
    public async updateAgent(
        agentId: string,
        request: JulepApi.UpdateAgentRequest = {},
        requestOptions?: JulepApiClient.RequestOptions
    ): Promise<JulepApi.ResourceUpdatedResponse> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.JulepApiEnvironment.Default,
                `api/agents/${agentId}`
            ),
            method: "PUT",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
            },
            contentType: "application/json",
            body: await serializers.UpdateAgentRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            withCredentials: true,
        });
        if (_response.ok) {
            return await serializers.ResourceUpdatedResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.JulepApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.JulepApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.JulepApiTimeoutError();
            case "unknown":
                throw new errors.JulepApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     *
     */
    public async deleteAgent(agentId: string, requestOptions?: JulepApiClient.RequestOptions): Promise<void> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.JulepApiEnvironment.Default,
                `api/agents/${agentId}`
            ),
            method: "DELETE",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
            },
            contentType: "application/json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            withCredentials: true,
        });
        if (_response.ok) {
            return;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.JulepApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.JulepApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.JulepApiTimeoutError();
            case "unknown":
                throw new errors.JulepApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Sorted (created_at descending)
     */
    public async getAgentAdditionalInfo(
        agentId: string,
        request: JulepApi.GetAgentAdditionalInfoRequest = {},
        requestOptions?: JulepApiClient.RequestOptions
    ): Promise<JulepApi.GetAgentAdditionalInfoResponse> {
        const { limit, offset } = request;
        const _queryParams = new URLSearchParams();
        if (limit != null) {
            _queryParams.append("limit", limit.toString());
        }

        if (offset != null) {
            _queryParams.append("offset", offset.toString());
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.JulepApiEnvironment.Default,
                `api/agents/${agentId}/additional_info`
            ),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            withCredentials: true,
        });
        if (_response.ok) {
            return await serializers.GetAgentAdditionalInfoResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.JulepApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.JulepApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.JulepApiTimeoutError();
            case "unknown":
                throw new errors.JulepApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     *
     */
    public async createAgentAdditionalInfo(
        agentId: string,
        request: JulepApi.CreateAdditionalInfoRequest,
        requestOptions?: JulepApiClient.RequestOptions
    ): Promise<JulepApi.ResourceCreatedResponse> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.JulepApiEnvironment.Default,
                `api/agents/${agentId}/additional_info`
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
            },
            contentType: "application/json",
            body: await serializers.CreateAdditionalInfoRequest.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
            }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            withCredentials: true,
        });
        if (_response.ok) {
            return await serializers.ResourceCreatedResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.JulepApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.JulepApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.JulepApiTimeoutError();
            case "unknown":
                throw new errors.JulepApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Sorted (created_at descending)
     */
    public async getUserAdditionalInfo(
        userId: string,
        request: JulepApi.GetUserAdditionalInfoRequest = {},
        requestOptions?: JulepApiClient.RequestOptions
    ): Promise<JulepApi.GetUserAdditionalInfoResponse> {
        const { limit, offset } = request;
        const _queryParams = new URLSearchParams();
        if (limit != null) {
            _queryParams.append("limit", limit.toString());
        }

        if (offset != null) {
            _queryParams.append("offset", offset.toString());
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.JulepApiEnvironment.Default,
                `api/users/${userId}/additional_info`
            ),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            withCredentials: true,
        });
        if (_response.ok) {
            return await serializers.GetUserAdditionalInfoResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.JulepApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.JulepApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.JulepApiTimeoutError();
            case "unknown":
                throw new errors.JulepApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     *
     */
    public async createUserAdditionalInfo(
        userId: string,
        request: JulepApi.CreateAdditionalInfoRequest,
        requestOptions?: JulepApiClient.RequestOptions
    ): Promise<JulepApi.ResourceCreatedResponse> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.JulepApiEnvironment.Default,
                `api/users/${userId}/additional_info`
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
            },
            contentType: "application/json",
            body: await serializers.CreateAdditionalInfoRequest.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
            }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            withCredentials: true,
        });
        if (_response.ok) {
            return await serializers.ResourceCreatedResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.JulepApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.JulepApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.JulepApiTimeoutError();
            case "unknown":
                throw new errors.JulepApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     *
     */
    public async deleteUserAdditionalInfo(
        userId: string,
        additionalInfoId: string,
        requestOptions?: JulepApiClient.RequestOptions
    ): Promise<void> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.JulepApiEnvironment.Default,
                `api/users/${userId}/additional_info/${additionalInfoId}`
            ),
            method: "DELETE",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
            },
            contentType: "application/json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            withCredentials: true,
        });
        if (_response.ok) {
            return;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.JulepApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.JulepApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.JulepApiTimeoutError();
            case "unknown":
                throw new errors.JulepApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     *
     */
    public async deleteAgentAdditionalInfo(
        agentId: string,
        additionalInfoId: string,
        requestOptions?: JulepApiClient.RequestOptions
    ): Promise<void> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.JulepApiEnvironment.Default,
                `api/agents/${agentId}/additional_info/${additionalInfoId}`
            ),
            method: "DELETE",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
            },
            contentType: "application/json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            withCredentials: true,
        });
        if (_response.ok) {
            return;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.JulepApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.JulepApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.JulepApiTimeoutError();
            case "unknown":
                throw new errors.JulepApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     *
     */
    public async deleteAgentMemory(
        agentId: string,
        memoryId: string,
        requestOptions?: JulepApiClient.RequestOptions
    ): Promise<void> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.JulepApiEnvironment.Default,
                `api/agents/${agentId}/memories/${memoryId}`
            ),
            method: "DELETE",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
            },
            contentType: "application/json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            withCredentials: true,
        });
        if (_response.ok) {
            return;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.JulepApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.JulepApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.JulepApiTimeoutError();
            case "unknown":
                throw new errors.JulepApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Sorted (created_at descending)
     */
    public async getAgentTools(
        agentId: string,
        request: JulepApi.GetAgentToolsRequest = {},
        requestOptions?: JulepApiClient.RequestOptions
    ): Promise<JulepApi.GetAgentToolsResponse> {
        const { limit, offset } = request;
        const _queryParams = new URLSearchParams();
        if (limit != null) {
            _queryParams.append("limit", limit.toString());
        }

        if (offset != null) {
            _queryParams.append("offset", offset.toString());
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.JulepApiEnvironment.Default,
                `api/agents/${agentId}/tools`
            ),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            withCredentials: true,
        });
        if (_response.ok) {
            return await serializers.GetAgentToolsResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.JulepApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.JulepApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.JulepApiTimeoutError();
            case "unknown":
                throw new errors.JulepApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     *
     */
    public async createAgentTool(
        agentId: string,
        request: JulepApi.CreateToolRequest,
        requestOptions?: JulepApiClient.RequestOptions
    ): Promise<JulepApi.ResourceCreatedResponse> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.JulepApiEnvironment.Default,
                `api/agents/${agentId}/tools`
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
            },
            contentType: "application/json",
            body: await serializers.CreateToolRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            withCredentials: true,
        });
        if (_response.ok) {
            return await serializers.ResourceCreatedResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.JulepApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.JulepApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.JulepApiTimeoutError();
            case "unknown":
                throw new errors.JulepApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     *
     */
    public async updateAgentTool(
        agentId: string,
        toolId: string,
        request: JulepApi.UpdateToolRequest,
        requestOptions?: JulepApiClient.RequestOptions
    ): Promise<JulepApi.ResourceUpdatedResponse> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.JulepApiEnvironment.Default,
                `api/agents/${agentId}/tools/${toolId}`
            ),
            method: "PUT",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
            },
            contentType: "application/json",
            body: await serializers.UpdateToolRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            withCredentials: true,
        });
        if (_response.ok) {
            return await serializers.ResourceUpdatedResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.JulepApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.JulepApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.JulepApiTimeoutError();
            case "unknown":
                throw new errors.JulepApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     *
     */
    public async deleteAgentTool(
        agentId: string,
        toolId: string,
        requestOptions?: JulepApiClient.RequestOptions
    ): Promise<void> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.JulepApiEnvironment.Default,
                `api/agents/${agentId}/tools/${toolId}`
            ),
            method: "DELETE",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "X-Fern-Language": "JavaScript",
            },
            contentType: "application/json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 300000,
            withCredentials: true,
        });
        if (_response.ok) {
            return;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.JulepApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.JulepApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.JulepApiTimeoutError();
            case "unknown":
                throw new errors.JulepApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    protected async _getAuthorizationHeader() {
        const value = await core.Supplier.get(this._options.apiKey);
        return value;
    }
}
