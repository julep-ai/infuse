# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

import httpx

from .core.api_error import ApiError
from .core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from .core.jsonable_encoder import jsonable_encoder
from .core.pydantic_utilities import pydantic_v1
from .core.request_options import RequestOptions
from .environment import JulepApiEnvironment
from .types.agent_docs_route_list_request_direction import (
    AgentDocsRouteListRequestDirection,
)
from .types.agent_docs_route_list_request_sort_by import AgentDocsRouteListRequestSortBy
from .types.agent_docs_route_list_response import AgentDocsRouteListResponse
from .types.agents_docs_search_route_search_request_body import (
    AgentsDocsSearchRouteSearchRequestBody,
)
from .types.agents_docs_search_route_search_request_direction import (
    AgentsDocsSearchRouteSearchRequestDirection,
)
from .types.agents_docs_search_route_search_request_sort_by import (
    AgentsDocsSearchRouteSearchRequestSortBy,
)
from .types.agents_docs_search_route_search_response import (
    AgentsDocsSearchRouteSearchResponse,
)
from .types.chat_route_generate_request import ChatRouteGenerateRequest
from .types.chat_route_generate_response import ChatRouteGenerateResponse
from .types.common_limit import CommonLimit
from .types.common_offset import CommonOffset
from .types.common_resource_created_response import CommonResourceCreatedResponse
from .types.common_resource_deleted_response import CommonResourceDeletedResponse
from .types.common_resource_updated_response import CommonResourceUpdatedResponse
from .types.common_uuid import CommonUuid
from .types.docs_doc import DocsDoc
from .types.execution_transitions_route_list_request_direction import (
    ExecutionTransitionsRouteListRequestDirection,
)
from .types.execution_transitions_route_list_request_sort_by import (
    ExecutionTransitionsRouteListRequestSortBy,
)
from .types.execution_transitions_route_list_response import (
    ExecutionTransitionsRouteListResponse,
)
from .types.executions_execution import ExecutionsExecution
from .types.executions_update_execution_request import ExecutionsUpdateExecutionRequest
from .types.history_route_list_request_direction import HistoryRouteListRequestDirection
from .types.history_route_list_request_sort_by import HistoryRouteListRequestSortBy
from .types.history_route_list_response import HistoryRouteListResponse
from .types.task_executions_route_list_request_direction import (
    TaskExecutionsRouteListRequestDirection,
)
from .types.task_executions_route_list_request_sort_by import (
    TaskExecutionsRouteListRequestSortBy,
)
from .types.task_executions_route_list_response import TaskExecutionsRouteListResponse
from .types.tasks_create_task_request_main_item import TasksCreateTaskRequestMainItem
from .types.tasks_patch_task_request_main_item import TasksPatchTaskRequestMainItem
from .types.tasks_route_list_request_direction import TasksRouteListRequestDirection
from .types.tasks_route_list_request_sort_by import TasksRouteListRequestSortBy
from .types.tasks_route_list_response import TasksRouteListResponse
from .types.tasks_task_tool import TasksTaskTool
from .types.tasks_update_task_request_main_item import TasksUpdateTaskRequestMainItem
from .types.user_docs_route_list_request_direction import (
    UserDocsRouteListRequestDirection,
)
from .types.user_docs_route_list_request_sort_by import UserDocsRouteListRequestSortBy
from .types.user_docs_route_list_response import UserDocsRouteListResponse
from .types.user_docs_search_route_search_request_body import (
    UserDocsSearchRouteSearchRequestBody,
)
from .types.user_docs_search_route_search_request_direction import (
    UserDocsSearchRouteSearchRequestDirection,
)
from .types.user_docs_search_route_search_request_sort_by import (
    UserDocsSearchRouteSearchRequestSortBy,
)
from .types.user_docs_search_route_search_response import (
    UserDocsSearchRouteSearchResponse,
)

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class JulepApi:
    """
    Use this class to access the different functions within the SDK. You can instantiate any number of clients with different configuration that will propagate to these functions.

    Parameters
    ----------
    base_url : typing.Optional[str]
        The base url to use for requests from the client.

    environment : JulepApiEnvironment
        The environment to use for requests from the client. from .environment import JulepApiEnvironment



        Defaults to JulepApiEnvironment.DEFAULT



    auth_key : str
    api_key : str
    timeout : typing.Optional[float]
        The timeout to be used, in seconds, for requests. By default the timeout is 300 seconds, unless a custom httpx client is used, in which case this default is not enforced.

    follow_redirects : typing.Optional[bool]
        Whether the default httpx client follows redirects or not, this is irrelevant if a custom httpx client is passed in.

    httpx_client : typing.Optional[httpx.Client]
        The httpx client to use for making requests, a preconfigured client is used by default, however this is useful should you want to pass in any custom httpx configuration.

    Examples
    --------
    from julep.client import JulepApi

    client = JulepApi(
        auth_key="YOUR_AUTH_KEY",
        api_key="YOUR_API_KEY",
    )
    """

    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: JulepApiEnvironment = JulepApiEnvironment.DEFAULT,
        auth_key: str,
        api_key: str,
        timeout: typing.Optional[float] = None,
        follow_redirects: typing.Optional[bool] = True,
        httpx_client: typing.Optional[httpx.Client] = None,
    ):
        _defaulted_timeout = (
            timeout if timeout is not None else 300 if httpx_client is None else None
        )
        self._client_wrapper = SyncClientWrapper(
            base_url=_get_base_url(base_url=base_url, environment=environment),
            auth_key=auth_key,
            api_key=api_key,
            httpx_client=(
                httpx_client
                if httpx_client is not None
                else (
                    httpx.Client(
                        timeout=_defaulted_timeout, follow_redirects=follow_redirects
                    )
                    if follow_redirects is not None
                    else httpx.Client(timeout=_defaulted_timeout)
                )
            ),
            timeout=_defaulted_timeout,
        )

    def agent_docs_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: AgentDocsRouteListRequestSortBy,
        direction: AgentDocsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AgentDocsRouteListResponse:
        """
        List Docs owned by an Agent

        Parameters
        ----------
        id : CommonUuid
            ID of parent

        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : AgentDocsRouteListRequestSortBy
            Sort by a field

        direction : AgentDocsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentDocsRouteListResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agent_docs_route_list(
            id="id",
            limit=1,
            offset=1,
            sort_by="created_at",
            direction="asc",
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/docs",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentDocsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agents_docs_search_route_search(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: AgentsDocsSearchRouteSearchRequestSortBy,
        direction: AgentsDocsSearchRouteSearchRequestDirection,
        metadata_filter: str,
        body: AgentsDocsSearchRouteSearchRequestBody,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AgentsDocsSearchRouteSearchResponse:
        """
        Search Docs owned by an Agent

        Parameters
        ----------
        id : CommonUuid
            ID of the parent

        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : AgentsDocsSearchRouteSearchRequestSortBy
            Sort by a field

        direction : AgentsDocsSearchRouteSearchRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        body : AgentsDocsSearchRouteSearchRequestBody

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentsDocsSearchRouteSearchResponse
            The request has succeeded.

        Examples
        --------
        from julep import DocsVectorDocSearchRequest
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agents_docs_search_route_search(
            id="id",
            limit=1,
            offset=1,
            sort_by="created_at",
            direction="asc",
            metadata_filter="metadata_filter",
            body=DocsVectorDocSearchRequest(
                confidence=1.1,
                alpha=1.1,
                mmr=True,
                vector=[1.1],
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/search",
            method="POST",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            json={"body": body},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentsDocsSearchRouteSearchResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def tasks_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: TasksRouteListRequestSortBy,
        direction: TasksRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TasksRouteListResponse:
        """
        List tasks (paginated)

        Parameters
        ----------
        id : CommonUuid
            ID of parent

        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : TasksRouteListRequestSortBy
            Sort by a field

        direction : TasksRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TasksRouteListResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.tasks_route_list(
            id="id",
            limit=1,
            offset=1,
            sort_by="created_at",
            direction="asc",
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tasks",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(TasksRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def tasks_route_create(
        self,
        id: CommonUuid,
        *,
        name: str,
        description: str,
        main: typing.Sequence[TasksCreateTaskRequestMainItem],
        tools: typing.Sequence[TasksTaskTool],
        inherit_tools: bool,
        input_schema: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceCreatedResponse:
        """
        Create a new task

        Parameters
        ----------
        id : CommonUuid
            ID of parent resource

        name : str

        description : str

        main : typing.Sequence[TasksCreateTaskRequestMainItem]
            The entrypoint of the task.

        tools : typing.Sequence[TasksTaskTool]
            Tools defined specifically for this task not included in the Agent itself.

        inherit_tools : bool
            Whether to inherit tools from the parent agent or not. Defaults to true.

        input_schema : typing.Optional[typing.Dict[str, typing.Any]]
            The schema for the input to the task. `null` means all inputs are valid.

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceCreatedResponse
            The request has succeeded and a new resource has been created as a result.

        Examples
        --------
        from julep import TasksEvaluateStep, TasksTaskTool
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.tasks_route_create(
            id="id",
            name="name",
            description="description",
            main=[
                TasksEvaluateStep(
                    evaluate={"key": "value"},
                )
            ],
            tools=[
                TasksTaskTool(
                    type="function",
                    name="name",
                )
            ],
            inherit_tools=True,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tasks",
            method="POST",
            json={
                "name": name,
                "description": description,
                "main": main,
                "input_schema": input_schema,
                "tools": tools,
                "inherit_tools": inherit_tools,
                "metadata": metadata,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceCreatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def tasks_route_update(
        self,
        id: CommonUuid,
        child_id: CommonUuid,
        *,
        description: str,
        main: typing.Sequence[TasksUpdateTaskRequestMainItem],
        tools: typing.Sequence[TasksTaskTool],
        inherit_tools: bool,
        input_schema: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Update an existing task (overwrite existing values)

        Parameters
        ----------
        id : CommonUuid
            ID of parent resource

        child_id : CommonUuid
            ID of the resource to be updated

        description : str

        main : typing.Sequence[TasksUpdateTaskRequestMainItem]
            The entrypoint of the task.

        tools : typing.Sequence[TasksTaskTool]
            Tools defined specifically for this task not included in the Agent itself.

        inherit_tools : bool
            Whether to inherit tools from the parent agent or not. Defaults to true.

        input_schema : typing.Optional[typing.Dict[str, typing.Any]]
            The schema for the input to the task. `null` means all inputs are valid.

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        from julep import TasksEvaluateStep, TasksTaskTool
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.tasks_route_update(
            id="id",
            child_id="child_id",
            description="description",
            main=[
                TasksEvaluateStep(
                    evaluate={"key": "value"},
                )
            ],
            tools=[
                TasksTaskTool(
                    type="function",
                    name="name",
                )
            ],
            inherit_tools=True,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tasks/{jsonable_encoder(child_id)}",
            method="PUT",
            json={
                "description": description,
                "main": main,
                "input_schema": input_schema,
                "tools": tools,
                "inherit_tools": inherit_tools,
                "metadata": metadata,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def tasks_route_delete(
        self,
        id: CommonUuid,
        child_id: CommonUuid,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceDeletedResponse:
        """
        Delete a task by its id

        Parameters
        ----------
        id : CommonUuid
            ID of parent resource

        child_id : CommonUuid
            ID of the resource to be deleted

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceDeletedResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.tasks_route_delete(
            id="id",
            child_id="child_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tasks/{jsonable_encoder(child_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceDeletedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def tasks_route_patch(
        self,
        id: CommonUuid,
        child_id: CommonUuid,
        *,
        description: typing.Optional[str] = OMIT,
        main: typing.Optional[typing.Sequence[TasksPatchTaskRequestMainItem]] = OMIT,
        input_schema: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        tools: typing.Optional[typing.Sequence[TasksTaskTool]] = OMIT,
        inherit_tools: typing.Optional[bool] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Update an existing task (merges with existing values)

        Parameters
        ----------
        id : CommonUuid
            ID of parent resource

        child_id : CommonUuid
            ID of the resource to be patched

        description : typing.Optional[str]

        main : typing.Optional[typing.Sequence[TasksPatchTaskRequestMainItem]]
            The entrypoint of the task.

        input_schema : typing.Optional[typing.Dict[str, typing.Any]]
            The schema for the input to the task. `null` means all inputs are valid.

        tools : typing.Optional[typing.Sequence[TasksTaskTool]]
            Tools defined specifically for this task not included in the Agent itself.

        inherit_tools : typing.Optional[bool]
            Whether to inherit tools from the parent agent or not. Defaults to true.

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.tasks_route_patch(
            id="id",
            child_id="child_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tasks/{jsonable_encoder(child_id)}",
            method="PATCH",
            json={
                "description": description,
                "main": main,
                "input_schema": input_schema,
                "tools": tools,
                "inherit_tools": inherit_tools,
                "metadata": metadata,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def individual_docs_route_get(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> DocsDoc:
        """
        Get Doc by id

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DocsDoc
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.individual_docs_route_get(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"docs/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(DocsDoc, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def individual_docs_route_delete(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> CommonResourceDeletedResponse:
        """
        Delete an existing Doc by id

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceDeletedResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.individual_docs_route_delete(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"docs/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceDeletedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def executions_route_get(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ExecutionsExecution:
        """
        Get an Execution by id

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ExecutionsExecution
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.executions_route_get(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"executions/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ExecutionsExecution, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def execution_transitions_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: ExecutionTransitionsRouteListRequestSortBy,
        direction: ExecutionTransitionsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ExecutionTransitionsRouteListResponse:
        """
        List the Transitions of an Execution by id

        Parameters
        ----------
        id : CommonUuid
            ID of parent

        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : ExecutionTransitionsRouteListRequestSortBy
            Sort by a field

        direction : ExecutionTransitionsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ExecutionTransitionsRouteListResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.execution_transitions_route_list(
            id="id",
            limit=1,
            offset=1,
            sort_by="created_at",
            direction="asc",
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"executions/{jsonable_encoder(id)}/transitions",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ExecutionTransitionsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def chat_route_generate(
        self,
        id: CommonUuid,
        *,
        request: ChatRouteGenerateRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ChatRouteGenerateResponse:
        """
        Generate a response from the model

        Parameters
        ----------
        id : CommonUuid
            The session ID

        request : ChatRouteGenerateRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChatRouteGenerateResponse
            The request has succeeded.

        Examples
        --------
        from julep import ChatRouteGenerateRequestPreset, EntriesInputChatMlMessage
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.chat_route_generate(
            id="id",
            request=ChatRouteGenerateRequestPreset(
                messages=[
                    EntriesInputChatMlMessage(
                        role="user",
                        content="content",
                    )
                ],
                recall=True,
                remember=True,
                save=True,
                stream=True,
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sessions/{jsonable_encoder(id)}/chat",
            method="POST",
            json=request,
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ChatRouteGenerateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def history_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: HistoryRouteListRequestSortBy,
        direction: HistoryRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HistoryRouteListResponse:
        """
        Get history of a Session (paginated)

        Parameters
        ----------
        id : CommonUuid
            ID of parent

        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : HistoryRouteListRequestSortBy
            Sort by a field

        direction : HistoryRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HistoryRouteListResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.history_route_list(
            id="id",
            limit=1,
            offset=1,
            sort_by="created_at",
            direction="asc",
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sessions/{jsonable_encoder(id)}/history",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(HistoryRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def history_route_delete(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> CommonResourceDeletedResponse:
        """
        Clear the history of a Session (resets the Session)

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceDeletedResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.history_route_delete(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sessions/{jsonable_encoder(id)}/history",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceDeletedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def task_executions_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: TaskExecutionsRouteListRequestSortBy,
        direction: TaskExecutionsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TaskExecutionsRouteListResponse:
        """
        List executions of the given task

        Parameters
        ----------
        id : CommonUuid
            ID of parent

        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : TaskExecutionsRouteListRequestSortBy
            Sort by a field

        direction : TaskExecutionsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TaskExecutionsRouteListResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.task_executions_route_list(
            id="id",
            limit=1,
            offset=1,
            sort_by="created_at",
            direction="asc",
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(id)}/executions",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(TaskExecutionsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def task_executions_route_create(
        self,
        id: CommonUuid,
        *,
        input: typing.Dict[str, typing.Any],
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceCreatedResponse:
        """
        Create an execution for the given task

        Parameters
        ----------
        id : CommonUuid
            ID of parent resource

        input : typing.Dict[str, typing.Any]
            The input to the execution

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceCreatedResponse
            The request has succeeded and a new resource has been created as a result.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.task_executions_route_create(
            id="id",
            input={"key": "value"},
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(id)}/executions",
            method="POST",
            json={"input": input, "metadata": metadata},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceCreatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def task_executions_route_resume_with_task_token(
        self,
        id: CommonUuid,
        *,
        task_token: str,
        input: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Resume an execution with a task token

        Parameters
        ----------
        id : CommonUuid
            ID of parent Task

        task_token : str
            A Task Token is a unique identifier for a specific Task Execution.

        input : typing.Optional[typing.Dict[str, typing.Any]]
            The input to resume the execution with

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.task_executions_route_resume_with_task_token(
            id="id",
            task_token="task_token",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(id)}/executions",
            method="PUT",
            json={"task_token": task_token, "input": input, "status": "running"},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def task_executions_route_update(
        self,
        id: CommonUuid,
        child_id: CommonUuid,
        *,
        request: ExecutionsUpdateExecutionRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Update an existing Execution

        Parameters
        ----------
        id : CommonUuid
            ID of parent resource

        child_id : CommonUuid
            ID of the resource to be updated

        request : ExecutionsUpdateExecutionRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        from julep import ExecutionsUpdateExecutionRequest_Cancelled
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.task_executions_route_update(
            id="string",
            child_id="string",
            request=ExecutionsUpdateExecutionRequest_Cancelled(
                reason="string",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(id)}/executions/{jsonable_encoder(child_id)}",
            method="PUT",
            json=request,
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def user_docs_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: UserDocsRouteListRequestSortBy,
        direction: UserDocsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UserDocsRouteListResponse:
        """
        List Docs owned by a User

        Parameters
        ----------
        id : CommonUuid
            ID of parent

        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : UserDocsRouteListRequestSortBy
            Sort by a field

        direction : UserDocsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UserDocsRouteListResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.user_docs_route_list(
            id="id",
            limit=1,
            offset=1,
            sort_by="created_at",
            direction="asc",
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(id)}/docs",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(UserDocsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def user_docs_search_route_search(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: UserDocsSearchRouteSearchRequestSortBy,
        direction: UserDocsSearchRouteSearchRequestDirection,
        metadata_filter: str,
        body: UserDocsSearchRouteSearchRequestBody,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UserDocsSearchRouteSearchResponse:
        """
        Search Docs owned by a User

        Parameters
        ----------
        id : CommonUuid
            ID of the parent

        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : UserDocsSearchRouteSearchRequestSortBy
            Sort by a field

        direction : UserDocsSearchRouteSearchRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        body : UserDocsSearchRouteSearchRequestBody

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UserDocsSearchRouteSearchResponse
            The request has succeeded.

        Examples
        --------
        from julep import DocsVectorDocSearchRequest
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.user_docs_search_route_search(
            id="id",
            limit=1,
            offset=1,
            sort_by="created_at",
            direction="asc",
            metadata_filter="metadata_filter",
            body=DocsVectorDocSearchRequest(
                confidence=1.1,
                alpha=1.1,
                mmr=True,
                vector=[1.1],
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(id)}/search",
            method="POST",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            json={"body": body},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(UserDocsSearchRouteSearchResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncJulepApi:
    """
    Use this class to access the different functions within the SDK. You can instantiate any number of clients with different configuration that will propagate to these functions.

    Parameters
    ----------
    base_url : typing.Optional[str]
        The base url to use for requests from the client.

    environment : JulepApiEnvironment
        The environment to use for requests from the client. from .environment import JulepApiEnvironment



        Defaults to JulepApiEnvironment.DEFAULT



    auth_key : str
    api_key : str
    timeout : typing.Optional[float]
        The timeout to be used, in seconds, for requests. By default the timeout is 300 seconds, unless a custom httpx client is used, in which case this default is not enforced.

    follow_redirects : typing.Optional[bool]
        Whether the default httpx client follows redirects or not, this is irrelevant if a custom httpx client is passed in.

    httpx_client : typing.Optional[httpx.AsyncClient]
        The httpx client to use for making requests, a preconfigured client is used by default, however this is useful should you want to pass in any custom httpx configuration.

    Examples
    --------
    from julep.client import AsyncJulepApi

    client = AsyncJulepApi(
        auth_key="YOUR_AUTH_KEY",
        api_key="YOUR_API_KEY",
    )
    """

    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: JulepApiEnvironment = JulepApiEnvironment.DEFAULT,
        auth_key: str,
        api_key: str,
        timeout: typing.Optional[float] = None,
        follow_redirects: typing.Optional[bool] = True,
        httpx_client: typing.Optional[httpx.AsyncClient] = None,
    ):
        _defaulted_timeout = (
            timeout if timeout is not None else 300 if httpx_client is None else None
        )
        self._client_wrapper = AsyncClientWrapper(
            base_url=_get_base_url(base_url=base_url, environment=environment),
            auth_key=auth_key,
            api_key=api_key,
            httpx_client=(
                httpx_client
                if httpx_client is not None
                else (
                    httpx.AsyncClient(
                        timeout=_defaulted_timeout, follow_redirects=follow_redirects
                    )
                    if follow_redirects is not None
                    else httpx.AsyncClient(timeout=_defaulted_timeout)
                )
            ),
            timeout=_defaulted_timeout,
        )

    async def agent_docs_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: AgentDocsRouteListRequestSortBy,
        direction: AgentDocsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AgentDocsRouteListResponse:
        """
        List Docs owned by an Agent

        Parameters
        ----------
        id : CommonUuid
            ID of parent

        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : AgentDocsRouteListRequestSortBy
            Sort by a field

        direction : AgentDocsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentDocsRouteListResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.agent_docs_route_list(
                id="id",
                limit=1,
                offset=1,
                sort_by="created_at",
                direction="asc",
                metadata_filter="metadata_filter",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/docs",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentDocsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agents_docs_search_route_search(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: AgentsDocsSearchRouteSearchRequestSortBy,
        direction: AgentsDocsSearchRouteSearchRequestDirection,
        metadata_filter: str,
        body: AgentsDocsSearchRouteSearchRequestBody,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AgentsDocsSearchRouteSearchResponse:
        """
        Search Docs owned by an Agent

        Parameters
        ----------
        id : CommonUuid
            ID of the parent

        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : AgentsDocsSearchRouteSearchRequestSortBy
            Sort by a field

        direction : AgentsDocsSearchRouteSearchRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        body : AgentsDocsSearchRouteSearchRequestBody

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentsDocsSearchRouteSearchResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep import DocsVectorDocSearchRequest
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.agents_docs_search_route_search(
                id="id",
                limit=1,
                offset=1,
                sort_by="created_at",
                direction="asc",
                metadata_filter="metadata_filter",
                body=DocsVectorDocSearchRequest(
                    confidence=1.1,
                    alpha=1.1,
                    mmr=True,
                    vector=[1.1],
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/search",
            method="POST",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            json={"body": body},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentsDocsSearchRouteSearchResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def tasks_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: TasksRouteListRequestSortBy,
        direction: TasksRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TasksRouteListResponse:
        """
        List tasks (paginated)

        Parameters
        ----------
        id : CommonUuid
            ID of parent

        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : TasksRouteListRequestSortBy
            Sort by a field

        direction : TasksRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TasksRouteListResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tasks_route_list(
                id="id",
                limit=1,
                offset=1,
                sort_by="created_at",
                direction="asc",
                metadata_filter="metadata_filter",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tasks",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(TasksRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def tasks_route_create(
        self,
        id: CommonUuid,
        *,
        name: str,
        description: str,
        main: typing.Sequence[TasksCreateTaskRequestMainItem],
        tools: typing.Sequence[TasksTaskTool],
        inherit_tools: bool,
        input_schema: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceCreatedResponse:
        """
        Create a new task

        Parameters
        ----------
        id : CommonUuid
            ID of parent resource

        name : str

        description : str

        main : typing.Sequence[TasksCreateTaskRequestMainItem]
            The entrypoint of the task.

        tools : typing.Sequence[TasksTaskTool]
            Tools defined specifically for this task not included in the Agent itself.

        inherit_tools : bool
            Whether to inherit tools from the parent agent or not. Defaults to true.

        input_schema : typing.Optional[typing.Dict[str, typing.Any]]
            The schema for the input to the task. `null` means all inputs are valid.

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceCreatedResponse
            The request has succeeded and a new resource has been created as a result.

        Examples
        --------
        import asyncio

        from julep import TasksEvaluateStep, TasksTaskTool
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tasks_route_create(
                id="id",
                name="name",
                description="description",
                main=[
                    TasksEvaluateStep(
                        evaluate={"key": "value"},
                    )
                ],
                tools=[
                    TasksTaskTool(
                        type="function",
                        name="name",
                    )
                ],
                inherit_tools=True,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tasks",
            method="POST",
            json={
                "name": name,
                "description": description,
                "main": main,
                "input_schema": input_schema,
                "tools": tools,
                "inherit_tools": inherit_tools,
                "metadata": metadata,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceCreatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def tasks_route_update(
        self,
        id: CommonUuid,
        child_id: CommonUuid,
        *,
        description: str,
        main: typing.Sequence[TasksUpdateTaskRequestMainItem],
        tools: typing.Sequence[TasksTaskTool],
        inherit_tools: bool,
        input_schema: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Update an existing task (overwrite existing values)

        Parameters
        ----------
        id : CommonUuid
            ID of parent resource

        child_id : CommonUuid
            ID of the resource to be updated

        description : str

        main : typing.Sequence[TasksUpdateTaskRequestMainItem]
            The entrypoint of the task.

        tools : typing.Sequence[TasksTaskTool]
            Tools defined specifically for this task not included in the Agent itself.

        inherit_tools : bool
            Whether to inherit tools from the parent agent or not. Defaults to true.

        input_schema : typing.Optional[typing.Dict[str, typing.Any]]
            The schema for the input to the task. `null` means all inputs are valid.

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep import TasksEvaluateStep, TasksTaskTool
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tasks_route_update(
                id="id",
                child_id="child_id",
                description="description",
                main=[
                    TasksEvaluateStep(
                        evaluate={"key": "value"},
                    )
                ],
                tools=[
                    TasksTaskTool(
                        type="function",
                        name="name",
                    )
                ],
                inherit_tools=True,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tasks/{jsonable_encoder(child_id)}",
            method="PUT",
            json={
                "description": description,
                "main": main,
                "input_schema": input_schema,
                "tools": tools,
                "inherit_tools": inherit_tools,
                "metadata": metadata,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def tasks_route_delete(
        self,
        id: CommonUuid,
        child_id: CommonUuid,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceDeletedResponse:
        """
        Delete a task by its id

        Parameters
        ----------
        id : CommonUuid
            ID of parent resource

        child_id : CommonUuid
            ID of the resource to be deleted

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceDeletedResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tasks_route_delete(
                id="id",
                child_id="child_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tasks/{jsonable_encoder(child_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceDeletedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def tasks_route_patch(
        self,
        id: CommonUuid,
        child_id: CommonUuid,
        *,
        description: typing.Optional[str] = OMIT,
        main: typing.Optional[typing.Sequence[TasksPatchTaskRequestMainItem]] = OMIT,
        input_schema: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        tools: typing.Optional[typing.Sequence[TasksTaskTool]] = OMIT,
        inherit_tools: typing.Optional[bool] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Update an existing task (merges with existing values)

        Parameters
        ----------
        id : CommonUuid
            ID of parent resource

        child_id : CommonUuid
            ID of the resource to be patched

        description : typing.Optional[str]

        main : typing.Optional[typing.Sequence[TasksPatchTaskRequestMainItem]]
            The entrypoint of the task.

        input_schema : typing.Optional[typing.Dict[str, typing.Any]]
            The schema for the input to the task. `null` means all inputs are valid.

        tools : typing.Optional[typing.Sequence[TasksTaskTool]]
            Tools defined specifically for this task not included in the Agent itself.

        inherit_tools : typing.Optional[bool]
            Whether to inherit tools from the parent agent or not. Defaults to true.

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tasks_route_patch(
                id="id",
                child_id="child_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tasks/{jsonable_encoder(child_id)}",
            method="PATCH",
            json={
                "description": description,
                "main": main,
                "input_schema": input_schema,
                "tools": tools,
                "inherit_tools": inherit_tools,
                "metadata": metadata,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def individual_docs_route_get(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> DocsDoc:
        """
        Get Doc by id

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DocsDoc
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.individual_docs_route_get(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"docs/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(DocsDoc, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def individual_docs_route_delete(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> CommonResourceDeletedResponse:
        """
        Delete an existing Doc by id

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceDeletedResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.individual_docs_route_delete(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"docs/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceDeletedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def executions_route_get(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ExecutionsExecution:
        """
        Get an Execution by id

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ExecutionsExecution
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.executions_route_get(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"executions/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ExecutionsExecution, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def execution_transitions_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: ExecutionTransitionsRouteListRequestSortBy,
        direction: ExecutionTransitionsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ExecutionTransitionsRouteListResponse:
        """
        List the Transitions of an Execution by id

        Parameters
        ----------
        id : CommonUuid
            ID of parent

        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : ExecutionTransitionsRouteListRequestSortBy
            Sort by a field

        direction : ExecutionTransitionsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ExecutionTransitionsRouteListResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.execution_transitions_route_list(
                id="id",
                limit=1,
                offset=1,
                sort_by="created_at",
                direction="asc",
                metadata_filter="metadata_filter",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"executions/{jsonable_encoder(id)}/transitions",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ExecutionTransitionsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def chat_route_generate(
        self,
        id: CommonUuid,
        *,
        request: ChatRouteGenerateRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ChatRouteGenerateResponse:
        """
        Generate a response from the model

        Parameters
        ----------
        id : CommonUuid
            The session ID

        request : ChatRouteGenerateRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChatRouteGenerateResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep import ChatRouteGenerateRequestPreset, EntriesInputChatMlMessage
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.chat_route_generate(
                id="id",
                request=ChatRouteGenerateRequestPreset(
                    messages=[
                        EntriesInputChatMlMessage(
                            role="user",
                            content="content",
                        )
                    ],
                    recall=True,
                    remember=True,
                    save=True,
                    stream=True,
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sessions/{jsonable_encoder(id)}/chat",
            method="POST",
            json=request,
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ChatRouteGenerateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def history_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: HistoryRouteListRequestSortBy,
        direction: HistoryRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HistoryRouteListResponse:
        """
        Get history of a Session (paginated)

        Parameters
        ----------
        id : CommonUuid
            ID of parent

        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : HistoryRouteListRequestSortBy
            Sort by a field

        direction : HistoryRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HistoryRouteListResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.history_route_list(
                id="id",
                limit=1,
                offset=1,
                sort_by="created_at",
                direction="asc",
                metadata_filter="metadata_filter",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sessions/{jsonable_encoder(id)}/history",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(HistoryRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def history_route_delete(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> CommonResourceDeletedResponse:
        """
        Clear the history of a Session (resets the Session)

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceDeletedResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.history_route_delete(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sessions/{jsonable_encoder(id)}/history",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceDeletedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def task_executions_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: TaskExecutionsRouteListRequestSortBy,
        direction: TaskExecutionsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TaskExecutionsRouteListResponse:
        """
        List executions of the given task

        Parameters
        ----------
        id : CommonUuid
            ID of parent

        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : TaskExecutionsRouteListRequestSortBy
            Sort by a field

        direction : TaskExecutionsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TaskExecutionsRouteListResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.task_executions_route_list(
                id="id",
                limit=1,
                offset=1,
                sort_by="created_at",
                direction="asc",
                metadata_filter="metadata_filter",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(id)}/executions",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(TaskExecutionsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def task_executions_route_create(
        self,
        id: CommonUuid,
        *,
        input: typing.Dict[str, typing.Any],
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceCreatedResponse:
        """
        Create an execution for the given task

        Parameters
        ----------
        id : CommonUuid
            ID of parent resource

        input : typing.Dict[str, typing.Any]
            The input to the execution

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceCreatedResponse
            The request has succeeded and a new resource has been created as a result.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.task_executions_route_create(
                id="id",
                input={"key": "value"},
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(id)}/executions",
            method="POST",
            json={"input": input, "metadata": metadata},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceCreatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def task_executions_route_resume_with_task_token(
        self,
        id: CommonUuid,
        *,
        task_token: str,
        input: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Resume an execution with a task token

        Parameters
        ----------
        id : CommonUuid
            ID of parent Task

        task_token : str
            A Task Token is a unique identifier for a specific Task Execution.

        input : typing.Optional[typing.Dict[str, typing.Any]]
            The input to resume the execution with

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.task_executions_route_resume_with_task_token(
                id="id",
                task_token="task_token",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(id)}/executions",
            method="PUT",
            json={"task_token": task_token, "input": input, "status": "running"},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def task_executions_route_update(
        self,
        id: CommonUuid,
        child_id: CommonUuid,
        *,
        request: ExecutionsUpdateExecutionRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Update an existing Execution

        Parameters
        ----------
        id : CommonUuid
            ID of parent resource

        child_id : CommonUuid
            ID of the resource to be updated

        request : ExecutionsUpdateExecutionRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep import ExecutionsUpdateExecutionRequest_Cancelled
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.task_executions_route_update(
                id="string",
                child_id="string",
                request=ExecutionsUpdateExecutionRequest_Cancelled(
                    reason="string",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(id)}/executions/{jsonable_encoder(child_id)}",
            method="PUT",
            json=request,
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def user_docs_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: UserDocsRouteListRequestSortBy,
        direction: UserDocsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UserDocsRouteListResponse:
        """
        List Docs owned by a User

        Parameters
        ----------
        id : CommonUuid
            ID of parent

        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : UserDocsRouteListRequestSortBy
            Sort by a field

        direction : UserDocsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UserDocsRouteListResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.user_docs_route_list(
                id="id",
                limit=1,
                offset=1,
                sort_by="created_at",
                direction="asc",
                metadata_filter="metadata_filter",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(id)}/docs",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(UserDocsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def user_docs_search_route_search(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: UserDocsSearchRouteSearchRequestSortBy,
        direction: UserDocsSearchRouteSearchRequestDirection,
        metadata_filter: str,
        body: UserDocsSearchRouteSearchRequestBody,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UserDocsSearchRouteSearchResponse:
        """
        Search Docs owned by a User

        Parameters
        ----------
        id : CommonUuid
            ID of the parent

        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : UserDocsSearchRouteSearchRequestSortBy
            Sort by a field

        direction : UserDocsSearchRouteSearchRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        body : UserDocsSearchRouteSearchRequestBody

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UserDocsSearchRouteSearchResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep import DocsVectorDocSearchRequest
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.user_docs_search_route_search(
                id="id",
                limit=1,
                offset=1,
                sort_by="created_at",
                direction="asc",
                metadata_filter="metadata_filter",
                body=DocsVectorDocSearchRequest(
                    confidence=1.1,
                    alpha=1.1,
                    mmr=True,
                    vector=[1.1],
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(id)}/search",
            method="POST",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            json={"body": body},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(UserDocsSearchRouteSearchResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


def _get_base_url(
    *, base_url: typing.Optional[str] = None, environment: JulepApiEnvironment
) -> str:
    if base_url is not None:
        return base_url
    elif environment is not None:
        return environment.value
    else:
        raise Exception(
            "Please pass in either base_url or environment to construct the client"
        )
