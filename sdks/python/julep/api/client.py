# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import httpx

from .core.api_error import ApiError
from .core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from .core.jsonable_encoder import jsonable_encoder
from .core.remove_none_from_dict import remove_none_from_dict
from .environment import JulepApiEnvironment
from .types.agent_docs_route_list_request_direction import (
    AgentDocsRouteListRequestDirection,
)
from .types.agent_docs_route_list_request_sort_by import AgentDocsRouteListRequestSortBy
from .types.agent_docs_route_list_response import AgentDocsRouteListResponse
from .types.agent_tools_route_create_response import AgentToolsRouteCreateResponse
from .types.agent_tools_route_list_request_direction import (
    AgentToolsRouteListRequestDirection,
)
from .types.agent_tools_route_list_request_sort_by import (
    AgentToolsRouteListRequestSortBy,
)
from .types.agent_tools_route_list_response import AgentToolsRouteListResponse
from .types.agents_agent import AgentsAgent
from .types.agents_create_agent_request import AgentsCreateAgentRequest
from .types.agents_create_or_update_agent_request_default_settings import (
    AgentsCreateOrUpdateAgentRequestDefaultSettings,
)
from .types.agents_create_or_update_agent_request_instructions import (
    AgentsCreateOrUpdateAgentRequestInstructions,
)
from .types.agents_docs_search_route_search_request_direction import (
    AgentsDocsSearchRouteSearchRequestDirection,
)
from .types.agents_docs_search_route_search_request_sort_by import (
    AgentsDocsSearchRouteSearchRequestSortBy,
)
from .types.agents_docs_search_route_search_response import (
    AgentsDocsSearchRouteSearchResponse,
)
from .types.agents_patch_agent_request_default_settings import (
    AgentsPatchAgentRequestDefaultSettings,
)
from .types.agents_patch_agent_request_instructions import (
    AgentsPatchAgentRequestInstructions,
)
from .types.agents_route_create_or_update_response import (
    AgentsRouteCreateOrUpdateResponse,
)
from .types.agents_route_create_response import AgentsRouteCreateResponse
from .types.agents_route_delete_response import AgentsRouteDeleteResponse
from .types.agents_route_list_request_direction import AgentsRouteListRequestDirection
from .types.agents_route_list_request_sort_by import AgentsRouteListRequestSortBy
from .types.agents_route_list_response import AgentsRouteListResponse
from .types.agents_route_patch_response import AgentsRoutePatchResponse
from .types.agents_route_update_response import AgentsRouteUpdateResponse
from .types.agents_update_agent_request_default_settings import (
    AgentsUpdateAgentRequestDefaultSettings,
)
from .types.agents_update_agent_request_instructions import (
    AgentsUpdateAgentRequestInstructions,
)
from .types.common_identifier_safe_unicode import CommonIdentifierSafeUnicode
from .types.common_limit import CommonLimit
from .types.common_offset import CommonOffset
from .types.common_uuid import CommonUuid
from .types.docs_doc import DocsDoc
from .types.docs_doc_search_request import DocsDocSearchRequest
from .types.execution_transitions_route_list_request_direction import (
    ExecutionTransitionsRouteListRequestDirection,
)
from .types.execution_transitions_route_list_request_sort_by import (
    ExecutionTransitionsRouteListRequestSortBy,
)
from .types.execution_transitions_route_list_response import (
    ExecutionTransitionsRouteListResponse,
)
from .types.executions_execution import ExecutionsExecution
from .types.executions_route_update_response import ExecutionsRouteUpdateResponse
from .types.executions_update_execution_request import ExecutionsUpdateExecutionRequest
from .types.history_route_delete_response import HistoryRouteDeleteResponse
from .types.history_route_list_request_direction import HistoryRouteListRequestDirection
from .types.history_route_list_request_sort_by import HistoryRouteListRequestSortBy
from .types.history_route_list_response import HistoryRouteListResponse
from .types.individual_docs_route_delete_response import (
    IndividualDocsRouteDeleteResponse,
)
from .types.jobs_job_status import JobsJobStatus
from .types.sessions_route_create_or_update_response import (
    SessionsRouteCreateOrUpdateResponse,
)
from .types.sessions_route_create_response import SessionsRouteCreateResponse
from .types.sessions_route_delete_response import SessionsRouteDeleteResponse
from .types.sessions_route_list_request_direction import (
    SessionsRouteListRequestDirection,
)
from .types.sessions_route_list_request_sort_by import SessionsRouteListRequestSortBy
from .types.sessions_route_list_response import SessionsRouteListResponse
from .types.sessions_route_patch_response import SessionsRoutePatchResponse
from .types.sessions_route_update_response import SessionsRouteUpdateResponse
from .types.sessions_session import SessionsSession
from .types.task_executions_route_create_response import (
    TaskExecutionsRouteCreateResponse,
)
from .types.task_executions_route_list_request_direction import (
    TaskExecutionsRouteListRequestDirection,
)
from .types.task_executions_route_list_request_sort_by import (
    TaskExecutionsRouteListRequestSortBy,
)
from .types.task_executions_route_list_response import TaskExecutionsRouteListResponse
from .types.task_executions_route_resume_with_task_token_response import (
    TaskExecutionsRouteResumeWithTaskTokenResponse,
)
from .types.tasks_route_create_or_update_response import (
    TasksRouteCreateOrUpdateResponse,
)
from .types.tasks_route_create_response import TasksRouteCreateResponse
from .types.tasks_route_delete_response import TasksRouteDeleteResponse
from .types.tasks_route_list_request_direction import TasksRouteListRequestDirection
from .types.tasks_route_list_request_sort_by import TasksRouteListRequestSortBy
from .types.tasks_route_list_response import TasksRouteListResponse
from .types.tasks_route_patch_response import TasksRoutePatchResponse
from .types.tasks_route_update_response import TasksRouteUpdateResponse
from .types.tasks_workflow_step import TasksWorkflowStep
from .types.tool_route_delete_response import ToolRouteDeleteResponse
from .types.tool_route_patch_response import ToolRoutePatchResponse
from .types.tool_route_update_response import ToolRouteUpdateResponse
from .types.tools_create_tool_request import ToolsCreateToolRequest
from .types.tools_function_def import ToolsFunctionDef
from .types.tools_function_def_update import ToolsFunctionDefUpdate
from .types.tools_tool_type import ToolsToolType
from .types.user_docs_route_list_request_direction import (
    UserDocsRouteListRequestDirection,
)
from .types.user_docs_route_list_request_sort_by import UserDocsRouteListRequestSortBy
from .types.user_docs_route_list_response import UserDocsRouteListResponse
from .types.user_docs_search_route_search_request_direction import (
    UserDocsSearchRouteSearchRequestDirection,
)
from .types.user_docs_search_route_search_request_sort_by import (
    UserDocsSearchRouteSearchRequestSortBy,
)
from .types.user_docs_search_route_search_response import (
    UserDocsSearchRouteSearchResponse,
)
from .types.users_route_create_or_update_response import (
    UsersRouteCreateOrUpdateResponse,
)
from .types.users_route_create_response import UsersRouteCreateResponse
from .types.users_route_delete_response import UsersRouteDeleteResponse
from .types.users_route_list_request_direction import UsersRouteListRequestDirection
from .types.users_route_list_request_sort_by import UsersRouteListRequestSortBy
from .types.users_route_list_response import UsersRouteListResponse
from .types.users_route_patch_response import UsersRoutePatchResponse
from .types.users_route_update_response import UsersRouteUpdateResponse
from .types.users_user import UsersUser

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class JulepApi:
    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: JulepApiEnvironment = JulepApiEnvironment.DEFAULT,
        auth_key: str,
        api_key: str,
        timeout: typing.Optional[float] = 300,
        httpx_client: typing.Optional[httpx.Client] = None,
    ):
        self._client_wrapper = SyncClientWrapper(
            base_url=_get_base_url(base_url=base_url, environment=environment),
            auth_key=auth_key,
            api_key=api_key,
            httpx_client=(
                httpx.Client(timeout=timeout) if httpx_client is None else httpx_client
            ),
        )

    def agents_route_list(
        self,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: AgentsRouteListRequestSortBy,
        direction: AgentsRouteListRequestDirection,
        metadata_filter: str,
    ) -> AgentsRouteListResponse:
        """
        List undefined items

        Parameters:
            - limit: CommonLimit. Limit the number of undefined items returned

            - offset: CommonOffset. Offset the undefined items returned

            - sort_by: AgentsRouteListRequestSortBy. Sort by a field

            - direction: AgentsRouteListRequestDirection. Sort direction

            - metadata_filter: str. JSON string of object that should be used to filter objects by metadata
        ---
        from julep import AgentsRouteListRequestDirection, AgentsRouteListRequestSortBy
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agents_route_list(
            limit=1,
            offset=1,
            sort_by=AgentsRouteListRequestSortBy.CREATED_AT,
            direction=AgentsRouteListRequestDirection.ASC,
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "agents"),
            params=remove_none_from_dict(
                {
                    "limit": limit,
                    "offset": offset,
                    "sort_by": sort_by,
                    "direction": direction,
                    "metadata_filter": metadata_filter,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AgentsRouteListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agents_route_create(
        self, *, request: AgentsCreateAgentRequest
    ) -> AgentsRouteCreateResponse:
        """
        Create new undefined

        Parameters:
            - request: AgentsCreateAgentRequest.
        ---
        from julep import AgentsCreateAgentRequest
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agents_route_create(
            request=AgentsCreateAgentRequest(
                name="name",
                about="about",
                model="model",
                docs=[],
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "agents"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AgentsRouteCreateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agents_route_create_or_update(
        self,
        *,
        id: CommonUuid,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        name: CommonIdentifierSafeUnicode,
        about: str,
        model: str,
        instructions: AgentsCreateOrUpdateAgentRequestInstructions,
        default_settings: typing.Optional[
            AgentsCreateOrUpdateAgentRequestDefaultSettings
        ] = OMIT,
    ) -> AgentsRouteCreateOrUpdateResponse:
        """
        Create or update undefined (ID is required in payload; existing resource will be overwritten)

        Parameters:
            - id: CommonUuid.

            - metadata: typing.Optional[typing.Dict[str, typing.Any]].

            - name: CommonIdentifierSafeUnicode. Name of the agent

            - about: str. About the agent

            - model: str. Model name to use (gpt-4-turbo, gemini-nano etc)

            - instructions: AgentsCreateOrUpdateAgentRequestInstructions. Instructions for the agent

            - default_settings: typing.Optional[AgentsCreateOrUpdateAgentRequestDefaultSettings]. Default settings for all sessions created by this agent
        ---
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agents_route_create_or_update(
            id="id",
            name="name",
            about="about",
            model="model",
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "id": id,
            "name": name,
            "about": about,
            "model": model,
            "instructions": instructions,
        }
        if metadata is not OMIT:
            _request["metadata"] = metadata
        if default_settings is not OMIT:
            _request["default_settings"] = default_settings
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "agents"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AgentsRouteCreateOrUpdateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agents_route_get(self, id: CommonUuid) -> AgentsAgent:
        """
        Get undefined by id

        Parameters:
            - id: CommonUuid. ID of the undefined
        ---
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agents_route_get(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"agents/{id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AgentsAgent, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agents_route_update(
        self,
        id: CommonUuid,
        *,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        name: CommonIdentifierSafeUnicode,
        about: str,
        model: str,
        instructions: AgentsUpdateAgentRequestInstructions,
        default_settings: typing.Optional[
            AgentsUpdateAgentRequestDefaultSettings
        ] = OMIT,
    ) -> AgentsRouteUpdateResponse:
        """
        Update undefined by id (overwrite)

        Parameters:
            - id: CommonUuid. ID of the undefined

            - metadata: typing.Optional[typing.Dict[str, typing.Any]].

            - name: CommonIdentifierSafeUnicode. Name of the agent

            - about: str. About the agent

            - model: str. Model name to use (gpt-4-turbo, gemini-nano etc)

            - instructions: AgentsUpdateAgentRequestInstructions. Instructions for the agent

            - default_settings: typing.Optional[AgentsUpdateAgentRequestDefaultSettings]. Default settings for all sessions created by this agent
        ---
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agents_route_update(
            id="id",
            name="name",
            about="about",
            model="model",
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "name": name,
            "about": about,
            "model": model,
            "instructions": instructions,
        }
        if metadata is not OMIT:
            _request["metadata"] = metadata
        if default_settings is not OMIT:
            _request["default_settings"] = default_settings
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"agents/{id}"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AgentsRouteUpdateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agents_route_delete(self, id: CommonUuid) -> AgentsRouteDeleteResponse:
        """
        Delete undefined by id

        Parameters:
            - id: CommonUuid. ID of the undefined
        ---
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agents_route_delete(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"agents/{id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AgentsRouteDeleteResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agents_route_patch(
        self,
        id: CommonUuid,
        *,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        name: typing.Optional[CommonIdentifierSafeUnicode] = OMIT,
        about: typing.Optional[str] = OMIT,
        model: typing.Optional[str] = OMIT,
        instructions: typing.Optional[AgentsPatchAgentRequestInstructions] = OMIT,
        default_settings: typing.Optional[
            AgentsPatchAgentRequestDefaultSettings
        ] = OMIT,
    ) -> AgentsRoutePatchResponse:
        """
        Patch undefined by id (merge changes)

        Parameters:
            - id: CommonUuid. ID of the undefined

            - metadata: typing.Optional[typing.Dict[str, typing.Any]].

            - name: typing.Optional[CommonIdentifierSafeUnicode]. Name of the agent

            - about: typing.Optional[str]. About the agent

            - model: typing.Optional[str]. Model name to use (gpt-4-turbo, gemini-nano etc)

            - instructions: typing.Optional[AgentsPatchAgentRequestInstructions]. Instructions for the agent

            - default_settings: typing.Optional[AgentsPatchAgentRequestDefaultSettings]. Default settings for all sessions created by this agent
        ---
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agents_route_patch(
            id="id",
        )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if metadata is not OMIT:
            _request["metadata"] = metadata
        if name is not OMIT:
            _request["name"] = name
        if about is not OMIT:
            _request["about"] = about
        if model is not OMIT:
            _request["model"] = model
        if instructions is not OMIT:
            _request["instructions"] = instructions
        if default_settings is not OMIT:
            _request["default_settings"] = default_settings
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"agents/{id}"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AgentsRoutePatchResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agent_docs_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: AgentDocsRouteListRequestSortBy,
        direction: AgentDocsRouteListRequestDirection,
        metadata_filter: str,
    ) -> AgentDocsRouteListResponse:
        """
        List undefined items of parent undefined

        Parameters:
            - id: CommonUuid. ID of parent undefined

            - limit: CommonLimit. Limit the number of undefined items returned

            - offset: CommonOffset. Offset the undefined items returned

            - sort_by: AgentDocsRouteListRequestSortBy. Sort by a field

            - direction: AgentDocsRouteListRequestDirection. Sort direction

            - metadata_filter: str. JSON string of object that should be used to filter objects by metadata
        ---
        from julep import (
            AgentDocsRouteListRequestDirection,
            AgentDocsRouteListRequestSortBy,
        )
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agent_docs_route_list(
            id="id",
            limit=1,
            offset=1,
            sort_by=AgentDocsRouteListRequestSortBy.CREATED_AT,
            direction=AgentDocsRouteListRequestDirection.ASC,
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"agents/{id}/docs"
            ),
            params=remove_none_from_dict(
                {
                    "limit": limit,
                    "offset": offset,
                    "sort_by": sort_by,
                    "direction": direction,
                    "metadata_filter": metadata_filter,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AgentDocsRouteListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agents_docs_search_route_search(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: AgentsDocsSearchRouteSearchRequestSortBy,
        direction: AgentsDocsSearchRouteSearchRequestDirection,
        metadata_filter: str,
        body: DocsDocSearchRequest,
    ) -> AgentsDocsSearchRouteSearchResponse:
        """
        Search for documents owned by undefined

        Parameters:
            - id: CommonUuid. ID of the undefined

            - limit: CommonLimit. Limit the number of undefined items returned

            - offset: CommonOffset. Offset the undefined items returned

            - sort_by: AgentsDocsSearchRouteSearchRequestSortBy. Sort by a field

            - direction: AgentsDocsSearchRouteSearchRequestDirection. Sort direction

            - metadata_filter: str. JSON string of object that should be used to filter objects by metadata

            - body: DocsDocSearchRequest.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"agents/{id}/search"
            ),
            params=remove_none_from_dict(
                {
                    "limit": limit,
                    "offset": offset,
                    "sort_by": sort_by,
                    "direction": direction,
                    "metadata_filter": metadata_filter,
                }
            ),
            json=jsonable_encoder({"body": body}),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AgentsDocsSearchRouteSearchResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agent_tools_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: AgentToolsRouteListRequestSortBy,
        direction: AgentToolsRouteListRequestDirection,
        metadata_filter: str,
    ) -> AgentToolsRouteListResponse:
        """
        List undefined items of parent undefined

        Parameters:
            - id: CommonUuid. ID of parent undefined

            - limit: CommonLimit. Limit the number of undefined items returned

            - offset: CommonOffset. Offset the undefined items returned

            - sort_by: AgentToolsRouteListRequestSortBy. Sort by a field

            - direction: AgentToolsRouteListRequestDirection. Sort direction

            - metadata_filter: str. JSON string of object that should be used to filter objects by metadata
        ---
        from julep import (
            AgentToolsRouteListRequestDirection,
            AgentToolsRouteListRequestSortBy,
        )
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agent_tools_route_list(
            id="id",
            limit=1,
            offset=1,
            sort_by=AgentToolsRouteListRequestSortBy.CREATED_AT,
            direction=AgentToolsRouteListRequestDirection.ASC,
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"agents/{id}/tools"
            ),
            params=remove_none_from_dict(
                {
                    "limit": limit,
                    "offset": offset,
                    "sort_by": sort_by,
                    "direction": direction,
                    "metadata_filter": metadata_filter,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AgentToolsRouteListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agent_tools_route_create(
        self, id: CommonUuid, *, request: AgentsCreateAgentRequest
    ) -> AgentToolsRouteCreateResponse:
        """
        Create new undefined

        Parameters:
            - id: CommonUuid. ID of parent undefined

            - request: AgentsCreateAgentRequest.
        ---
        from julep import AgentsCreateAgentRequest
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agent_tools_route_create(
            id="id",
            request=AgentsCreateAgentRequest(
                name="name",
                about="about",
                model="model",
                docs=[],
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"agents/{id}/tools"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AgentToolsRouteCreateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def individual_docs_route_get(self, id: CommonUuid) -> DocsDoc:
        """
        Get undefined by id

        Parameters:
            - id: CommonUuid. ID of the undefined
        ---
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.individual_docs_route_get(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"docs/{id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DocsDoc, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def individual_docs_route_delete(
        self, id: CommonUuid
    ) -> IndividualDocsRouteDeleteResponse:
        """
        Delete undefined by id

        Parameters:
            - id: CommonUuid. ID of the undefined
        ---
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.individual_docs_route_delete(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"docs/{id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(IndividualDocsRouteDeleteResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def executions_route_get(self, id: CommonUuid) -> ExecutionsExecution:
        """
        Get undefined by id

        Parameters:
            - id: CommonUuid. ID of the undefined
        ---
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.executions_route_get(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"executions/{id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ExecutionsExecution, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def executions_route_update(
        self, id: CommonUuid, *, request: ExecutionsUpdateExecutionRequest
    ) -> ExecutionsRouteUpdateResponse:
        """
        Update undefined by id (overwrite)

        Parameters:
            - id: CommonUuid. ID of the undefined

            - request: ExecutionsUpdateExecutionRequest.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"executions/{id}"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ExecutionsRouteUpdateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def execution_transitions_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: ExecutionTransitionsRouteListRequestSortBy,
        direction: ExecutionTransitionsRouteListRequestDirection,
        metadata_filter: str,
    ) -> ExecutionTransitionsRouteListResponse:
        """
        List undefined items of parent undefined

        Parameters:
            - id: CommonUuid. ID of parent undefined

            - limit: CommonLimit. Limit the number of undefined items returned

            - offset: CommonOffset. Offset the undefined items returned

            - sort_by: ExecutionTransitionsRouteListRequestSortBy. Sort by a field

            - direction: ExecutionTransitionsRouteListRequestDirection. Sort direction

            - metadata_filter: str. JSON string of object that should be used to filter objects by metadata
        ---
        from julep import (
            ExecutionTransitionsRouteListRequestDirection,
            ExecutionTransitionsRouteListRequestSortBy,
        )
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.execution_transitions_route_list(
            id="id",
            limit=1,
            offset=1,
            sort_by=ExecutionTransitionsRouteListRequestSortBy.CREATED_AT,
            direction=ExecutionTransitionsRouteListRequestDirection.ASC,
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"executions/{id}/transitions",
            ),
            params=remove_none_from_dict(
                {
                    "limit": limit,
                    "offset": offset,
                    "sort_by": sort_by,
                    "direction": direction,
                    "metadata_filter": metadata_filter,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ExecutionTransitionsRouteListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def job_route_get(self, id: CommonUuid) -> JobsJobStatus:
        """
        Get undefined by id

        Parameters:
            - id: CommonUuid. ID of the undefined
        ---
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.job_route_get(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"jobs/{id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(JobsJobStatus, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def sessions_route_list(
        self,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: SessionsRouteListRequestSortBy,
        direction: SessionsRouteListRequestDirection,
        metadata_filter: str,
    ) -> SessionsRouteListResponse:
        """
        List undefined items

        Parameters:
            - limit: CommonLimit. Limit the number of undefined items returned

            - offset: CommonOffset. Offset the undefined items returned

            - sort_by: SessionsRouteListRequestSortBy. Sort by a field

            - direction: SessionsRouteListRequestDirection. Sort direction

            - metadata_filter: str. JSON string of object that should be used to filter objects by metadata
        ---
        from julep import (
            SessionsRouteListRequestDirection,
            SessionsRouteListRequestSortBy,
        )
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.sessions_route_list(
            limit=1,
            offset=1,
            sort_by=SessionsRouteListRequestSortBy.CREATED_AT,
            direction=SessionsRouteListRequestDirection.ASC,
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "sessions"),
            params=remove_none_from_dict(
                {
                    "limit": limit,
                    "offset": offset,
                    "sort_by": sort_by,
                    "direction": direction,
                    "metadata_filter": metadata_filter,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SessionsRouteListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def sessions_route_create(
        self,
        *,
        user: typing.Optional[CommonUuid] = OMIT,
        users: typing.Optional[typing.List[CommonUuid]] = OMIT,
        agent: typing.Optional[CommonUuid] = OMIT,
        agents: typing.Optional[typing.List[CommonUuid]] = OMIT,
        situation: str,
        render_templates: bool,
        token_budget: typing.Optional[int] = OMIT,
        context_overflow: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
    ) -> SessionsRouteCreateResponse:
        """
        Create new undefined

        Parameters:
            - user: typing.Optional[CommonUuid]. User ID of user associated with this session

            - users: typing.Optional[typing.List[CommonUuid]].

            - agent: typing.Optional[CommonUuid]. Agent ID of agent associated with this session

            - agents: typing.Optional[typing.List[CommonUuid]].

            - situation: str. A specific situation that sets the background for this session

            - render_templates: bool. Render system and assistant message content as jinja templates

            - token_budget: typing.Optional[int]. Threshold value for the adaptive context functionality

            - context_overflow: typing.Optional[str]. Action to start on context window overflow

            - metadata: typing.Optional[typing.Dict[str, typing.Any]].
        ---
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.sessions_route_create(
            situation="situation",
            render_templates=True,
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "situation": situation,
            "render_templates": render_templates,
        }
        if user is not OMIT:
            _request["user"] = user
        if users is not OMIT:
            _request["users"] = users
        if agent is not OMIT:
            _request["agent"] = agent
        if agents is not OMIT:
            _request["agents"] = agents
        if token_budget is not OMIT:
            _request["token_budget"] = token_budget
        if context_overflow is not OMIT:
            _request["context_overflow"] = context_overflow
        if metadata is not OMIT:
            _request["metadata"] = metadata
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "sessions"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SessionsRouteCreateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def sessions_route_create_or_update(
        self,
        *,
        id: CommonUuid,
        user: typing.Optional[CommonUuid] = OMIT,
        users: typing.Optional[typing.List[CommonUuid]] = OMIT,
        agent: typing.Optional[CommonUuid] = OMIT,
        agents: typing.Optional[typing.List[CommonUuid]] = OMIT,
        situation: str,
        render_templates: bool,
        token_budget: typing.Optional[int] = OMIT,
        context_overflow: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
    ) -> SessionsRouteCreateOrUpdateResponse:
        """
        Create or update undefined (ID is required in payload; existing resource will be overwritten)

        Parameters:
            - id: CommonUuid.

            - user: typing.Optional[CommonUuid]. User ID of user associated with this session

            - users: typing.Optional[typing.List[CommonUuid]].

            - agent: typing.Optional[CommonUuid]. Agent ID of agent associated with this session

            - agents: typing.Optional[typing.List[CommonUuid]].

            - situation: str. A specific situation that sets the background for this session

            - render_templates: bool. Render system and assistant message content as jinja templates

            - token_budget: typing.Optional[int]. Threshold value for the adaptive context functionality

            - context_overflow: typing.Optional[str]. Action to start on context window overflow

            - metadata: typing.Optional[typing.Dict[str, typing.Any]].
        ---
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.sessions_route_create_or_update(
            id="id",
            situation="situation",
            render_templates=True,
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "id": id,
            "situation": situation,
            "render_templates": render_templates,
        }
        if user is not OMIT:
            _request["user"] = user
        if users is not OMIT:
            _request["users"] = users
        if agent is not OMIT:
            _request["agent"] = agent
        if agents is not OMIT:
            _request["agents"] = agents
        if token_budget is not OMIT:
            _request["token_budget"] = token_budget
        if context_overflow is not OMIT:
            _request["context_overflow"] = context_overflow
        if metadata is not OMIT:
            _request["metadata"] = metadata
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "sessions"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SessionsRouteCreateOrUpdateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def history_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: HistoryRouteListRequestSortBy,
        direction: HistoryRouteListRequestDirection,
        metadata_filter: str,
    ) -> HistoryRouteListResponse:
        """
        List undefined items of parent undefined

        Parameters:
            - id: CommonUuid. ID of parent undefined

            - limit: CommonLimit. Limit the number of undefined items returned

            - offset: CommonOffset. Offset the undefined items returned

            - sort_by: HistoryRouteListRequestSortBy. Sort by a field

            - direction: HistoryRouteListRequestDirection. Sort direction

            - metadata_filter: str. JSON string of object that should be used to filter objects by metadata
        ---
        from julep import (
            HistoryRouteListRequestDirection,
            HistoryRouteListRequestSortBy,
        )
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.history_route_list(
            id="id",
            limit=1,
            offset=1,
            sort_by=HistoryRouteListRequestSortBy.CREATED_AT,
            direction=HistoryRouteListRequestDirection.ASC,
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"sessions/history/{id}"
            ),
            params=remove_none_from_dict(
                {
                    "limit": limit,
                    "offset": offset,
                    "sort_by": sort_by,
                    "direction": direction,
                    "metadata_filter": metadata_filter,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(HistoryRouteListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def history_route_delete(self, id: CommonUuid) -> HistoryRouteDeleteResponse:
        """
        Delete undefined by id

        Parameters:
            - id: CommonUuid. ID of the undefined
        ---
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.history_route_delete(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"sessions/history/{id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(HistoryRouteDeleteResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def sessions_route_get(self, id: CommonUuid) -> SessionsSession:
        """
        Get undefined by id

        Parameters:
            - id: CommonUuid. ID of the undefined
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"sessions/{id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SessionsSession, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def sessions_route_update(
        self,
        id: CommonUuid,
        *,
        situation: str,
        render_templates: bool,
        token_budget: typing.Optional[int] = OMIT,
        context_overflow: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
    ) -> SessionsRouteUpdateResponse:
        """
        Update undefined by id (overwrite)

        Parameters:
            - id: CommonUuid. ID of the undefined

            - situation: str. A specific situation that sets the background for this session

            - render_templates: bool. Render system and assistant message content as jinja templates

            - token_budget: typing.Optional[int]. Threshold value for the adaptive context functionality

            - context_overflow: typing.Optional[str]. Action to start on context window overflow

            - metadata: typing.Optional[typing.Dict[str, typing.Any]].
        ---
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.sessions_route_update(
            id="id",
            situation="situation",
            render_templates=True,
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "situation": situation,
            "render_templates": render_templates,
        }
        if token_budget is not OMIT:
            _request["token_budget"] = token_budget
        if context_overflow is not OMIT:
            _request["context_overflow"] = context_overflow
        if metadata is not OMIT:
            _request["metadata"] = metadata
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"sessions/{id}"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SessionsRouteUpdateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def sessions_route_delete(self, id: CommonUuid) -> SessionsRouteDeleteResponse:
        """
        Delete undefined by id

        Parameters:
            - id: CommonUuid. ID of the undefined
        ---
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.sessions_route_delete(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"sessions/{id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SessionsRouteDeleteResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def sessions_route_patch(
        self,
        id: CommonUuid,
        *,
        situation: typing.Optional[str] = OMIT,
        render_templates: typing.Optional[bool] = OMIT,
        token_budget: typing.Optional[int] = OMIT,
        context_overflow: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
    ) -> SessionsRoutePatchResponse:
        """
        Patch undefined by id (merge changes)

        Parameters:
            - id: CommonUuid. ID of the undefined

            - situation: typing.Optional[str]. A specific situation that sets the background for this session

            - render_templates: typing.Optional[bool]. Render system and assistant message content as jinja templates

            - token_budget: typing.Optional[int]. Threshold value for the adaptive context functionality

            - context_overflow: typing.Optional[str]. Action to start on context window overflow

            - metadata: typing.Optional[typing.Dict[str, typing.Any]].
        ---
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.sessions_route_patch(
            id="id",
        )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if situation is not OMIT:
            _request["situation"] = situation
        if render_templates is not OMIT:
            _request["render_templates"] = render_templates
        if token_budget is not OMIT:
            _request["token_budget"] = token_budget
        if context_overflow is not OMIT:
            _request["context_overflow"] = context_overflow
        if metadata is not OMIT:
            _request["metadata"] = metadata
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"sessions/{id}"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SessionsRoutePatchResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def tasks_route_list(
        self,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: TasksRouteListRequestSortBy,
        direction: TasksRouteListRequestDirection,
        metadata_filter: str,
    ) -> TasksRouteListResponse:
        """
        List undefined items

        Parameters:
            - limit: CommonLimit. Limit the number of undefined items returned

            - offset: CommonOffset. Offset the undefined items returned

            - sort_by: TasksRouteListRequestSortBy. Sort by a field

            - direction: TasksRouteListRequestDirection. Sort direction

            - metadata_filter: str. JSON string of object that should be used to filter objects by metadata
        ---
        from julep import TasksRouteListRequestDirection, TasksRouteListRequestSortBy
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.tasks_route_list(
            limit=1,
            offset=1,
            sort_by=TasksRouteListRequestSortBy.CREATED_AT,
            direction=TasksRouteListRequestDirection.ASC,
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "tasks"),
            params=remove_none_from_dict(
                {
                    "limit": limit,
                    "offset": offset,
                    "sort_by": sort_by,
                    "direction": direction,
                    "metadata_filter": metadata_filter,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TasksRouteListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def tasks_route_create(
        self,
        *,
        name: str,
        description: str,
        main: typing.List[TasksWorkflowStep],
        input_schema: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        tools: typing.List[ToolsCreateToolRequest],
        inherit_tools: bool,
    ) -> TasksRouteCreateResponse:
        """
        Create new undefined

        Parameters:
            - name: str.

            - description: str.

            - main: typing.List[TasksWorkflowStep]. The entrypoint of the task.

            - input_schema: typing.Optional[typing.Dict[str, typing.Any]]. The schema for the input to the task. `null` means all inputs are valid.

            - tools: typing.List[ToolsCreateToolRequest]. Tools defined specifically for this task not included in the Agent itself.

            - inherit_tools: bool. Whether to inherit tools from the parent agent or not. Defaults to true.
        ---
        from julep import ToolsCreateToolRequest, ToolsToolType
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.tasks_route_create(
            name="name",
            description="description",
            main=[],
            tools=[
                ToolsCreateToolRequest(
                    type=ToolsToolType.FUNCTION,
                    background=True,
                    interactive=True,
                )
            ],
            inherit_tools=True,
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "name": name,
            "description": description,
            "main": main,
            "tools": tools,
            "inherit_tools": inherit_tools,
        }
        if input_schema is not OMIT:
            _request["input_schema"] = input_schema
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "tasks"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TasksRouteCreateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def tasks_route_create_or_update(
        self,
        *,
        id: CommonUuid,
        name: str,
        description: str,
        main: typing.List[TasksWorkflowStep],
        input_schema: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        tools: typing.List[ToolsCreateToolRequest],
        inherit_tools: bool,
    ) -> TasksRouteCreateOrUpdateResponse:
        """
        Create or update undefined (ID is required in payload; existing resource will be overwritten)

        Parameters:
            - id: CommonUuid.

            - name: str.

            - description: str.

            - main: typing.List[TasksWorkflowStep]. The entrypoint of the task.

            - input_schema: typing.Optional[typing.Dict[str, typing.Any]]. The schema for the input to the task. `null` means all inputs are valid.

            - tools: typing.List[ToolsCreateToolRequest]. Tools defined specifically for this task not included in the Agent itself.

            - inherit_tools: bool. Whether to inherit tools from the parent agent or not. Defaults to true.
        ---
        from julep import ToolsCreateToolRequest, ToolsToolType
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.tasks_route_create_or_update(
            id="id",
            name="name",
            description="description",
            main=[],
            tools=[
                ToolsCreateToolRequest(
                    type=ToolsToolType.FUNCTION,
                    background=True,
                    interactive=True,
                )
            ],
            inherit_tools=True,
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "id": id,
            "name": name,
            "description": description,
            "main": main,
            "tools": tools,
            "inherit_tools": inherit_tools,
        }
        if input_schema is not OMIT:
            _request["input_schema"] = input_schema
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "tasks"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TasksRouteCreateOrUpdateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def tasks_route_update(
        self,
        id: CommonUuid,
        *,
        description: str,
        main: typing.List[TasksWorkflowStep],
        input_schema: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        tools: typing.List[ToolsCreateToolRequest],
        inherit_tools: bool,
    ) -> TasksRouteUpdateResponse:
        """
        Update undefined by id (overwrite)

        Parameters:
            - id: CommonUuid. ID of the undefined

            - description: str.

            - main: typing.List[TasksWorkflowStep]. The entrypoint of the task.

            - input_schema: typing.Optional[typing.Dict[str, typing.Any]]. The schema for the input to the task. `null` means all inputs are valid.

            - tools: typing.List[ToolsCreateToolRequest]. Tools defined specifically for this task not included in the Agent itself.

            - inherit_tools: bool. Whether to inherit tools from the parent agent or not. Defaults to true.
        ---
        from julep import ToolsCreateToolRequest, ToolsToolType
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.tasks_route_update(
            id="id",
            description="description",
            main=[],
            tools=[
                ToolsCreateToolRequest(
                    type=ToolsToolType.FUNCTION,
                    background=True,
                    interactive=True,
                )
            ],
            inherit_tools=True,
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "description": description,
            "main": main,
            "tools": tools,
            "inherit_tools": inherit_tools,
        }
        if input_schema is not OMIT:
            _request["input_schema"] = input_schema
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"tasks/{id}"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TasksRouteUpdateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def tasks_route_delete(self, id: CommonUuid) -> TasksRouteDeleteResponse:
        """
        Delete undefined by id

        Parameters:
            - id: CommonUuid. ID of the undefined
        ---
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.tasks_route_delete(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"tasks/{id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TasksRouteDeleteResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def tasks_route_patch(
        self,
        id: CommonUuid,
        *,
        description: typing.Optional[str] = OMIT,
        main: typing.Optional[typing.List[TasksWorkflowStep]] = OMIT,
        input_schema: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        tools: typing.Optional[typing.List[ToolsCreateToolRequest]] = OMIT,
        inherit_tools: typing.Optional[bool] = OMIT,
    ) -> TasksRoutePatchResponse:
        """
        Patch undefined by id (merge changes)

        Parameters:
            - id: CommonUuid. ID of the undefined

            - description: typing.Optional[str].

            - main: typing.Optional[typing.List[TasksWorkflowStep]]. The entrypoint of the task.

            - input_schema: typing.Optional[typing.Dict[str, typing.Any]]. The schema for the input to the task. `null` means all inputs are valid.

            - tools: typing.Optional[typing.List[ToolsCreateToolRequest]]. Tools defined specifically for this task not included in the Agent itself.

            - inherit_tools: typing.Optional[bool]. Whether to inherit tools from the parent agent or not. Defaults to true.
        ---
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.tasks_route_patch(
            id="id",
        )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if description is not OMIT:
            _request["description"] = description
        if main is not OMIT:
            _request["main"] = main
        if input_schema is not OMIT:
            _request["input_schema"] = input_schema
        if tools is not OMIT:
            _request["tools"] = tools
        if inherit_tools is not OMIT:
            _request["inherit_tools"] = inherit_tools
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"tasks/{id}"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TasksRoutePatchResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def task_executions_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: TaskExecutionsRouteListRequestSortBy,
        direction: TaskExecutionsRouteListRequestDirection,
        metadata_filter: str,
    ) -> TaskExecutionsRouteListResponse:
        """
        List undefined items of parent undefined

        Parameters:
            - id: CommonUuid. ID of parent undefined

            - limit: CommonLimit. Limit the number of undefined items returned

            - offset: CommonOffset. Offset the undefined items returned

            - sort_by: TaskExecutionsRouteListRequestSortBy. Sort by a field

            - direction: TaskExecutionsRouteListRequestDirection. Sort direction

            - metadata_filter: str. JSON string of object that should be used to filter objects by metadata
        ---
        from julep import (
            TaskExecutionsRouteListRequestDirection,
            TaskExecutionsRouteListRequestSortBy,
        )
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.task_executions_route_list(
            id="id",
            limit=1,
            offset=1,
            sort_by=TaskExecutionsRouteListRequestSortBy.CREATED_AT,
            direction=TaskExecutionsRouteListRequestDirection.ASC,
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"tasks/{id}/executions"
            ),
            params=remove_none_from_dict(
                {
                    "limit": limit,
                    "offset": offset,
                    "sort_by": sort_by,
                    "direction": direction,
                    "metadata_filter": metadata_filter,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TaskExecutionsRouteListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def task_executions_route_create(
        self, id: CommonUuid, *, input: typing.Dict[str, typing.Any]
    ) -> TaskExecutionsRouteCreateResponse:
        """
        Create new undefined

        Parameters:
            - id: CommonUuid. ID of parent undefined

            - input: typing.Dict[str, typing.Any]. The input to the execution
        ---
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.task_executions_route_create(
            id="id",
            input={},
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"tasks/{id}/executions"
            ),
            json=jsonable_encoder({"input": input}),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TaskExecutionsRouteCreateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def task_executions_route_resume_with_task_token(
        self,
        id: CommonUuid,
        *,
        task_token: str,
        input: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
    ) -> TaskExecutionsRouteResumeWithTaskTokenResponse:
        """
        Resume an execution with a task token

        Parameters:
            - id: CommonUuid. ID of parent Task

            - task_token: str. A Task Token is a unique identifier for a specific Task Execution.

            - input: typing.Optional[typing.Dict[str, typing.Any]]. The input to resume the execution with
        ---
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.task_executions_route_resume_with_task_token(
            id="id",
            status="running",
            task_token="task_token",
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "status": status,
            "task_token": task_token,
        }
        if input is not OMIT:
            _request["input"] = input
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"tasks/{id}/executions"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TaskExecutionsRouteResumeWithTaskTokenResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def tool_route_update(
        self,
        id: CommonUuid,
        *,
        type: ToolsToolType,
        background: bool,
        interactive: bool,
        function: typing.Optional[ToolsFunctionDef] = OMIT,
        integration: typing.Optional[typing.Any] = OMIT,
        system: typing.Optional[typing.Any] = OMIT,
        api_call: typing.Optional[typing.Any] = OMIT,
    ) -> ToolRouteUpdateResponse:
        """
        Update undefined by id (overwrite)

        Parameters:
            - id: CommonUuid. ID of the undefined

            - type: ToolsToolType. Whether this tool is a `function`, `api_call`, `system` etc. (Only `function` tool supported right now)

            - background: bool. The tool should be run in the background (not supported at the moment)

            - interactive: bool. Whether the tool that can be run interactively (response should contain "stop" boolean field)

            - function: typing.Optional[ToolsFunctionDef].

            - integration: typing.Optional[typing.Any].

            - system: typing.Optional[typing.Any].

            - api_call: typing.Optional[typing.Any].
        ---
        from julep import ToolsToolType
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.tool_route_update(
            id="id",
            type=ToolsToolType.FUNCTION,
            background=True,
            interactive=True,
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "type": type.value,
            "background": background,
            "interactive": interactive,
        }
        if function is not OMIT:
            _request["function"] = function
        if integration is not OMIT:
            _request["integration"] = integration
        if system is not OMIT:
            _request["system"] = system
        if api_call is not OMIT:
            _request["api_call"] = api_call
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"tools/{id}"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ToolRouteUpdateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def tool_route_delete(self, id: CommonUuid) -> ToolRouteDeleteResponse:
        """
        Delete undefined by id

        Parameters:
            - id: CommonUuid. ID of the undefined
        ---
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.tool_route_delete(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"tools/{id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ToolRouteDeleteResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def tool_route_patch(
        self,
        id: CommonUuid,
        *,
        type: typing.Optional[ToolsToolType] = OMIT,
        background: typing.Optional[bool] = OMIT,
        interactive: typing.Optional[bool] = OMIT,
        function: typing.Optional[ToolsFunctionDefUpdate] = OMIT,
        integration: typing.Optional[typing.Any] = OMIT,
        system: typing.Optional[typing.Any] = OMIT,
        api_call: typing.Optional[typing.Any] = OMIT,
    ) -> ToolRoutePatchResponse:
        """
        Patch undefined by id (merge changes)

        Parameters:
            - id: CommonUuid. ID of the undefined

            - type: typing.Optional[ToolsToolType]. Whether this tool is a `function`, `api_call`, `system` etc. (Only `function` tool supported right now)

            - background: typing.Optional[bool]. The tool should be run in the background (not supported at the moment)

            - interactive: typing.Optional[bool]. Whether the tool that can be run interactively (response should contain "stop" boolean field)

            - function: typing.Optional[ToolsFunctionDefUpdate].

            - integration: typing.Optional[typing.Any].

            - system: typing.Optional[typing.Any].

            - api_call: typing.Optional[typing.Any].
        ---
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.tool_route_patch(
            id="id",
        )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if type is not OMIT:
            _request["type"] = type.value
        if background is not OMIT:
            _request["background"] = background
        if interactive is not OMIT:
            _request["interactive"] = interactive
        if function is not OMIT:
            _request["function"] = function
        if integration is not OMIT:
            _request["integration"] = integration
        if system is not OMIT:
            _request["system"] = system
        if api_call is not OMIT:
            _request["api_call"] = api_call
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"tools/{id}"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ToolRoutePatchResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def users_route_list(
        self,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: UsersRouteListRequestSortBy,
        direction: UsersRouteListRequestDirection,
        metadata_filter: str,
    ) -> UsersRouteListResponse:
        """
        List undefined items

        Parameters:
            - limit: CommonLimit. Limit the number of undefined items returned

            - offset: CommonOffset. Offset the undefined items returned

            - sort_by: UsersRouteListRequestSortBy. Sort by a field

            - direction: UsersRouteListRequestDirection. Sort direction

            - metadata_filter: str. JSON string of object that should be used to filter objects by metadata
        ---
        from julep import UsersRouteListRequestDirection, UsersRouteListRequestSortBy
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.users_route_list(
            limit=1,
            offset=1,
            sort_by=UsersRouteListRequestSortBy.CREATED_AT,
            direction=UsersRouteListRequestDirection.ASC,
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "users"),
            params=remove_none_from_dict(
                {
                    "limit": limit,
                    "offset": offset,
                    "sort_by": sort_by,
                    "direction": direction,
                    "metadata_filter": metadata_filter,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UsersRouteListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def users_route_create(
        self,
        *,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        name: CommonIdentifierSafeUnicode,
        about: str,
        docs: typing.List[typing.Any],
    ) -> UsersRouteCreateResponse:
        """
        Create new undefined

        Parameters:
            - metadata: typing.Optional[typing.Dict[str, typing.Any]].

            - name: CommonIdentifierSafeUnicode. Name of the user

            - about: str. About the user

            - docs: typing.List[typing.Any]. Documents to index for this user. (Max: 100 items)
        ---
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.users_route_create(
            name="name",
            about="about",
            docs=[],
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "name": name,
            "about": about,
            "docs": docs,
        }
        if metadata is not OMIT:
            _request["metadata"] = metadata
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "users"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UsersRouteCreateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def users_route_create_or_update(
        self,
        *,
        id: CommonUuid,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        name: CommonIdentifierSafeUnicode,
        about: str,
    ) -> UsersRouteCreateOrUpdateResponse:
        """
        Create or update undefined (ID is required in payload; existing resource will be overwritten)

        Parameters:
            - id: CommonUuid.

            - metadata: typing.Optional[typing.Dict[str, typing.Any]].

            - name: CommonIdentifierSafeUnicode. Name of the user

            - about: str. About the user
        ---
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.users_route_create_or_update(
            id="id",
            name="name",
            about="about",
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "id": id,
            "name": name,
            "about": about,
        }
        if metadata is not OMIT:
            _request["metadata"] = metadata
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "users"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UsersRouteCreateOrUpdateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def users_route_get(self, id: CommonUuid) -> UsersUser:
        """
        Get undefined by id

        Parameters:
            - id: CommonUuid. ID of the undefined
        ---
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.users_route_get(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"users/{id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UsersUser, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def users_route_update(
        self,
        id: CommonUuid,
        *,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        name: CommonIdentifierSafeUnicode,
        about: str,
    ) -> UsersRouteUpdateResponse:
        """
        Update undefined by id (overwrite)

        Parameters:
            - id: CommonUuid. ID of the undefined

            - metadata: typing.Optional[typing.Dict[str, typing.Any]].

            - name: CommonIdentifierSafeUnicode. Name of the user

            - about: str. About the user
        ---
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.users_route_update(
            id="id",
            name="name",
            about="about",
        )
        """
        _request: typing.Dict[str, typing.Any] = {"name": name, "about": about}
        if metadata is not OMIT:
            _request["metadata"] = metadata
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"users/{id}"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UsersRouteUpdateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def users_route_delete(self, id: CommonUuid) -> UsersRouteDeleteResponse:
        """
        Delete undefined by id

        Parameters:
            - id: CommonUuid. ID of the undefined
        ---
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.users_route_delete(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"users/{id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UsersRouteDeleteResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def users_route_patch(
        self,
        id: CommonUuid,
        *,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        name: typing.Optional[CommonIdentifierSafeUnicode] = OMIT,
        about: typing.Optional[str] = OMIT,
    ) -> UsersRoutePatchResponse:
        """
        Patch undefined by id (merge changes)

        Parameters:
            - id: CommonUuid. ID of the undefined

            - metadata: typing.Optional[typing.Dict[str, typing.Any]].

            - name: typing.Optional[CommonIdentifierSafeUnicode]. Name of the user

            - about: typing.Optional[str]. About the user
        ---
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.users_route_patch(
            id="id",
        )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if metadata is not OMIT:
            _request["metadata"] = metadata
        if name is not OMIT:
            _request["name"] = name
        if about is not OMIT:
            _request["about"] = about
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"users/{id}"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UsersRoutePatchResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def user_docs_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: UserDocsRouteListRequestSortBy,
        direction: UserDocsRouteListRequestDirection,
        metadata_filter: str,
    ) -> UserDocsRouteListResponse:
        """
        List undefined items of parent undefined

        Parameters:
            - id: CommonUuid. ID of parent undefined

            - limit: CommonLimit. Limit the number of undefined items returned

            - offset: CommonOffset. Offset the undefined items returned

            - sort_by: UserDocsRouteListRequestSortBy. Sort by a field

            - direction: UserDocsRouteListRequestDirection. Sort direction

            - metadata_filter: str. JSON string of object that should be used to filter objects by metadata
        ---
        from julep import (
            UserDocsRouteListRequestDirection,
            UserDocsRouteListRequestSortBy,
        )
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.user_docs_route_list(
            id="id",
            limit=1,
            offset=1,
            sort_by=UserDocsRouteListRequestSortBy.CREATED_AT,
            direction=UserDocsRouteListRequestDirection.ASC,
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"users/{id}/docs"
            ),
            params=remove_none_from_dict(
                {
                    "limit": limit,
                    "offset": offset,
                    "sort_by": sort_by,
                    "direction": direction,
                    "metadata_filter": metadata_filter,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UserDocsRouteListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def user_docs_search_route_search(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: UserDocsSearchRouteSearchRequestSortBy,
        direction: UserDocsSearchRouteSearchRequestDirection,
        metadata_filter: str,
        body: DocsDocSearchRequest,
    ) -> UserDocsSearchRouteSearchResponse:
        """
        Search for documents owned by undefined

        Parameters:
            - id: CommonUuid. ID of the undefined

            - limit: CommonLimit. Limit the number of undefined items returned

            - offset: CommonOffset. Offset the undefined items returned

            - sort_by: UserDocsSearchRouteSearchRequestSortBy. Sort by a field

            - direction: UserDocsSearchRouteSearchRequestDirection. Sort direction

            - metadata_filter: str. JSON string of object that should be used to filter objects by metadata

            - body: DocsDocSearchRequest.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"users/{id}/search"
            ),
            params=remove_none_from_dict(
                {
                    "limit": limit,
                    "offset": offset,
                    "sort_by": sort_by,
                    "direction": direction,
                    "metadata_filter": metadata_filter,
                }
            ),
            json=jsonable_encoder({"body": body}),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UserDocsSearchRouteSearchResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncJulepApi:
    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: JulepApiEnvironment = JulepApiEnvironment.DEFAULT,
        auth_key: str,
        api_key: str,
        timeout: typing.Optional[float] = 300,
        httpx_client: typing.Optional[httpx.AsyncClient] = None,
    ):
        self._client_wrapper = AsyncClientWrapper(
            base_url=_get_base_url(base_url=base_url, environment=environment),
            auth_key=auth_key,
            api_key=api_key,
            httpx_client=(
                httpx.AsyncClient(timeout=timeout)
                if httpx_client is None
                else httpx_client
            ),
        )

    async def agents_route_list(
        self,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: AgentsRouteListRequestSortBy,
        direction: AgentsRouteListRequestDirection,
        metadata_filter: str,
    ) -> AgentsRouteListResponse:
        """
        List undefined items

        Parameters:
            - limit: CommonLimit. Limit the number of undefined items returned

            - offset: CommonOffset. Offset the undefined items returned

            - sort_by: AgentsRouteListRequestSortBy. Sort by a field

            - direction: AgentsRouteListRequestDirection. Sort direction

            - metadata_filter: str. JSON string of object that should be used to filter objects by metadata
        ---
        from julep import AgentsRouteListRequestDirection, AgentsRouteListRequestSortBy
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.agents_route_list(
            limit=1,
            offset=1,
            sort_by=AgentsRouteListRequestSortBy.CREATED_AT,
            direction=AgentsRouteListRequestDirection.ASC,
            metadata_filter="metadata_filter",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "agents"),
            params=remove_none_from_dict(
                {
                    "limit": limit,
                    "offset": offset,
                    "sort_by": sort_by,
                    "direction": direction,
                    "metadata_filter": metadata_filter,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AgentsRouteListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agents_route_create(
        self, *, request: AgentsCreateAgentRequest
    ) -> AgentsRouteCreateResponse:
        """
        Create new undefined

        Parameters:
            - request: AgentsCreateAgentRequest.
        ---
        from julep import AgentsCreateAgentRequest
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.agents_route_create(
            request=AgentsCreateAgentRequest(
                name="name",
                about="about",
                model="model",
                docs=[],
            ),
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "agents"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AgentsRouteCreateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agents_route_create_or_update(
        self,
        *,
        id: CommonUuid,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        name: CommonIdentifierSafeUnicode,
        about: str,
        model: str,
        instructions: AgentsCreateOrUpdateAgentRequestInstructions,
        default_settings: typing.Optional[
            AgentsCreateOrUpdateAgentRequestDefaultSettings
        ] = OMIT,
    ) -> AgentsRouteCreateOrUpdateResponse:
        """
        Create or update undefined (ID is required in payload; existing resource will be overwritten)

        Parameters:
            - id: CommonUuid.

            - metadata: typing.Optional[typing.Dict[str, typing.Any]].

            - name: CommonIdentifierSafeUnicode. Name of the agent

            - about: str. About the agent

            - model: str. Model name to use (gpt-4-turbo, gemini-nano etc)

            - instructions: AgentsCreateOrUpdateAgentRequestInstructions. Instructions for the agent

            - default_settings: typing.Optional[AgentsCreateOrUpdateAgentRequestDefaultSettings]. Default settings for all sessions created by this agent
        ---
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.agents_route_create_or_update(
            id="id",
            name="name",
            about="about",
            model="model",
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "id": id,
            "name": name,
            "about": about,
            "model": model,
            "instructions": instructions,
        }
        if metadata is not OMIT:
            _request["metadata"] = metadata
        if default_settings is not OMIT:
            _request["default_settings"] = default_settings
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "agents"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AgentsRouteCreateOrUpdateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agents_route_get(self, id: CommonUuid) -> AgentsAgent:
        """
        Get undefined by id

        Parameters:
            - id: CommonUuid. ID of the undefined
        ---
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.agents_route_get(
            id="id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"agents/{id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AgentsAgent, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agents_route_update(
        self,
        id: CommonUuid,
        *,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        name: CommonIdentifierSafeUnicode,
        about: str,
        model: str,
        instructions: AgentsUpdateAgentRequestInstructions,
        default_settings: typing.Optional[
            AgentsUpdateAgentRequestDefaultSettings
        ] = OMIT,
    ) -> AgentsRouteUpdateResponse:
        """
        Update undefined by id (overwrite)

        Parameters:
            - id: CommonUuid. ID of the undefined

            - metadata: typing.Optional[typing.Dict[str, typing.Any]].

            - name: CommonIdentifierSafeUnicode. Name of the agent

            - about: str. About the agent

            - model: str. Model name to use (gpt-4-turbo, gemini-nano etc)

            - instructions: AgentsUpdateAgentRequestInstructions. Instructions for the agent

            - default_settings: typing.Optional[AgentsUpdateAgentRequestDefaultSettings]. Default settings for all sessions created by this agent
        ---
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.agents_route_update(
            id="id",
            name="name",
            about="about",
            model="model",
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "name": name,
            "about": about,
            "model": model,
            "instructions": instructions,
        }
        if metadata is not OMIT:
            _request["metadata"] = metadata
        if default_settings is not OMIT:
            _request["default_settings"] = default_settings
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"agents/{id}"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AgentsRouteUpdateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agents_route_delete(self, id: CommonUuid) -> AgentsRouteDeleteResponse:
        """
        Delete undefined by id

        Parameters:
            - id: CommonUuid. ID of the undefined
        ---
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.agents_route_delete(
            id="id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"agents/{id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AgentsRouteDeleteResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agents_route_patch(
        self,
        id: CommonUuid,
        *,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        name: typing.Optional[CommonIdentifierSafeUnicode] = OMIT,
        about: typing.Optional[str] = OMIT,
        model: typing.Optional[str] = OMIT,
        instructions: typing.Optional[AgentsPatchAgentRequestInstructions] = OMIT,
        default_settings: typing.Optional[
            AgentsPatchAgentRequestDefaultSettings
        ] = OMIT,
    ) -> AgentsRoutePatchResponse:
        """
        Patch undefined by id (merge changes)

        Parameters:
            - id: CommonUuid. ID of the undefined

            - metadata: typing.Optional[typing.Dict[str, typing.Any]].

            - name: typing.Optional[CommonIdentifierSafeUnicode]. Name of the agent

            - about: typing.Optional[str]. About the agent

            - model: typing.Optional[str]. Model name to use (gpt-4-turbo, gemini-nano etc)

            - instructions: typing.Optional[AgentsPatchAgentRequestInstructions]. Instructions for the agent

            - default_settings: typing.Optional[AgentsPatchAgentRequestDefaultSettings]. Default settings for all sessions created by this agent
        ---
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.agents_route_patch(
            id="id",
        )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if metadata is not OMIT:
            _request["metadata"] = metadata
        if name is not OMIT:
            _request["name"] = name
        if about is not OMIT:
            _request["about"] = about
        if model is not OMIT:
            _request["model"] = model
        if instructions is not OMIT:
            _request["instructions"] = instructions
        if default_settings is not OMIT:
            _request["default_settings"] = default_settings
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"agents/{id}"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AgentsRoutePatchResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agent_docs_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: AgentDocsRouteListRequestSortBy,
        direction: AgentDocsRouteListRequestDirection,
        metadata_filter: str,
    ) -> AgentDocsRouteListResponse:
        """
        List undefined items of parent undefined

        Parameters:
            - id: CommonUuid. ID of parent undefined

            - limit: CommonLimit. Limit the number of undefined items returned

            - offset: CommonOffset. Offset the undefined items returned

            - sort_by: AgentDocsRouteListRequestSortBy. Sort by a field

            - direction: AgentDocsRouteListRequestDirection. Sort direction

            - metadata_filter: str. JSON string of object that should be used to filter objects by metadata
        ---
        from julep import (
            AgentDocsRouteListRequestDirection,
            AgentDocsRouteListRequestSortBy,
        )
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.agent_docs_route_list(
            id="id",
            limit=1,
            offset=1,
            sort_by=AgentDocsRouteListRequestSortBy.CREATED_AT,
            direction=AgentDocsRouteListRequestDirection.ASC,
            metadata_filter="metadata_filter",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"agents/{id}/docs"
            ),
            params=remove_none_from_dict(
                {
                    "limit": limit,
                    "offset": offset,
                    "sort_by": sort_by,
                    "direction": direction,
                    "metadata_filter": metadata_filter,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AgentDocsRouteListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agents_docs_search_route_search(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: AgentsDocsSearchRouteSearchRequestSortBy,
        direction: AgentsDocsSearchRouteSearchRequestDirection,
        metadata_filter: str,
        body: DocsDocSearchRequest,
    ) -> AgentsDocsSearchRouteSearchResponse:
        """
        Search for documents owned by undefined

        Parameters:
            - id: CommonUuid. ID of the undefined

            - limit: CommonLimit. Limit the number of undefined items returned

            - offset: CommonOffset. Offset the undefined items returned

            - sort_by: AgentsDocsSearchRouteSearchRequestSortBy. Sort by a field

            - direction: AgentsDocsSearchRouteSearchRequestDirection. Sort direction

            - metadata_filter: str. JSON string of object that should be used to filter objects by metadata

            - body: DocsDocSearchRequest.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"agents/{id}/search"
            ),
            params=remove_none_from_dict(
                {
                    "limit": limit,
                    "offset": offset,
                    "sort_by": sort_by,
                    "direction": direction,
                    "metadata_filter": metadata_filter,
                }
            ),
            json=jsonable_encoder({"body": body}),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AgentsDocsSearchRouteSearchResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agent_tools_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: AgentToolsRouteListRequestSortBy,
        direction: AgentToolsRouteListRequestDirection,
        metadata_filter: str,
    ) -> AgentToolsRouteListResponse:
        """
        List undefined items of parent undefined

        Parameters:
            - id: CommonUuid. ID of parent undefined

            - limit: CommonLimit. Limit the number of undefined items returned

            - offset: CommonOffset. Offset the undefined items returned

            - sort_by: AgentToolsRouteListRequestSortBy. Sort by a field

            - direction: AgentToolsRouteListRequestDirection. Sort direction

            - metadata_filter: str. JSON string of object that should be used to filter objects by metadata
        ---
        from julep import (
            AgentToolsRouteListRequestDirection,
            AgentToolsRouteListRequestSortBy,
        )
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.agent_tools_route_list(
            id="id",
            limit=1,
            offset=1,
            sort_by=AgentToolsRouteListRequestSortBy.CREATED_AT,
            direction=AgentToolsRouteListRequestDirection.ASC,
            metadata_filter="metadata_filter",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"agents/{id}/tools"
            ),
            params=remove_none_from_dict(
                {
                    "limit": limit,
                    "offset": offset,
                    "sort_by": sort_by,
                    "direction": direction,
                    "metadata_filter": metadata_filter,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AgentToolsRouteListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agent_tools_route_create(
        self, id: CommonUuid, *, request: AgentsCreateAgentRequest
    ) -> AgentToolsRouteCreateResponse:
        """
        Create new undefined

        Parameters:
            - id: CommonUuid. ID of parent undefined

            - request: AgentsCreateAgentRequest.
        ---
        from julep import AgentsCreateAgentRequest
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.agent_tools_route_create(
            id="id",
            request=AgentsCreateAgentRequest(
                name="name",
                about="about",
                model="model",
                docs=[],
            ),
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"agents/{id}/tools"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AgentToolsRouteCreateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def individual_docs_route_get(self, id: CommonUuid) -> DocsDoc:
        """
        Get undefined by id

        Parameters:
            - id: CommonUuid. ID of the undefined
        ---
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.individual_docs_route_get(
            id="id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"docs/{id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DocsDoc, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def individual_docs_route_delete(
        self, id: CommonUuid
    ) -> IndividualDocsRouteDeleteResponse:
        """
        Delete undefined by id

        Parameters:
            - id: CommonUuid. ID of the undefined
        ---
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.individual_docs_route_delete(
            id="id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"docs/{id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(IndividualDocsRouteDeleteResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def executions_route_get(self, id: CommonUuid) -> ExecutionsExecution:
        """
        Get undefined by id

        Parameters:
            - id: CommonUuid. ID of the undefined
        ---
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.executions_route_get(
            id="id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"executions/{id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ExecutionsExecution, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def executions_route_update(
        self, id: CommonUuid, *, request: ExecutionsUpdateExecutionRequest
    ) -> ExecutionsRouteUpdateResponse:
        """
        Update undefined by id (overwrite)

        Parameters:
            - id: CommonUuid. ID of the undefined

            - request: ExecutionsUpdateExecutionRequest.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"executions/{id}"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ExecutionsRouteUpdateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def execution_transitions_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: ExecutionTransitionsRouteListRequestSortBy,
        direction: ExecutionTransitionsRouteListRequestDirection,
        metadata_filter: str,
    ) -> ExecutionTransitionsRouteListResponse:
        """
        List undefined items of parent undefined

        Parameters:
            - id: CommonUuid. ID of parent undefined

            - limit: CommonLimit. Limit the number of undefined items returned

            - offset: CommonOffset. Offset the undefined items returned

            - sort_by: ExecutionTransitionsRouteListRequestSortBy. Sort by a field

            - direction: ExecutionTransitionsRouteListRequestDirection. Sort direction

            - metadata_filter: str. JSON string of object that should be used to filter objects by metadata
        ---
        from julep import (
            ExecutionTransitionsRouteListRequestDirection,
            ExecutionTransitionsRouteListRequestSortBy,
        )
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.execution_transitions_route_list(
            id="id",
            limit=1,
            offset=1,
            sort_by=ExecutionTransitionsRouteListRequestSortBy.CREATED_AT,
            direction=ExecutionTransitionsRouteListRequestDirection.ASC,
            metadata_filter="metadata_filter",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"executions/{id}/transitions",
            ),
            params=remove_none_from_dict(
                {
                    "limit": limit,
                    "offset": offset,
                    "sort_by": sort_by,
                    "direction": direction,
                    "metadata_filter": metadata_filter,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ExecutionTransitionsRouteListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def job_route_get(self, id: CommonUuid) -> JobsJobStatus:
        """
        Get undefined by id

        Parameters:
            - id: CommonUuid. ID of the undefined
        ---
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.job_route_get(
            id="id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"jobs/{id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(JobsJobStatus, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def sessions_route_list(
        self,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: SessionsRouteListRequestSortBy,
        direction: SessionsRouteListRequestDirection,
        metadata_filter: str,
    ) -> SessionsRouteListResponse:
        """
        List undefined items

        Parameters:
            - limit: CommonLimit. Limit the number of undefined items returned

            - offset: CommonOffset. Offset the undefined items returned

            - sort_by: SessionsRouteListRequestSortBy. Sort by a field

            - direction: SessionsRouteListRequestDirection. Sort direction

            - metadata_filter: str. JSON string of object that should be used to filter objects by metadata
        ---
        from julep import (
            SessionsRouteListRequestDirection,
            SessionsRouteListRequestSortBy,
        )
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.sessions_route_list(
            limit=1,
            offset=1,
            sort_by=SessionsRouteListRequestSortBy.CREATED_AT,
            direction=SessionsRouteListRequestDirection.ASC,
            metadata_filter="metadata_filter",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "sessions"),
            params=remove_none_from_dict(
                {
                    "limit": limit,
                    "offset": offset,
                    "sort_by": sort_by,
                    "direction": direction,
                    "metadata_filter": metadata_filter,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SessionsRouteListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def sessions_route_create(
        self,
        *,
        user: typing.Optional[CommonUuid] = OMIT,
        users: typing.Optional[typing.List[CommonUuid]] = OMIT,
        agent: typing.Optional[CommonUuid] = OMIT,
        agents: typing.Optional[typing.List[CommonUuid]] = OMIT,
        situation: str,
        render_templates: bool,
        token_budget: typing.Optional[int] = OMIT,
        context_overflow: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
    ) -> SessionsRouteCreateResponse:
        """
        Create new undefined

        Parameters:
            - user: typing.Optional[CommonUuid]. User ID of user associated with this session

            - users: typing.Optional[typing.List[CommonUuid]].

            - agent: typing.Optional[CommonUuid]. Agent ID of agent associated with this session

            - agents: typing.Optional[typing.List[CommonUuid]].

            - situation: str. A specific situation that sets the background for this session

            - render_templates: bool. Render system and assistant message content as jinja templates

            - token_budget: typing.Optional[int]. Threshold value for the adaptive context functionality

            - context_overflow: typing.Optional[str]. Action to start on context window overflow

            - metadata: typing.Optional[typing.Dict[str, typing.Any]].
        ---
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.sessions_route_create(
            situation="situation",
            render_templates=True,
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "situation": situation,
            "render_templates": render_templates,
        }
        if user is not OMIT:
            _request["user"] = user
        if users is not OMIT:
            _request["users"] = users
        if agent is not OMIT:
            _request["agent"] = agent
        if agents is not OMIT:
            _request["agents"] = agents
        if token_budget is not OMIT:
            _request["token_budget"] = token_budget
        if context_overflow is not OMIT:
            _request["context_overflow"] = context_overflow
        if metadata is not OMIT:
            _request["metadata"] = metadata
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "sessions"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SessionsRouteCreateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def sessions_route_create_or_update(
        self,
        *,
        id: CommonUuid,
        user: typing.Optional[CommonUuid] = OMIT,
        users: typing.Optional[typing.List[CommonUuid]] = OMIT,
        agent: typing.Optional[CommonUuid] = OMIT,
        agents: typing.Optional[typing.List[CommonUuid]] = OMIT,
        situation: str,
        render_templates: bool,
        token_budget: typing.Optional[int] = OMIT,
        context_overflow: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
    ) -> SessionsRouteCreateOrUpdateResponse:
        """
        Create or update undefined (ID is required in payload; existing resource will be overwritten)

        Parameters:
            - id: CommonUuid.

            - user: typing.Optional[CommonUuid]. User ID of user associated with this session

            - users: typing.Optional[typing.List[CommonUuid]].

            - agent: typing.Optional[CommonUuid]. Agent ID of agent associated with this session

            - agents: typing.Optional[typing.List[CommonUuid]].

            - situation: str. A specific situation that sets the background for this session

            - render_templates: bool. Render system and assistant message content as jinja templates

            - token_budget: typing.Optional[int]. Threshold value for the adaptive context functionality

            - context_overflow: typing.Optional[str]. Action to start on context window overflow

            - metadata: typing.Optional[typing.Dict[str, typing.Any]].
        ---
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.sessions_route_create_or_update(
            id="id",
            situation="situation",
            render_templates=True,
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "id": id,
            "situation": situation,
            "render_templates": render_templates,
        }
        if user is not OMIT:
            _request["user"] = user
        if users is not OMIT:
            _request["users"] = users
        if agent is not OMIT:
            _request["agent"] = agent
        if agents is not OMIT:
            _request["agents"] = agents
        if token_budget is not OMIT:
            _request["token_budget"] = token_budget
        if context_overflow is not OMIT:
            _request["context_overflow"] = context_overflow
        if metadata is not OMIT:
            _request["metadata"] = metadata
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "sessions"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SessionsRouteCreateOrUpdateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def history_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: HistoryRouteListRequestSortBy,
        direction: HistoryRouteListRequestDirection,
        metadata_filter: str,
    ) -> HistoryRouteListResponse:
        """
        List undefined items of parent undefined

        Parameters:
            - id: CommonUuid. ID of parent undefined

            - limit: CommonLimit. Limit the number of undefined items returned

            - offset: CommonOffset. Offset the undefined items returned

            - sort_by: HistoryRouteListRequestSortBy. Sort by a field

            - direction: HistoryRouteListRequestDirection. Sort direction

            - metadata_filter: str. JSON string of object that should be used to filter objects by metadata
        ---
        from julep import (
            HistoryRouteListRequestDirection,
            HistoryRouteListRequestSortBy,
        )
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.history_route_list(
            id="id",
            limit=1,
            offset=1,
            sort_by=HistoryRouteListRequestSortBy.CREATED_AT,
            direction=HistoryRouteListRequestDirection.ASC,
            metadata_filter="metadata_filter",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"sessions/history/{id}"
            ),
            params=remove_none_from_dict(
                {
                    "limit": limit,
                    "offset": offset,
                    "sort_by": sort_by,
                    "direction": direction,
                    "metadata_filter": metadata_filter,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(HistoryRouteListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def history_route_delete(self, id: CommonUuid) -> HistoryRouteDeleteResponse:
        """
        Delete undefined by id

        Parameters:
            - id: CommonUuid. ID of the undefined
        ---
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.history_route_delete(
            id="id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"sessions/history/{id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(HistoryRouteDeleteResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def sessions_route_get(self, id: CommonUuid) -> SessionsSession:
        """
        Get undefined by id

        Parameters:
            - id: CommonUuid. ID of the undefined
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"sessions/{id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SessionsSession, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def sessions_route_update(
        self,
        id: CommonUuid,
        *,
        situation: str,
        render_templates: bool,
        token_budget: typing.Optional[int] = OMIT,
        context_overflow: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
    ) -> SessionsRouteUpdateResponse:
        """
        Update undefined by id (overwrite)

        Parameters:
            - id: CommonUuid. ID of the undefined

            - situation: str. A specific situation that sets the background for this session

            - render_templates: bool. Render system and assistant message content as jinja templates

            - token_budget: typing.Optional[int]. Threshold value for the adaptive context functionality

            - context_overflow: typing.Optional[str]. Action to start on context window overflow

            - metadata: typing.Optional[typing.Dict[str, typing.Any]].
        ---
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.sessions_route_update(
            id="id",
            situation="situation",
            render_templates=True,
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "situation": situation,
            "render_templates": render_templates,
        }
        if token_budget is not OMIT:
            _request["token_budget"] = token_budget
        if context_overflow is not OMIT:
            _request["context_overflow"] = context_overflow
        if metadata is not OMIT:
            _request["metadata"] = metadata
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"sessions/{id}"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SessionsRouteUpdateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def sessions_route_delete(
        self, id: CommonUuid
    ) -> SessionsRouteDeleteResponse:
        """
        Delete undefined by id

        Parameters:
            - id: CommonUuid. ID of the undefined
        ---
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.sessions_route_delete(
            id="id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"sessions/{id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SessionsRouteDeleteResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def sessions_route_patch(
        self,
        id: CommonUuid,
        *,
        situation: typing.Optional[str] = OMIT,
        render_templates: typing.Optional[bool] = OMIT,
        token_budget: typing.Optional[int] = OMIT,
        context_overflow: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
    ) -> SessionsRoutePatchResponse:
        """
        Patch undefined by id (merge changes)

        Parameters:
            - id: CommonUuid. ID of the undefined

            - situation: typing.Optional[str]. A specific situation that sets the background for this session

            - render_templates: typing.Optional[bool]. Render system and assistant message content as jinja templates

            - token_budget: typing.Optional[int]. Threshold value for the adaptive context functionality

            - context_overflow: typing.Optional[str]. Action to start on context window overflow

            - metadata: typing.Optional[typing.Dict[str, typing.Any]].
        ---
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.sessions_route_patch(
            id="id",
        )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if situation is not OMIT:
            _request["situation"] = situation
        if render_templates is not OMIT:
            _request["render_templates"] = render_templates
        if token_budget is not OMIT:
            _request["token_budget"] = token_budget
        if context_overflow is not OMIT:
            _request["context_overflow"] = context_overflow
        if metadata is not OMIT:
            _request["metadata"] = metadata
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"sessions/{id}"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SessionsRoutePatchResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def tasks_route_list(
        self,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: TasksRouteListRequestSortBy,
        direction: TasksRouteListRequestDirection,
        metadata_filter: str,
    ) -> TasksRouteListResponse:
        """
        List undefined items

        Parameters:
            - limit: CommonLimit. Limit the number of undefined items returned

            - offset: CommonOffset. Offset the undefined items returned

            - sort_by: TasksRouteListRequestSortBy. Sort by a field

            - direction: TasksRouteListRequestDirection. Sort direction

            - metadata_filter: str. JSON string of object that should be used to filter objects by metadata
        ---
        from julep import TasksRouteListRequestDirection, TasksRouteListRequestSortBy
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.tasks_route_list(
            limit=1,
            offset=1,
            sort_by=TasksRouteListRequestSortBy.CREATED_AT,
            direction=TasksRouteListRequestDirection.ASC,
            metadata_filter="metadata_filter",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "tasks"),
            params=remove_none_from_dict(
                {
                    "limit": limit,
                    "offset": offset,
                    "sort_by": sort_by,
                    "direction": direction,
                    "metadata_filter": metadata_filter,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TasksRouteListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def tasks_route_create(
        self,
        *,
        name: str,
        description: str,
        main: typing.List[TasksWorkflowStep],
        input_schema: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        tools: typing.List[ToolsCreateToolRequest],
        inherit_tools: bool,
    ) -> TasksRouteCreateResponse:
        """
        Create new undefined

        Parameters:
            - name: str.

            - description: str.

            - main: typing.List[TasksWorkflowStep]. The entrypoint of the task.

            - input_schema: typing.Optional[typing.Dict[str, typing.Any]]. The schema for the input to the task. `null` means all inputs are valid.

            - tools: typing.List[ToolsCreateToolRequest]. Tools defined specifically for this task not included in the Agent itself.

            - inherit_tools: bool. Whether to inherit tools from the parent agent or not. Defaults to true.
        ---
        from julep import ToolsCreateToolRequest, ToolsToolType
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.tasks_route_create(
            name="name",
            description="description",
            main=[],
            tools=[
                ToolsCreateToolRequest(
                    type=ToolsToolType.FUNCTION,
                    background=True,
                    interactive=True,
                )
            ],
            inherit_tools=True,
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "name": name,
            "description": description,
            "main": main,
            "tools": tools,
            "inherit_tools": inherit_tools,
        }
        if input_schema is not OMIT:
            _request["input_schema"] = input_schema
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "tasks"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TasksRouteCreateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def tasks_route_create_or_update(
        self,
        *,
        id: CommonUuid,
        name: str,
        description: str,
        main: typing.List[TasksWorkflowStep],
        input_schema: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        tools: typing.List[ToolsCreateToolRequest],
        inherit_tools: bool,
    ) -> TasksRouteCreateOrUpdateResponse:
        """
        Create or update undefined (ID is required in payload; existing resource will be overwritten)

        Parameters:
            - id: CommonUuid.

            - name: str.

            - description: str.

            - main: typing.List[TasksWorkflowStep]. The entrypoint of the task.

            - input_schema: typing.Optional[typing.Dict[str, typing.Any]]. The schema for the input to the task. `null` means all inputs are valid.

            - tools: typing.List[ToolsCreateToolRequest]. Tools defined specifically for this task not included in the Agent itself.

            - inherit_tools: bool. Whether to inherit tools from the parent agent or not. Defaults to true.
        ---
        from julep import ToolsCreateToolRequest, ToolsToolType
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.tasks_route_create_or_update(
            id="id",
            name="name",
            description="description",
            main=[],
            tools=[
                ToolsCreateToolRequest(
                    type=ToolsToolType.FUNCTION,
                    background=True,
                    interactive=True,
                )
            ],
            inherit_tools=True,
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "id": id,
            "name": name,
            "description": description,
            "main": main,
            "tools": tools,
            "inherit_tools": inherit_tools,
        }
        if input_schema is not OMIT:
            _request["input_schema"] = input_schema
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "tasks"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TasksRouteCreateOrUpdateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def tasks_route_update(
        self,
        id: CommonUuid,
        *,
        description: str,
        main: typing.List[TasksWorkflowStep],
        input_schema: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        tools: typing.List[ToolsCreateToolRequest],
        inherit_tools: bool,
    ) -> TasksRouteUpdateResponse:
        """
        Update undefined by id (overwrite)

        Parameters:
            - id: CommonUuid. ID of the undefined

            - description: str.

            - main: typing.List[TasksWorkflowStep]. The entrypoint of the task.

            - input_schema: typing.Optional[typing.Dict[str, typing.Any]]. The schema for the input to the task. `null` means all inputs are valid.

            - tools: typing.List[ToolsCreateToolRequest]. Tools defined specifically for this task not included in the Agent itself.

            - inherit_tools: bool. Whether to inherit tools from the parent agent or not. Defaults to true.
        ---
        from julep import ToolsCreateToolRequest, ToolsToolType
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.tasks_route_update(
            id="id",
            description="description",
            main=[],
            tools=[
                ToolsCreateToolRequest(
                    type=ToolsToolType.FUNCTION,
                    background=True,
                    interactive=True,
                )
            ],
            inherit_tools=True,
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "description": description,
            "main": main,
            "tools": tools,
            "inherit_tools": inherit_tools,
        }
        if input_schema is not OMIT:
            _request["input_schema"] = input_schema
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"tasks/{id}"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TasksRouteUpdateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def tasks_route_delete(self, id: CommonUuid) -> TasksRouteDeleteResponse:
        """
        Delete undefined by id

        Parameters:
            - id: CommonUuid. ID of the undefined
        ---
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.tasks_route_delete(
            id="id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"tasks/{id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TasksRouteDeleteResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def tasks_route_patch(
        self,
        id: CommonUuid,
        *,
        description: typing.Optional[str] = OMIT,
        main: typing.Optional[typing.List[TasksWorkflowStep]] = OMIT,
        input_schema: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        tools: typing.Optional[typing.List[ToolsCreateToolRequest]] = OMIT,
        inherit_tools: typing.Optional[bool] = OMIT,
    ) -> TasksRoutePatchResponse:
        """
        Patch undefined by id (merge changes)

        Parameters:
            - id: CommonUuid. ID of the undefined

            - description: typing.Optional[str].

            - main: typing.Optional[typing.List[TasksWorkflowStep]]. The entrypoint of the task.

            - input_schema: typing.Optional[typing.Dict[str, typing.Any]]. The schema for the input to the task. `null` means all inputs are valid.

            - tools: typing.Optional[typing.List[ToolsCreateToolRequest]]. Tools defined specifically for this task not included in the Agent itself.

            - inherit_tools: typing.Optional[bool]. Whether to inherit tools from the parent agent or not. Defaults to true.
        ---
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.tasks_route_patch(
            id="id",
        )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if description is not OMIT:
            _request["description"] = description
        if main is not OMIT:
            _request["main"] = main
        if input_schema is not OMIT:
            _request["input_schema"] = input_schema
        if tools is not OMIT:
            _request["tools"] = tools
        if inherit_tools is not OMIT:
            _request["inherit_tools"] = inherit_tools
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"tasks/{id}"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TasksRoutePatchResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def task_executions_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: TaskExecutionsRouteListRequestSortBy,
        direction: TaskExecutionsRouteListRequestDirection,
        metadata_filter: str,
    ) -> TaskExecutionsRouteListResponse:
        """
        List undefined items of parent undefined

        Parameters:
            - id: CommonUuid. ID of parent undefined

            - limit: CommonLimit. Limit the number of undefined items returned

            - offset: CommonOffset. Offset the undefined items returned

            - sort_by: TaskExecutionsRouteListRequestSortBy. Sort by a field

            - direction: TaskExecutionsRouteListRequestDirection. Sort direction

            - metadata_filter: str. JSON string of object that should be used to filter objects by metadata
        ---
        from julep import (
            TaskExecutionsRouteListRequestDirection,
            TaskExecutionsRouteListRequestSortBy,
        )
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.task_executions_route_list(
            id="id",
            limit=1,
            offset=1,
            sort_by=TaskExecutionsRouteListRequestSortBy.CREATED_AT,
            direction=TaskExecutionsRouteListRequestDirection.ASC,
            metadata_filter="metadata_filter",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"tasks/{id}/executions"
            ),
            params=remove_none_from_dict(
                {
                    "limit": limit,
                    "offset": offset,
                    "sort_by": sort_by,
                    "direction": direction,
                    "metadata_filter": metadata_filter,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TaskExecutionsRouteListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def task_executions_route_create(
        self, id: CommonUuid, *, input: typing.Dict[str, typing.Any]
    ) -> TaskExecutionsRouteCreateResponse:
        """
        Create new undefined

        Parameters:
            - id: CommonUuid. ID of parent undefined

            - input: typing.Dict[str, typing.Any]. The input to the execution
        ---
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.task_executions_route_create(
            id="id",
            input={},
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"tasks/{id}/executions"
            ),
            json=jsonable_encoder({"input": input}),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TaskExecutionsRouteCreateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def task_executions_route_resume_with_task_token(
        self,
        id: CommonUuid,
        *,
        task_token: str,
        input: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
    ) -> TaskExecutionsRouteResumeWithTaskTokenResponse:
        """
        Resume an execution with a task token

        Parameters:
            - id: CommonUuid. ID of parent Task

            - task_token: str. A Task Token is a unique identifier for a specific Task Execution.

            - input: typing.Optional[typing.Dict[str, typing.Any]]. The input to resume the execution with
        ---
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.task_executions_route_resume_with_task_token(
            id="id",
            status="running",
            task_token="task_token",
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "status": status,
            "task_token": task_token,
        }
        if input is not OMIT:
            _request["input"] = input
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"tasks/{id}/executions"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TaskExecutionsRouteResumeWithTaskTokenResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def tool_route_update(
        self,
        id: CommonUuid,
        *,
        type: ToolsToolType,
        background: bool,
        interactive: bool,
        function: typing.Optional[ToolsFunctionDef] = OMIT,
        integration: typing.Optional[typing.Any] = OMIT,
        system: typing.Optional[typing.Any] = OMIT,
        api_call: typing.Optional[typing.Any] = OMIT,
    ) -> ToolRouteUpdateResponse:
        """
        Update undefined by id (overwrite)

        Parameters:
            - id: CommonUuid. ID of the undefined

            - type: ToolsToolType. Whether this tool is a `function`, `api_call`, `system` etc. (Only `function` tool supported right now)

            - background: bool. The tool should be run in the background (not supported at the moment)

            - interactive: bool. Whether the tool that can be run interactively (response should contain "stop" boolean field)

            - function: typing.Optional[ToolsFunctionDef].

            - integration: typing.Optional[typing.Any].

            - system: typing.Optional[typing.Any].

            - api_call: typing.Optional[typing.Any].
        ---
        from julep import ToolsToolType
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.tool_route_update(
            id="id",
            type=ToolsToolType.FUNCTION,
            background=True,
            interactive=True,
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "type": type.value,
            "background": background,
            "interactive": interactive,
        }
        if function is not OMIT:
            _request["function"] = function
        if integration is not OMIT:
            _request["integration"] = integration
        if system is not OMIT:
            _request["system"] = system
        if api_call is not OMIT:
            _request["api_call"] = api_call
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"tools/{id}"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ToolRouteUpdateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def tool_route_delete(self, id: CommonUuid) -> ToolRouteDeleteResponse:
        """
        Delete undefined by id

        Parameters:
            - id: CommonUuid. ID of the undefined
        ---
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.tool_route_delete(
            id="id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"tools/{id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ToolRouteDeleteResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def tool_route_patch(
        self,
        id: CommonUuid,
        *,
        type: typing.Optional[ToolsToolType] = OMIT,
        background: typing.Optional[bool] = OMIT,
        interactive: typing.Optional[bool] = OMIT,
        function: typing.Optional[ToolsFunctionDefUpdate] = OMIT,
        integration: typing.Optional[typing.Any] = OMIT,
        system: typing.Optional[typing.Any] = OMIT,
        api_call: typing.Optional[typing.Any] = OMIT,
    ) -> ToolRoutePatchResponse:
        """
        Patch undefined by id (merge changes)

        Parameters:
            - id: CommonUuid. ID of the undefined

            - type: typing.Optional[ToolsToolType]. Whether this tool is a `function`, `api_call`, `system` etc. (Only `function` tool supported right now)

            - background: typing.Optional[bool]. The tool should be run in the background (not supported at the moment)

            - interactive: typing.Optional[bool]. Whether the tool that can be run interactively (response should contain "stop" boolean field)

            - function: typing.Optional[ToolsFunctionDefUpdate].

            - integration: typing.Optional[typing.Any].

            - system: typing.Optional[typing.Any].

            - api_call: typing.Optional[typing.Any].
        ---
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.tool_route_patch(
            id="id",
        )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if type is not OMIT:
            _request["type"] = type.value
        if background is not OMIT:
            _request["background"] = background
        if interactive is not OMIT:
            _request["interactive"] = interactive
        if function is not OMIT:
            _request["function"] = function
        if integration is not OMIT:
            _request["integration"] = integration
        if system is not OMIT:
            _request["system"] = system
        if api_call is not OMIT:
            _request["api_call"] = api_call
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"tools/{id}"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ToolRoutePatchResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def users_route_list(
        self,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: UsersRouteListRequestSortBy,
        direction: UsersRouteListRequestDirection,
        metadata_filter: str,
    ) -> UsersRouteListResponse:
        """
        List undefined items

        Parameters:
            - limit: CommonLimit. Limit the number of undefined items returned

            - offset: CommonOffset. Offset the undefined items returned

            - sort_by: UsersRouteListRequestSortBy. Sort by a field

            - direction: UsersRouteListRequestDirection. Sort direction

            - metadata_filter: str. JSON string of object that should be used to filter objects by metadata
        ---
        from julep import UsersRouteListRequestDirection, UsersRouteListRequestSortBy
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.users_route_list(
            limit=1,
            offset=1,
            sort_by=UsersRouteListRequestSortBy.CREATED_AT,
            direction=UsersRouteListRequestDirection.ASC,
            metadata_filter="metadata_filter",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "users"),
            params=remove_none_from_dict(
                {
                    "limit": limit,
                    "offset": offset,
                    "sort_by": sort_by,
                    "direction": direction,
                    "metadata_filter": metadata_filter,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UsersRouteListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def users_route_create(
        self,
        *,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        name: CommonIdentifierSafeUnicode,
        about: str,
        docs: typing.List[typing.Any],
    ) -> UsersRouteCreateResponse:
        """
        Create new undefined

        Parameters:
            - metadata: typing.Optional[typing.Dict[str, typing.Any]].

            - name: CommonIdentifierSafeUnicode. Name of the user

            - about: str. About the user

            - docs: typing.List[typing.Any]. Documents to index for this user. (Max: 100 items)
        ---
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.users_route_create(
            name="name",
            about="about",
            docs=[],
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "name": name,
            "about": about,
            "docs": docs,
        }
        if metadata is not OMIT:
            _request["metadata"] = metadata
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "users"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UsersRouteCreateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def users_route_create_or_update(
        self,
        *,
        id: CommonUuid,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        name: CommonIdentifierSafeUnicode,
        about: str,
    ) -> UsersRouteCreateOrUpdateResponse:
        """
        Create or update undefined (ID is required in payload; existing resource will be overwritten)

        Parameters:
            - id: CommonUuid.

            - metadata: typing.Optional[typing.Dict[str, typing.Any]].

            - name: CommonIdentifierSafeUnicode. Name of the user

            - about: str. About the user
        ---
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.users_route_create_or_update(
            id="id",
            name="name",
            about="about",
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "id": id,
            "name": name,
            "about": about,
        }
        if metadata is not OMIT:
            _request["metadata"] = metadata
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "users"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UsersRouteCreateOrUpdateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def users_route_get(self, id: CommonUuid) -> UsersUser:
        """
        Get undefined by id

        Parameters:
            - id: CommonUuid. ID of the undefined
        ---
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.users_route_get(
            id="id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"users/{id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UsersUser, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def users_route_update(
        self,
        id: CommonUuid,
        *,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        name: CommonIdentifierSafeUnicode,
        about: str,
    ) -> UsersRouteUpdateResponse:
        """
        Update undefined by id (overwrite)

        Parameters:
            - id: CommonUuid. ID of the undefined

            - metadata: typing.Optional[typing.Dict[str, typing.Any]].

            - name: CommonIdentifierSafeUnicode. Name of the user

            - about: str. About the user
        ---
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.users_route_update(
            id="id",
            name="name",
            about="about",
        )
        """
        _request: typing.Dict[str, typing.Any] = {"name": name, "about": about}
        if metadata is not OMIT:
            _request["metadata"] = metadata
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"users/{id}"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UsersRouteUpdateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def users_route_delete(self, id: CommonUuid) -> UsersRouteDeleteResponse:
        """
        Delete undefined by id

        Parameters:
            - id: CommonUuid. ID of the undefined
        ---
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.users_route_delete(
            id="id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"users/{id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UsersRouteDeleteResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def users_route_patch(
        self,
        id: CommonUuid,
        *,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        name: typing.Optional[CommonIdentifierSafeUnicode] = OMIT,
        about: typing.Optional[str] = OMIT,
    ) -> UsersRoutePatchResponse:
        """
        Patch undefined by id (merge changes)

        Parameters:
            - id: CommonUuid. ID of the undefined

            - metadata: typing.Optional[typing.Dict[str, typing.Any]].

            - name: typing.Optional[CommonIdentifierSafeUnicode]. Name of the user

            - about: typing.Optional[str]. About the user
        ---
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.users_route_patch(
            id="id",
        )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if metadata is not OMIT:
            _request["metadata"] = metadata
        if name is not OMIT:
            _request["name"] = name
        if about is not OMIT:
            _request["about"] = about
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"users/{id}"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UsersRoutePatchResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def user_docs_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: UserDocsRouteListRequestSortBy,
        direction: UserDocsRouteListRequestDirection,
        metadata_filter: str,
    ) -> UserDocsRouteListResponse:
        """
        List undefined items of parent undefined

        Parameters:
            - id: CommonUuid. ID of parent undefined

            - limit: CommonLimit. Limit the number of undefined items returned

            - offset: CommonOffset. Offset the undefined items returned

            - sort_by: UserDocsRouteListRequestSortBy. Sort by a field

            - direction: UserDocsRouteListRequestDirection. Sort direction

            - metadata_filter: str. JSON string of object that should be used to filter objects by metadata
        ---
        from julep import (
            UserDocsRouteListRequestDirection,
            UserDocsRouteListRequestSortBy,
        )
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        await client.user_docs_route_list(
            id="id",
            limit=1,
            offset=1,
            sort_by=UserDocsRouteListRequestSortBy.CREATED_AT,
            direction=UserDocsRouteListRequestDirection.ASC,
            metadata_filter="metadata_filter",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"users/{id}/docs"
            ),
            params=remove_none_from_dict(
                {
                    "limit": limit,
                    "offset": offset,
                    "sort_by": sort_by,
                    "direction": direction,
                    "metadata_filter": metadata_filter,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UserDocsRouteListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def user_docs_search_route_search(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: UserDocsSearchRouteSearchRequestSortBy,
        direction: UserDocsSearchRouteSearchRequestDirection,
        metadata_filter: str,
        body: DocsDocSearchRequest,
    ) -> UserDocsSearchRouteSearchResponse:
        """
        Search for documents owned by undefined

        Parameters:
            - id: CommonUuid. ID of the undefined

            - limit: CommonLimit. Limit the number of undefined items returned

            - offset: CommonOffset. Offset the undefined items returned

            - sort_by: UserDocsSearchRouteSearchRequestSortBy. Sort by a field

            - direction: UserDocsSearchRouteSearchRequestDirection. Sort direction

            - metadata_filter: str. JSON string of object that should be used to filter objects by metadata

            - body: DocsDocSearchRequest.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"users/{id}/search"
            ),
            params=remove_none_from_dict(
                {
                    "limit": limit,
                    "offset": offset,
                    "sort_by": sort_by,
                    "direction": direction,
                    "metadata_filter": metadata_filter,
                }
            ),
            json=jsonable_encoder({"body": body}),
            headers=self._client_wrapper.get_headers(),
            timeout=300,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UserDocsSearchRouteSearchResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


def _get_base_url(
    *, base_url: typing.Optional[str] = None, environment: JulepApiEnvironment
) -> str:
    if base_url is not None:
        return base_url
    elif environment is not None:
        return environment.value
    else:
        raise Exception(
            "Please pass in either base_url or environment to construct the client"
        )
