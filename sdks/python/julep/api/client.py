# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

import httpx

from .core.api_error import ApiError
from .core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from .core.jsonable_encoder import jsonable_encoder
from .core.pydantic_utilities import pydantic_v1
from .core.request_options import RequestOptions
from .environment import JulepApiEnvironment
from .types.agent_docs_route_list_request_direction import (
    AgentDocsRouteListRequestDirection,
)
from .types.agent_docs_route_list_request_sort_by import AgentDocsRouteListRequestSortBy
from .types.agent_docs_route_list_response import AgentDocsRouteListResponse
from .types.agent_tools_route_list_request_direction import (
    AgentToolsRouteListRequestDirection,
)
from .types.agent_tools_route_list_request_sort_by import (
    AgentToolsRouteListRequestSortBy,
)
from .types.agent_tools_route_list_response import AgentToolsRouteListResponse
from .types.agents_agent import AgentsAgent
from .types.agents_create_agent_request_default_settings import (
    AgentsCreateAgentRequestDefaultSettings,
)
from .types.agents_create_agent_request_instructions import (
    AgentsCreateAgentRequestInstructions,
)
from .types.agents_docs_search_route_search_request_body import (
    AgentsDocsSearchRouteSearchRequestBody,
)
from .types.agents_docs_search_route_search_request_direction import (
    AgentsDocsSearchRouteSearchRequestDirection,
)
from .types.agents_docs_search_route_search_request_sort_by import (
    AgentsDocsSearchRouteSearchRequestSortBy,
)
from .types.agents_docs_search_route_search_response import (
    AgentsDocsSearchRouteSearchResponse,
)
from .types.agents_patch_agent_request_default_settings import (
    AgentsPatchAgentRequestDefaultSettings,
)
from .types.agents_patch_agent_request_instructions import (
    AgentsPatchAgentRequestInstructions,
)
from .types.agents_route_list_request_direction import AgentsRouteListRequestDirection
from .types.agents_route_list_request_sort_by import AgentsRouteListRequestSortBy
from .types.agents_route_list_response import AgentsRouteListResponse
from .types.agents_update_agent_request_default_settings import (
    AgentsUpdateAgentRequestDefaultSettings,
)
from .types.agents_update_agent_request_instructions import (
    AgentsUpdateAgentRequestInstructions,
)
from .types.chat_route_generate_request import ChatRouteGenerateRequest
from .types.chat_route_generate_response import ChatRouteGenerateResponse
from .types.common_identifier_safe_unicode import CommonIdentifierSafeUnicode
from .types.common_limit import CommonLimit
from .types.common_offset import CommonOffset
from .types.common_resource_created_response import CommonResourceCreatedResponse
from .types.common_resource_deleted_response import CommonResourceDeletedResponse
from .types.common_resource_updated_response import CommonResourceUpdatedResponse
from .types.common_uuid import CommonUuid
from .types.common_valid_python_identifier import CommonValidPythonIdentifier
from .types.docs_doc import DocsDoc
from .types.docs_embed_query_request import DocsEmbedQueryRequest
from .types.docs_embed_query_response import DocsEmbedQueryResponse
from .types.entries_history import EntriesHistory
from .types.execution_transitions_route_list_request_direction import (
    ExecutionTransitionsRouteListRequestDirection,
)
from .types.execution_transitions_route_list_request_sort_by import (
    ExecutionTransitionsRouteListRequestSortBy,
)
from .types.execution_transitions_route_list_response import (
    ExecutionTransitionsRouteListResponse,
)
from .types.executions_execution import ExecutionsExecution
from .types.executions_update_execution_request import ExecutionsUpdateExecutionRequest
from .types.jobs_job_status import JobsJobStatus
from .types.sessions_context_overflow_type import SessionsContextOverflowType
from .types.sessions_route_list_request_direction import (
    SessionsRouteListRequestDirection,
)
from .types.sessions_route_list_request_sort_by import SessionsRouteListRequestSortBy
from .types.sessions_route_list_response import SessionsRouteListResponse
from .types.sessions_session import SessionsSession
from .types.task_executions_route_list_request_direction import (
    TaskExecutionsRouteListRequestDirection,
)
from .types.task_executions_route_list_request_sort_by import (
    TaskExecutionsRouteListRequestSortBy,
)
from .types.task_executions_route_list_response import TaskExecutionsRouteListResponse
from .types.tasks_create_task_request_main_item import TasksCreateTaskRequestMainItem
from .types.tasks_patch_task_request_main_item import TasksPatchTaskRequestMainItem
from .types.tasks_route_list_request_direction import TasksRouteListRequestDirection
from .types.tasks_route_list_request_sort_by import TasksRouteListRequestSortBy
from .types.tasks_route_list_response import TasksRouteListResponse
from .types.tasks_task_tool import TasksTaskTool
from .types.tasks_update_task_request_main_item import TasksUpdateTaskRequestMainItem
from .types.tools_function_def import ToolsFunctionDef
from .types.tools_function_def_update import ToolsFunctionDefUpdate
from .types.tools_tool_type import ToolsToolType
from .types.user_docs_route_list_request_direction import (
    UserDocsRouteListRequestDirection,
)
from .types.user_docs_route_list_request_sort_by import UserDocsRouteListRequestSortBy
from .types.user_docs_route_list_response import UserDocsRouteListResponse
from .types.user_docs_search_route_search_request_body import (
    UserDocsSearchRouteSearchRequestBody,
)
from .types.user_docs_search_route_search_request_direction import (
    UserDocsSearchRouteSearchRequestDirection,
)
from .types.user_docs_search_route_search_request_sort_by import (
    UserDocsSearchRouteSearchRequestSortBy,
)
from .types.user_docs_search_route_search_response import (
    UserDocsSearchRouteSearchResponse,
)
from .types.users_route_list_request_direction import UsersRouteListRequestDirection
from .types.users_route_list_request_sort_by import UsersRouteListRequestSortBy
from .types.users_route_list_response import UsersRouteListResponse
from .types.users_user import UsersUser

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class JulepApi:
    """
    Use this class to access the different functions within the SDK. You can instantiate any number of clients with different configuration that will propagate to these functions.

    Parameters
    ----------
    base_url : typing.Optional[str]
        The base url to use for requests from the client.

    environment : JulepApiEnvironment
        The environment to use for requests from the client. from .environment import JulepApiEnvironment



        Defaults to JulepApiEnvironment.DEFAULT



    auth_key : str
    api_key : str
    timeout : typing.Optional[float]
        The timeout to be used, in seconds, for requests. By default the timeout is 300 seconds, unless a custom httpx client is used, in which case this default is not enforced.

    follow_redirects : typing.Optional[bool]
        Whether the default httpx client follows redirects or not, this is irrelevant if a custom httpx client is passed in.

    httpx_client : typing.Optional[httpx.Client]
        The httpx client to use for making requests, a preconfigured client is used by default, however this is useful should you want to pass in any custom httpx configuration.

    Examples
    --------
    from julep.client import JulepApi

    client = JulepApi(
        auth_key="YOUR_AUTH_KEY",
        api_key="YOUR_API_KEY",
    )
    """

    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: JulepApiEnvironment = JulepApiEnvironment.DEFAULT,
        auth_key: str,
        api_key: str,
        timeout: typing.Optional[float] = None,
        follow_redirects: typing.Optional[bool] = True,
        httpx_client: typing.Optional[httpx.Client] = None,
    ):
        _defaulted_timeout = (
            timeout if timeout is not None else 300 if httpx_client is None else None
        )
        self._client_wrapper = SyncClientWrapper(
            base_url=_get_base_url(base_url=base_url, environment=environment),
            auth_key=auth_key,
            api_key=api_key,
            httpx_client=(
                httpx_client
                if httpx_client is not None
                else (
                    httpx.Client(
                        timeout=_defaulted_timeout, follow_redirects=follow_redirects
                    )
                    if follow_redirects is not None
                    else httpx.Client(timeout=_defaulted_timeout)
                )
            ),
            timeout=_defaulted_timeout,
        )

    def agents_route_list(
        self,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: AgentsRouteListRequestSortBy,
        direction: AgentsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AgentsRouteListResponse:
        """
        List Agents (paginated)

        Parameters
        ----------
        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : AgentsRouteListRequestSortBy
            Sort by a field

        direction : AgentsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentsRouteListResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agents_route_list(
            limit=1,
            offset=1,
            sort_by="created_at",
            direction="asc",
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "agents",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agents_route_create(
        self,
        *,
        name: CommonIdentifierSafeUnicode,
        about: str,
        model: str,
        instructions: AgentsCreateAgentRequestInstructions,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        default_settings: typing.Optional[
            AgentsCreateAgentRequestDefaultSettings
        ] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceCreatedResponse:
        """
        Create a new Agent

        Parameters
        ----------
        name : CommonIdentifierSafeUnicode
            Name of the agent

        about : str
            About the agent

        model : str
            Model name to use (gpt-4-turbo, gemini-nano etc)

        instructions : AgentsCreateAgentRequestInstructions
            Instructions for the agent

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        default_settings : typing.Optional[AgentsCreateAgentRequestDefaultSettings]
            Default settings for all sessions created by this agent

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceCreatedResponse
            The request has succeeded and a new resource has been created as a result.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agents_route_create(
            name="name",
            about="about",
            model="model",
            instructions="instructions",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "agents",
            method="POST",
            json={
                "metadata": metadata,
                "name": name,
                "about": about,
                "model": model,
                "instructions": instructions,
                "default_settings": default_settings,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceCreatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agents_route_get(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AgentsAgent:
        """
        Get an Agent by id

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentsAgent
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agents_route_get(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentsAgent, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agents_route_create_or_update(
        self,
        id: CommonUuid,
        *,
        name: CommonIdentifierSafeUnicode,
        about: str,
        model: str,
        instructions: AgentsUpdateAgentRequestInstructions,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        default_settings: typing.Optional[
            AgentsUpdateAgentRequestDefaultSettings
        ] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Create or update an Agent

        Parameters
        ----------
        id : CommonUuid

        name : CommonIdentifierSafeUnicode
            Name of the agent

        about : str
            About the agent

        model : str
            Model name to use (gpt-4-turbo, gemini-nano etc)

        instructions : AgentsUpdateAgentRequestInstructions
            Instructions for the agent

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        default_settings : typing.Optional[AgentsUpdateAgentRequestDefaultSettings]
            Default settings for all sessions created by this agent

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agents_route_create_or_update(
            id="id",
            name="name",
            about="about",
            model="model",
            instructions="instructions",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}",
            method="POST",
            json={
                "metadata": metadata,
                "name": name,
                "about": about,
                "model": model,
                "instructions": instructions,
                "default_settings": default_settings,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agents_route_update(
        self,
        id: CommonUuid,
        *,
        name: CommonIdentifierSafeUnicode,
        about: str,
        model: str,
        instructions: AgentsUpdateAgentRequestInstructions,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        default_settings: typing.Optional[
            AgentsUpdateAgentRequestDefaultSettings
        ] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Update an existing Agent by id (overwrites existing values; use PATCH for merging instead)

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        name : CommonIdentifierSafeUnicode
            Name of the agent

        about : str
            About the agent

        model : str
            Model name to use (gpt-4-turbo, gemini-nano etc)

        instructions : AgentsUpdateAgentRequestInstructions
            Instructions for the agent

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        default_settings : typing.Optional[AgentsUpdateAgentRequestDefaultSettings]
            Default settings for all sessions created by this agent

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agents_route_update(
            id="id",
            name="name",
            about="about",
            model="model",
            instructions="instructions",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}",
            method="PUT",
            json={
                "metadata": metadata,
                "name": name,
                "about": about,
                "model": model,
                "instructions": instructions,
                "default_settings": default_settings,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agents_route_delete(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> CommonResourceDeletedResponse:
        """
        Delete Agent by id

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceDeletedResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agents_route_delete(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceDeletedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agents_route_patch(
        self,
        id: CommonUuid,
        *,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        name: typing.Optional[CommonIdentifierSafeUnicode] = OMIT,
        about: typing.Optional[str] = OMIT,
        model: typing.Optional[str] = OMIT,
        instructions: typing.Optional[AgentsPatchAgentRequestInstructions] = OMIT,
        default_settings: typing.Optional[
            AgentsPatchAgentRequestDefaultSettings
        ] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Update an existing Agent by id (merges with existing values)

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        name : typing.Optional[CommonIdentifierSafeUnicode]
            Name of the agent

        about : typing.Optional[str]
            About the agent

        model : typing.Optional[str]
            Model name to use (gpt-4-turbo, gemini-nano etc)

        instructions : typing.Optional[AgentsPatchAgentRequestInstructions]
            Instructions for the agent

        default_settings : typing.Optional[AgentsPatchAgentRequestDefaultSettings]
            Default settings for all sessions created by this agent

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agents_route_patch(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "metadata": metadata,
                "name": name,
                "about": about,
                "model": model,
                "instructions": instructions,
                "default_settings": default_settings,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agent_docs_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: AgentDocsRouteListRequestSortBy,
        direction: AgentDocsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AgentDocsRouteListResponse:
        """
        List Docs owned by an Agent

        Parameters
        ----------
        id : CommonUuid
            ID of parent

        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : AgentDocsRouteListRequestSortBy
            Sort by a field

        direction : AgentDocsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentDocsRouteListResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agent_docs_route_list(
            id="id",
            limit=1,
            offset=1,
            sort_by="created_at",
            direction="asc",
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/docs",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentDocsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agents_docs_search_route_search(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: AgentsDocsSearchRouteSearchRequestSortBy,
        direction: AgentsDocsSearchRouteSearchRequestDirection,
        metadata_filter: str,
        body: AgentsDocsSearchRouteSearchRequestBody,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AgentsDocsSearchRouteSearchResponse:
        """
        Search Docs owned by an Agent

        Parameters
        ----------
        id : CommonUuid
            ID of the parent

        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : AgentsDocsSearchRouteSearchRequestSortBy
            Sort by a field

        direction : AgentsDocsSearchRouteSearchRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        body : AgentsDocsSearchRouteSearchRequestBody

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentsDocsSearchRouteSearchResponse
            The request has succeeded.

        Examples
        --------
        from julep import DocsVectorDocSearchRequest
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agents_docs_search_route_search(
            id="id",
            limit=1,
            offset=1,
            sort_by="created_at",
            direction="asc",
            metadata_filter="metadata_filter",
            body=DocsVectorDocSearchRequest(
                confidence=1.1,
                alpha=1.1,
                mmr=True,
                vector=[1.1],
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/search",
            method="POST",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            json={"body": body},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentsDocsSearchRouteSearchResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def tasks_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: TasksRouteListRequestSortBy,
        direction: TasksRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TasksRouteListResponse:
        """
        List tasks (paginated)

        Parameters
        ----------
        id : CommonUuid
            ID of parent

        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : TasksRouteListRequestSortBy
            Sort by a field

        direction : TasksRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TasksRouteListResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.tasks_route_list(
            id="id",
            limit=1,
            offset=1,
            sort_by="created_at",
            direction="asc",
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tasks",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(TasksRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def tasks_route_create(
        self,
        id: CommonUuid,
        *,
        name: str,
        description: str,
        main: typing.Sequence[TasksCreateTaskRequestMainItem],
        tools: typing.Sequence[TasksTaskTool],
        inherit_tools: bool,
        input_schema: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceCreatedResponse:
        """
        Create a new task

        Parameters
        ----------
        id : CommonUuid
            ID of parent resource

        name : str

        description : str

        main : typing.Sequence[TasksCreateTaskRequestMainItem]
            The entrypoint of the task.

        tools : typing.Sequence[TasksTaskTool]
            Tools defined specifically for this task not included in the Agent itself.

        inherit_tools : bool
            Whether to inherit tools from the parent agent or not. Defaults to true.

        input_schema : typing.Optional[typing.Dict[str, typing.Any]]
            The schema for the input to the task. `null` means all inputs are valid.

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceCreatedResponse
            The request has succeeded and a new resource has been created as a result.

        Examples
        --------
        from julep import TasksEvaluateStep, TasksTaskTool
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.tasks_route_create(
            id="id",
            name="name",
            description="description",
            main=[
                TasksEvaluateStep(
                    evaluate={"key": "value"},
                )
            ],
            tools=[
                TasksTaskTool(
                    type="function",
                    name="name",
                )
            ],
            inherit_tools=True,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tasks",
            method="POST",
            json={
                "name": name,
                "description": description,
                "main": main,
                "input_schema": input_schema,
                "tools": tools,
                "inherit_tools": inherit_tools,
                "metadata": metadata,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceCreatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def tasks_route_update(
        self,
        id: CommonUuid,
        child_id: CommonUuid,
        *,
        description: str,
        main: typing.Sequence[TasksUpdateTaskRequestMainItem],
        tools: typing.Sequence[TasksTaskTool],
        inherit_tools: bool,
        input_schema: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Update an existing task (overwrite existing values)

        Parameters
        ----------
        id : CommonUuid
            ID of parent resource

        child_id : CommonUuid
            ID of the resource to be updated

        description : str

        main : typing.Sequence[TasksUpdateTaskRequestMainItem]
            The entrypoint of the task.

        tools : typing.Sequence[TasksTaskTool]
            Tools defined specifically for this task not included in the Agent itself.

        inherit_tools : bool
            Whether to inherit tools from the parent agent or not. Defaults to true.

        input_schema : typing.Optional[typing.Dict[str, typing.Any]]
            The schema for the input to the task. `null` means all inputs are valid.

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        from julep import TasksEvaluateStep, TasksTaskTool
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.tasks_route_update(
            id="id",
            child_id="child_id",
            description="description",
            main=[
                TasksEvaluateStep(
                    evaluate={"key": "value"},
                )
            ],
            tools=[
                TasksTaskTool(
                    type="function",
                    name="name",
                )
            ],
            inherit_tools=True,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tasks/{jsonable_encoder(child_id)}",
            method="PUT",
            json={
                "description": description,
                "main": main,
                "input_schema": input_schema,
                "tools": tools,
                "inherit_tools": inherit_tools,
                "metadata": metadata,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def tasks_route_delete(
        self,
        id: CommonUuid,
        child_id: CommonUuid,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceDeletedResponse:
        """
        Delete a task by its id

        Parameters
        ----------
        id : CommonUuid
            ID of parent resource

        child_id : CommonUuid
            ID of the resource to be deleted

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceDeletedResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.tasks_route_delete(
            id="id",
            child_id="child_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tasks/{jsonable_encoder(child_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceDeletedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def tasks_route_patch(
        self,
        id: CommonUuid,
        child_id: CommonUuid,
        *,
        description: typing.Optional[str] = OMIT,
        main: typing.Optional[typing.Sequence[TasksPatchTaskRequestMainItem]] = OMIT,
        input_schema: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        tools: typing.Optional[typing.Sequence[TasksTaskTool]] = OMIT,
        inherit_tools: typing.Optional[bool] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Update an existing task (merges with existing values)

        Parameters
        ----------
        id : CommonUuid
            ID of parent resource

        child_id : CommonUuid
            ID of the resource to be patched

        description : typing.Optional[str]

        main : typing.Optional[typing.Sequence[TasksPatchTaskRequestMainItem]]
            The entrypoint of the task.

        input_schema : typing.Optional[typing.Dict[str, typing.Any]]
            The schema for the input to the task. `null` means all inputs are valid.

        tools : typing.Optional[typing.Sequence[TasksTaskTool]]
            Tools defined specifically for this task not included in the Agent itself.

        inherit_tools : typing.Optional[bool]
            Whether to inherit tools from the parent agent or not. Defaults to true.

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.tasks_route_patch(
            id="id",
            child_id="child_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tasks/{jsonable_encoder(child_id)}",
            method="PATCH",
            json={
                "description": description,
                "main": main,
                "input_schema": input_schema,
                "tools": tools,
                "inherit_tools": inherit_tools,
                "metadata": metadata,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agent_tools_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: AgentToolsRouteListRequestSortBy,
        direction: AgentToolsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AgentToolsRouteListResponse:
        """
        List tools of the given agent

        Parameters
        ----------
        id : CommonUuid
            ID of parent

        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : AgentToolsRouteListRequestSortBy
            Sort by a field

        direction : AgentToolsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentToolsRouteListResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agent_tools_route_list(
            id="id",
            limit=1,
            offset=1,
            sort_by="created_at",
            direction="asc",
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tools",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentToolsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agent_tools_route_create(
        self,
        id: CommonUuid,
        *,
        name: CommonIdentifierSafeUnicode,
        about: str,
        model: str,
        instructions: AgentsCreateAgentRequestInstructions,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        default_settings: typing.Optional[
            AgentsCreateAgentRequestDefaultSettings
        ] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceCreatedResponse:
        """
        Create a new tool for this agent

        Parameters
        ----------
        id : CommonUuid
            ID of parent resource

        name : CommonIdentifierSafeUnicode
            Name of the agent

        about : str
            About the agent

        model : str
            Model name to use (gpt-4-turbo, gemini-nano etc)

        instructions : AgentsCreateAgentRequestInstructions
            Instructions for the agent

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        default_settings : typing.Optional[AgentsCreateAgentRequestDefaultSettings]
            Default settings for all sessions created by this agent

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceCreatedResponse
            The request has succeeded and a new resource has been created as a result.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agent_tools_route_create(
            id="id",
            name="name",
            about="about",
            model="model",
            instructions="instructions",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tools",
            method="POST",
            json={
                "metadata": metadata,
                "name": name,
                "about": about,
                "model": model,
                "instructions": instructions,
                "default_settings": default_settings,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceCreatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agent_tools_route_update(
        self,
        id: CommonUuid,
        child_id: CommonUuid,
        *,
        type: ToolsToolType,
        name: CommonValidPythonIdentifier,
        function: typing.Optional[ToolsFunctionDef] = OMIT,
        integration: typing.Optional[typing.Any] = OMIT,
        system: typing.Optional[typing.Any] = OMIT,
        api_call: typing.Optional[typing.Any] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Update an existing tool (overwrite existing values)

        Parameters
        ----------
        id : CommonUuid
            ID of parent resource

        child_id : CommonUuid
            ID of the resource to be updated

        type : ToolsToolType
            Whether this tool is a `function`, `api_call`, `system` etc. (Only `function` tool supported right now)

        name : CommonValidPythonIdentifier
            Name of the tool (must be unique for this agent and a valid python identifier string )

        function : typing.Optional[ToolsFunctionDef]

        integration : typing.Optional[typing.Any]

        system : typing.Optional[typing.Any]

        api_call : typing.Optional[typing.Any]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agent_tools_route_update(
            id="id",
            child_id="child_id",
            type="function",
            name="name",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tools/{jsonable_encoder(child_id)}",
            method="PUT",
            json={
                "type": type,
                "name": name,
                "function": function,
                "integration": integration,
                "system": system,
                "api_call": api_call,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agent_tools_route_delete(
        self,
        id: CommonUuid,
        child_id: CommonUuid,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceDeletedResponse:
        """
        Delete an existing tool by id

        Parameters
        ----------
        id : CommonUuid
            ID of parent resource

        child_id : CommonUuid
            ID of the resource to be deleted

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceDeletedResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agent_tools_route_delete(
            id="id",
            child_id="child_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tools/{jsonable_encoder(child_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceDeletedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agent_tools_route_patch(
        self,
        id: CommonUuid,
        child_id: CommonUuid,
        *,
        type: typing.Optional[ToolsToolType] = OMIT,
        name: typing.Optional[CommonValidPythonIdentifier] = OMIT,
        function: typing.Optional[ToolsFunctionDefUpdate] = OMIT,
        integration: typing.Optional[typing.Any] = OMIT,
        system: typing.Optional[typing.Any] = OMIT,
        api_call: typing.Optional[typing.Any] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Update an existing tool (merges with existing values)

        Parameters
        ----------
        id : CommonUuid
            ID of parent resource

        child_id : CommonUuid
            ID of the resource to be patched

        type : typing.Optional[ToolsToolType]
            Whether this tool is a `function`, `api_call`, `system` etc. (Only `function` tool supported right now)

        name : typing.Optional[CommonValidPythonIdentifier]
            Name of the tool (must be unique for this agent and a valid python identifier string )

        function : typing.Optional[ToolsFunctionDefUpdate]

        integration : typing.Optional[typing.Any]

        system : typing.Optional[typing.Any]

        api_call : typing.Optional[typing.Any]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agent_tools_route_patch(
            id="id",
            child_id="child_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tools/{jsonable_encoder(child_id)}",
            method="PATCH",
            json={
                "type": type,
                "name": name,
                "function": function,
                "integration": integration,
                "system": system,
                "api_call": api_call,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def tasks_create_or_update_route_create_or_update(
        self,
        parent_id: CommonUuid,
        id: CommonUuid,
        *,
        name: str,
        description: str,
        main: typing.Sequence[TasksCreateTaskRequestMainItem],
        tools: typing.Sequence[TasksTaskTool],
        inherit_tools: bool,
        input_schema: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Create or update a task

        Parameters
        ----------
        parent_id : CommonUuid
            ID of parent resource

        id : CommonUuid

        name : str

        description : str

        main : typing.Sequence[TasksCreateTaskRequestMainItem]
            The entrypoint of the task.

        tools : typing.Sequence[TasksTaskTool]
            Tools defined specifically for this task not included in the Agent itself.

        inherit_tools : bool
            Whether to inherit tools from the parent agent or not. Defaults to true.

        input_schema : typing.Optional[typing.Dict[str, typing.Any]]
            The schema for the input to the task. `null` means all inputs are valid.

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        from julep import TasksEvaluateStep, TasksTaskTool
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.tasks_create_or_update_route_create_or_update(
            parent_id="parent_id",
            id="id",
            name="name",
            description="description",
            main=[
                TasksEvaluateStep(
                    evaluate={"key": "value"},
                )
            ],
            tools=[
                TasksTaskTool(
                    type="function",
                    name="name",
                )
            ],
            inherit_tools=True,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(parent_id)}/tasks/{jsonable_encoder(id)}",
            method="POST",
            json={
                "name": name,
                "description": description,
                "main": main,
                "input_schema": input_schema,
                "tools": tools,
                "inherit_tools": inherit_tools,
                "metadata": metadata,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def individual_docs_route_get(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> DocsDoc:
        """
        Get Doc by id

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DocsDoc
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.individual_docs_route_get(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"docs/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(DocsDoc, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def individual_docs_route_delete(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> CommonResourceDeletedResponse:
        """
        Delete an existing Doc by id

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceDeletedResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.individual_docs_route_delete(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"docs/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceDeletedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def embed_route_embed(
        self,
        *,
        body: DocsEmbedQueryRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> DocsEmbedQueryResponse:
        """
        Embed a query for search

        Parameters
        ----------
        body : DocsEmbedQueryRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DocsEmbedQueryResponse
            The request has succeeded.

        Examples
        --------
        from julep import DocsEmbedQueryRequest
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.embed_route_embed(
            body=DocsEmbedQueryRequest(
                text="text",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "embed",
            method="POST",
            json={"body": body},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(DocsEmbedQueryResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def executions_route_get(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ExecutionsExecution:
        """
        Get an Execution by id

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ExecutionsExecution
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.executions_route_get(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"executions/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ExecutionsExecution, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def execution_transitions_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: ExecutionTransitionsRouteListRequestSortBy,
        direction: ExecutionTransitionsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ExecutionTransitionsRouteListResponse:
        """
        List the Transitions of an Execution by id

        Parameters
        ----------
        id : CommonUuid
            ID of parent

        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : ExecutionTransitionsRouteListRequestSortBy
            Sort by a field

        direction : ExecutionTransitionsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ExecutionTransitionsRouteListResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.execution_transitions_route_list(
            id="id",
            limit=1,
            offset=1,
            sort_by="created_at",
            direction="asc",
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"executions/{jsonable_encoder(id)}/transitions",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ExecutionTransitionsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def job_route_get(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> JobsJobStatus:
        """
        Get the status of an existing Job by its id

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        JobsJobStatus
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.job_route_get(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"jobs/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(JobsJobStatus, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def sessions_route_list(
        self,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: SessionsRouteListRequestSortBy,
        direction: SessionsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SessionsRouteListResponse:
        """
        List sessions (paginated)

        Parameters
        ----------
        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : SessionsRouteListRequestSortBy
            Sort by a field

        direction : SessionsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SessionsRouteListResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.sessions_route_list(
            limit=1,
            offset=1,
            sort_by="created_at",
            direction="asc",
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "sessions",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(SessionsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def sessions_route_create(
        self,
        *,
        situation: str,
        render_templates: bool,
        user: typing.Optional[CommonUuid] = OMIT,
        users: typing.Optional[typing.Sequence[CommonUuid]] = OMIT,
        agent: typing.Optional[CommonUuid] = OMIT,
        agents: typing.Optional[typing.Sequence[CommonUuid]] = OMIT,
        token_budget: typing.Optional[int] = OMIT,
        context_overflow: typing.Optional[SessionsContextOverflowType] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceCreatedResponse:
        """
        Create a new session

        Parameters
        ----------
        situation : str
            A specific situation that sets the background for this session

        render_templates : bool
            Render system and assistant message content as jinja templates

        user : typing.Optional[CommonUuid]
            User ID of user associated with this session

        users : typing.Optional[typing.Sequence[CommonUuid]]

        agent : typing.Optional[CommonUuid]
            Agent ID of agent associated with this session

        agents : typing.Optional[typing.Sequence[CommonUuid]]

        token_budget : typing.Optional[int]
            Threshold value for the adaptive context functionality

        context_overflow : typing.Optional[SessionsContextOverflowType]
            Action to start on context window overflow

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceCreatedResponse
            The request has succeeded and a new resource has been created as a result.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.sessions_route_create(
            situation="situation",
            render_templates=True,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "sessions",
            method="POST",
            json={
                "user": user,
                "users": users,
                "agent": agent,
                "agents": agents,
                "situation": situation,
                "render_templates": render_templates,
                "token_budget": token_budget,
                "context_overflow": context_overflow,
                "metadata": metadata,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceCreatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def sessions_route_get(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> SessionsSession:
        """
        Get a session by id

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SessionsSession
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.sessions_route_get(
            id="string",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sessions/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(SessionsSession, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def sessions_route_create_or_update(
        self,
        id: CommonUuid,
        *,
        situation: str,
        render_templates: bool,
        user: typing.Optional[CommonUuid] = OMIT,
        users: typing.Optional[typing.Sequence[CommonUuid]] = OMIT,
        agent: typing.Optional[CommonUuid] = OMIT,
        agents: typing.Optional[typing.Sequence[CommonUuid]] = OMIT,
        token_budget: typing.Optional[int] = OMIT,
        context_overflow: typing.Optional[SessionsContextOverflowType] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Create or update a session

        Parameters
        ----------
        id : CommonUuid

        situation : str
            A specific situation that sets the background for this session

        render_templates : bool
            Render system and assistant message content as jinja templates

        user : typing.Optional[CommonUuid]
            User ID of user associated with this session

        users : typing.Optional[typing.Sequence[CommonUuid]]

        agent : typing.Optional[CommonUuid]
            Agent ID of agent associated with this session

        agents : typing.Optional[typing.Sequence[CommonUuid]]

        token_budget : typing.Optional[int]
            Threshold value for the adaptive context functionality

        context_overflow : typing.Optional[SessionsContextOverflowType]
            Action to start on context window overflow

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.sessions_route_create_or_update(
            id="id",
            situation="situation",
            render_templates=True,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sessions/{jsonable_encoder(id)}",
            method="POST",
            json={
                "user": user,
                "users": users,
                "agent": agent,
                "agents": agents,
                "situation": situation,
                "render_templates": render_templates,
                "token_budget": token_budget,
                "context_overflow": context_overflow,
                "metadata": metadata,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def sessions_route_update(
        self,
        id: CommonUuid,
        *,
        situation: str,
        render_templates: bool,
        token_budget: typing.Optional[int] = OMIT,
        context_overflow: typing.Optional[SessionsContextOverflowType] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Update an existing session by its id (overwrites all existing values)

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        situation : str
            A specific situation that sets the background for this session

        render_templates : bool
            Render system and assistant message content as jinja templates

        token_budget : typing.Optional[int]
            Threshold value for the adaptive context functionality

        context_overflow : typing.Optional[SessionsContextOverflowType]
            Action to start on context window overflow

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.sessions_route_update(
            id="id",
            situation="situation",
            render_templates=True,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sessions/{jsonable_encoder(id)}",
            method="PUT",
            json={
                "situation": situation,
                "render_templates": render_templates,
                "token_budget": token_budget,
                "context_overflow": context_overflow,
                "metadata": metadata,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def sessions_route_delete(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> CommonResourceDeletedResponse:
        """
        Delete a session by its id

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceDeletedResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.sessions_route_delete(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sessions/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceDeletedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def sessions_route_patch(
        self,
        id: CommonUuid,
        *,
        situation: typing.Optional[str] = OMIT,
        render_templates: typing.Optional[bool] = OMIT,
        token_budget: typing.Optional[int] = OMIT,
        context_overflow: typing.Optional[SessionsContextOverflowType] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Update an existing session by its id (merges with existing values)

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        situation : typing.Optional[str]
            A specific situation that sets the background for this session

        render_templates : typing.Optional[bool]
            Render system and assistant message content as jinja templates

        token_budget : typing.Optional[int]
            Threshold value for the adaptive context functionality

        context_overflow : typing.Optional[SessionsContextOverflowType]
            Action to start on context window overflow

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.sessions_route_patch(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sessions/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "situation": situation,
                "render_templates": render_templates,
                "token_budget": token_budget,
                "context_overflow": context_overflow,
                "metadata": metadata,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def chat_route_generate(
        self,
        id: CommonUuid,
        *,
        request: ChatRouteGenerateRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ChatRouteGenerateResponse:
        """
        Generate a response from the model

        Parameters
        ----------
        id : CommonUuid
            The session ID

        request : ChatRouteGenerateRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChatRouteGenerateResponse
            The request has succeeded.

        Examples
        --------
        from julep import ChatRouteGenerateRequestPreset, EntriesInputChatMlMessage
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.chat_route_generate(
            id="id",
            request=ChatRouteGenerateRequestPreset(
                messages=[
                    EntriesInputChatMlMessage(
                        role="user",
                        content="content",
                    )
                ],
                recall=True,
                remember=True,
                save=True,
                stream=True,
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sessions/{jsonable_encoder(id)}/chat",
            method="POST",
            json=request,
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ChatRouteGenerateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def history_route_history(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> EntriesHistory:
        """
        Get history of a Session

        Parameters
        ----------
        id : CommonUuid
            ID of parent

        limit : CommonLimit
            Limit the number of items returned

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        EntriesHistory
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.history_route_history(
            id="id",
            limit=1,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sessions/{jsonable_encoder(id)}/history",
            method="GET",
            params={"limit": limit},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(EntriesHistory, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def history_route_delete(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> CommonResourceDeletedResponse:
        """
        Clear the history of a Session (resets the Session)

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceDeletedResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.history_route_delete(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sessions/{jsonable_encoder(id)}/history",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceDeletedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def task_executions_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: TaskExecutionsRouteListRequestSortBy,
        direction: TaskExecutionsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TaskExecutionsRouteListResponse:
        """
        List executions of the given task

        Parameters
        ----------
        id : CommonUuid
            ID of parent

        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : TaskExecutionsRouteListRequestSortBy
            Sort by a field

        direction : TaskExecutionsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TaskExecutionsRouteListResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.task_executions_route_list(
            id="id",
            limit=1,
            offset=1,
            sort_by="created_at",
            direction="asc",
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(id)}/executions",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(TaskExecutionsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def task_executions_route_create(
        self,
        id: CommonUuid,
        *,
        input: typing.Dict[str, typing.Any],
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceCreatedResponse:
        """
        Create an execution for the given task

        Parameters
        ----------
        id : CommonUuid
            ID of parent resource

        input : typing.Dict[str, typing.Any]
            The input to the execution

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceCreatedResponse
            The request has succeeded and a new resource has been created as a result.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.task_executions_route_create(
            id="id",
            input={"key": "value"},
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(id)}/executions",
            method="POST",
            json={"input": input, "metadata": metadata},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceCreatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def task_executions_route_resume_with_task_token(
        self,
        id: CommonUuid,
        *,
        task_token: str,
        input: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Resume an execution with a task token

        Parameters
        ----------
        id : CommonUuid
            ID of parent Task

        task_token : str
            A Task Token is a unique identifier for a specific Task Execution.

        input : typing.Optional[typing.Dict[str, typing.Any]]
            The input to resume the execution with

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.task_executions_route_resume_with_task_token(
            id="id",
            task_token="task_token",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(id)}/executions",
            method="PUT",
            json={"task_token": task_token, "input": input, "status": "running"},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def task_executions_route_update(
        self,
        id: CommonUuid,
        child_id: CommonUuid,
        *,
        request: ExecutionsUpdateExecutionRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Update an existing Execution

        Parameters
        ----------
        id : CommonUuid
            ID of parent resource

        child_id : CommonUuid
            ID of the resource to be updated

        request : ExecutionsUpdateExecutionRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        from julep import ExecutionsUpdateExecutionRequest_Cancelled
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.task_executions_route_update(
            id="string",
            child_id="string",
            request=ExecutionsUpdateExecutionRequest_Cancelled(
                reason="string",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(id)}/executions/{jsonable_encoder(child_id)}",
            method="PUT",
            json=request,
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def users_route_list(
        self,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: UsersRouteListRequestSortBy,
        direction: UsersRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UsersRouteListResponse:
        """
        List users (paginated)

        Parameters
        ----------
        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : UsersRouteListRequestSortBy
            Sort by a field

        direction : UsersRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UsersRouteListResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.users_route_list(
            limit=1,
            offset=1,
            sort_by="created_at",
            direction="asc",
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "users",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(UsersRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def users_route_create(
        self,
        *,
        name: CommonIdentifierSafeUnicode,
        about: str,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceCreatedResponse:
        """
        Create a new user

        Parameters
        ----------
        name : CommonIdentifierSafeUnicode
            Name of the user

        about : str
            About the user

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceCreatedResponse
            The request has succeeded and a new resource has been created as a result.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.users_route_create(
            name="name",
            about="about",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "users",
            method="POST",
            json={"metadata": metadata, "name": name, "about": about},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceCreatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def users_route_get(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> UsersUser:
        """
        Get a user by id

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UsersUser
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.users_route_get(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(UsersUser, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def users_route_create_or_update(
        self,
        id: CommonUuid,
        *,
        name: CommonIdentifierSafeUnicode,
        about: str,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Create or update a user

        Parameters
        ----------
        id : CommonUuid

        name : CommonIdentifierSafeUnicode
            Name of the user

        about : str
            About the user

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.users_route_create_or_update(
            id="id",
            name="name",
            about="about",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(id)}",
            method="POST",
            json={"metadata": metadata, "name": name, "about": about},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def users_route_update(
        self,
        id: CommonUuid,
        *,
        name: CommonIdentifierSafeUnicode,
        about: str,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Update an existing user by id (overwrite existing values)

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        name : CommonIdentifierSafeUnicode
            Name of the user

        about : str
            About the user

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.users_route_update(
            id="id",
            name="name",
            about="about",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(id)}",
            method="PUT",
            json={"metadata": metadata, "name": name, "about": about},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def users_route_delete(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> CommonResourceDeletedResponse:
        """
        Delete a user by id

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceDeletedResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.users_route_delete(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceDeletedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def users_route_patch(
        self,
        id: CommonUuid,
        *,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        name: typing.Optional[CommonIdentifierSafeUnicode] = OMIT,
        about: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Update an existing user by id (merge with existing values)

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        name : typing.Optional[CommonIdentifierSafeUnicode]
            Name of the user

        about : typing.Optional[str]
            About the user

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.users_route_patch(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(id)}",
            method="PATCH",
            json={"metadata": metadata, "name": name, "about": about},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def user_docs_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: UserDocsRouteListRequestSortBy,
        direction: UserDocsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UserDocsRouteListResponse:
        """
        List Docs owned by a User

        Parameters
        ----------
        id : CommonUuid
            ID of parent

        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : UserDocsRouteListRequestSortBy
            Sort by a field

        direction : UserDocsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UserDocsRouteListResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.user_docs_route_list(
            id="id",
            limit=1,
            offset=1,
            sort_by="created_at",
            direction="asc",
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(id)}/docs",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(UserDocsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def user_docs_search_route_search(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: UserDocsSearchRouteSearchRequestSortBy,
        direction: UserDocsSearchRouteSearchRequestDirection,
        metadata_filter: str,
        body: UserDocsSearchRouteSearchRequestBody,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UserDocsSearchRouteSearchResponse:
        """
        Search Docs owned by a User

        Parameters
        ----------
        id : CommonUuid
            ID of the parent

        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : UserDocsSearchRouteSearchRequestSortBy
            Sort by a field

        direction : UserDocsSearchRouteSearchRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        body : UserDocsSearchRouteSearchRequestBody

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UserDocsSearchRouteSearchResponse
            The request has succeeded.

        Examples
        --------
        from julep import DocsVectorDocSearchRequest
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.user_docs_search_route_search(
            id="id",
            limit=1,
            offset=1,
            sort_by="created_at",
            direction="asc",
            metadata_filter="metadata_filter",
            body=DocsVectorDocSearchRequest(
                confidence=1.1,
                alpha=1.1,
                mmr=True,
                vector=[1.1],
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(id)}/search",
            method="POST",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            json={"body": body},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(UserDocsSearchRouteSearchResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncJulepApi:
    """
    Use this class to access the different functions within the SDK. You can instantiate any number of clients with different configuration that will propagate to these functions.

    Parameters
    ----------
    base_url : typing.Optional[str]
        The base url to use for requests from the client.

    environment : JulepApiEnvironment
        The environment to use for requests from the client. from .environment import JulepApiEnvironment



        Defaults to JulepApiEnvironment.DEFAULT



    auth_key : str
    api_key : str
    timeout : typing.Optional[float]
        The timeout to be used, in seconds, for requests. By default the timeout is 300 seconds, unless a custom httpx client is used, in which case this default is not enforced.

    follow_redirects : typing.Optional[bool]
        Whether the default httpx client follows redirects or not, this is irrelevant if a custom httpx client is passed in.

    httpx_client : typing.Optional[httpx.AsyncClient]
        The httpx client to use for making requests, a preconfigured client is used by default, however this is useful should you want to pass in any custom httpx configuration.

    Examples
    --------
    from julep.client import AsyncJulepApi

    client = AsyncJulepApi(
        auth_key="YOUR_AUTH_KEY",
        api_key="YOUR_API_KEY",
    )
    """

    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: JulepApiEnvironment = JulepApiEnvironment.DEFAULT,
        auth_key: str,
        api_key: str,
        timeout: typing.Optional[float] = None,
        follow_redirects: typing.Optional[bool] = True,
        httpx_client: typing.Optional[httpx.AsyncClient] = None,
    ):
        _defaulted_timeout = (
            timeout if timeout is not None else 300 if httpx_client is None else None
        )
        self._client_wrapper = AsyncClientWrapper(
            base_url=_get_base_url(base_url=base_url, environment=environment),
            auth_key=auth_key,
            api_key=api_key,
            httpx_client=(
                httpx_client
                if httpx_client is not None
                else (
                    httpx.AsyncClient(
                        timeout=_defaulted_timeout, follow_redirects=follow_redirects
                    )
                    if follow_redirects is not None
                    else httpx.AsyncClient(timeout=_defaulted_timeout)
                )
            ),
            timeout=_defaulted_timeout,
        )

    async def agents_route_list(
        self,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: AgentsRouteListRequestSortBy,
        direction: AgentsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AgentsRouteListResponse:
        """
        List Agents (paginated)

        Parameters
        ----------
        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : AgentsRouteListRequestSortBy
            Sort by a field

        direction : AgentsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentsRouteListResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.agents_route_list(
                limit=1,
                offset=1,
                sort_by="created_at",
                direction="asc",
                metadata_filter="metadata_filter",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "agents",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agents_route_create(
        self,
        *,
        name: CommonIdentifierSafeUnicode,
        about: str,
        model: str,
        instructions: AgentsCreateAgentRequestInstructions,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        default_settings: typing.Optional[
            AgentsCreateAgentRequestDefaultSettings
        ] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceCreatedResponse:
        """
        Create a new Agent

        Parameters
        ----------
        name : CommonIdentifierSafeUnicode
            Name of the agent

        about : str
            About the agent

        model : str
            Model name to use (gpt-4-turbo, gemini-nano etc)

        instructions : AgentsCreateAgentRequestInstructions
            Instructions for the agent

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        default_settings : typing.Optional[AgentsCreateAgentRequestDefaultSettings]
            Default settings for all sessions created by this agent

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceCreatedResponse
            The request has succeeded and a new resource has been created as a result.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.agents_route_create(
                name="name",
                about="about",
                model="model",
                instructions="instructions",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "agents",
            method="POST",
            json={
                "metadata": metadata,
                "name": name,
                "about": about,
                "model": model,
                "instructions": instructions,
                "default_settings": default_settings,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceCreatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agents_route_get(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AgentsAgent:
        """
        Get an Agent by id

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentsAgent
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.agents_route_get(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentsAgent, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agents_route_create_or_update(
        self,
        id: CommonUuid,
        *,
        name: CommonIdentifierSafeUnicode,
        about: str,
        model: str,
        instructions: AgentsUpdateAgentRequestInstructions,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        default_settings: typing.Optional[
            AgentsUpdateAgentRequestDefaultSettings
        ] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Create or update an Agent

        Parameters
        ----------
        id : CommonUuid

        name : CommonIdentifierSafeUnicode
            Name of the agent

        about : str
            About the agent

        model : str
            Model name to use (gpt-4-turbo, gemini-nano etc)

        instructions : AgentsUpdateAgentRequestInstructions
            Instructions for the agent

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        default_settings : typing.Optional[AgentsUpdateAgentRequestDefaultSettings]
            Default settings for all sessions created by this agent

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.agents_route_create_or_update(
                id="id",
                name="name",
                about="about",
                model="model",
                instructions="instructions",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}",
            method="POST",
            json={
                "metadata": metadata,
                "name": name,
                "about": about,
                "model": model,
                "instructions": instructions,
                "default_settings": default_settings,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agents_route_update(
        self,
        id: CommonUuid,
        *,
        name: CommonIdentifierSafeUnicode,
        about: str,
        model: str,
        instructions: AgentsUpdateAgentRequestInstructions,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        default_settings: typing.Optional[
            AgentsUpdateAgentRequestDefaultSettings
        ] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Update an existing Agent by id (overwrites existing values; use PATCH for merging instead)

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        name : CommonIdentifierSafeUnicode
            Name of the agent

        about : str
            About the agent

        model : str
            Model name to use (gpt-4-turbo, gemini-nano etc)

        instructions : AgentsUpdateAgentRequestInstructions
            Instructions for the agent

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        default_settings : typing.Optional[AgentsUpdateAgentRequestDefaultSettings]
            Default settings for all sessions created by this agent

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.agents_route_update(
                id="id",
                name="name",
                about="about",
                model="model",
                instructions="instructions",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}",
            method="PUT",
            json={
                "metadata": metadata,
                "name": name,
                "about": about,
                "model": model,
                "instructions": instructions,
                "default_settings": default_settings,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agents_route_delete(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> CommonResourceDeletedResponse:
        """
        Delete Agent by id

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceDeletedResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.agents_route_delete(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceDeletedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agents_route_patch(
        self,
        id: CommonUuid,
        *,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        name: typing.Optional[CommonIdentifierSafeUnicode] = OMIT,
        about: typing.Optional[str] = OMIT,
        model: typing.Optional[str] = OMIT,
        instructions: typing.Optional[AgentsPatchAgentRequestInstructions] = OMIT,
        default_settings: typing.Optional[
            AgentsPatchAgentRequestDefaultSettings
        ] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Update an existing Agent by id (merges with existing values)

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        name : typing.Optional[CommonIdentifierSafeUnicode]
            Name of the agent

        about : typing.Optional[str]
            About the agent

        model : typing.Optional[str]
            Model name to use (gpt-4-turbo, gemini-nano etc)

        instructions : typing.Optional[AgentsPatchAgentRequestInstructions]
            Instructions for the agent

        default_settings : typing.Optional[AgentsPatchAgentRequestDefaultSettings]
            Default settings for all sessions created by this agent

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.agents_route_patch(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "metadata": metadata,
                "name": name,
                "about": about,
                "model": model,
                "instructions": instructions,
                "default_settings": default_settings,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agent_docs_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: AgentDocsRouteListRequestSortBy,
        direction: AgentDocsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AgentDocsRouteListResponse:
        """
        List Docs owned by an Agent

        Parameters
        ----------
        id : CommonUuid
            ID of parent

        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : AgentDocsRouteListRequestSortBy
            Sort by a field

        direction : AgentDocsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentDocsRouteListResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.agent_docs_route_list(
                id="id",
                limit=1,
                offset=1,
                sort_by="created_at",
                direction="asc",
                metadata_filter="metadata_filter",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/docs",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentDocsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agents_docs_search_route_search(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: AgentsDocsSearchRouteSearchRequestSortBy,
        direction: AgentsDocsSearchRouteSearchRequestDirection,
        metadata_filter: str,
        body: AgentsDocsSearchRouteSearchRequestBody,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AgentsDocsSearchRouteSearchResponse:
        """
        Search Docs owned by an Agent

        Parameters
        ----------
        id : CommonUuid
            ID of the parent

        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : AgentsDocsSearchRouteSearchRequestSortBy
            Sort by a field

        direction : AgentsDocsSearchRouteSearchRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        body : AgentsDocsSearchRouteSearchRequestBody

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentsDocsSearchRouteSearchResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep import DocsVectorDocSearchRequest
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.agents_docs_search_route_search(
                id="id",
                limit=1,
                offset=1,
                sort_by="created_at",
                direction="asc",
                metadata_filter="metadata_filter",
                body=DocsVectorDocSearchRequest(
                    confidence=1.1,
                    alpha=1.1,
                    mmr=True,
                    vector=[1.1],
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/search",
            method="POST",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            json={"body": body},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentsDocsSearchRouteSearchResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def tasks_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: TasksRouteListRequestSortBy,
        direction: TasksRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TasksRouteListResponse:
        """
        List tasks (paginated)

        Parameters
        ----------
        id : CommonUuid
            ID of parent

        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : TasksRouteListRequestSortBy
            Sort by a field

        direction : TasksRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TasksRouteListResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tasks_route_list(
                id="id",
                limit=1,
                offset=1,
                sort_by="created_at",
                direction="asc",
                metadata_filter="metadata_filter",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tasks",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(TasksRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def tasks_route_create(
        self,
        id: CommonUuid,
        *,
        name: str,
        description: str,
        main: typing.Sequence[TasksCreateTaskRequestMainItem],
        tools: typing.Sequence[TasksTaskTool],
        inherit_tools: bool,
        input_schema: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceCreatedResponse:
        """
        Create a new task

        Parameters
        ----------
        id : CommonUuid
            ID of parent resource

        name : str

        description : str

        main : typing.Sequence[TasksCreateTaskRequestMainItem]
            The entrypoint of the task.

        tools : typing.Sequence[TasksTaskTool]
            Tools defined specifically for this task not included in the Agent itself.

        inherit_tools : bool
            Whether to inherit tools from the parent agent or not. Defaults to true.

        input_schema : typing.Optional[typing.Dict[str, typing.Any]]
            The schema for the input to the task. `null` means all inputs are valid.

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceCreatedResponse
            The request has succeeded and a new resource has been created as a result.

        Examples
        --------
        import asyncio

        from julep import TasksEvaluateStep, TasksTaskTool
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tasks_route_create(
                id="id",
                name="name",
                description="description",
                main=[
                    TasksEvaluateStep(
                        evaluate={"key": "value"},
                    )
                ],
                tools=[
                    TasksTaskTool(
                        type="function",
                        name="name",
                    )
                ],
                inherit_tools=True,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tasks",
            method="POST",
            json={
                "name": name,
                "description": description,
                "main": main,
                "input_schema": input_schema,
                "tools": tools,
                "inherit_tools": inherit_tools,
                "metadata": metadata,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceCreatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def tasks_route_update(
        self,
        id: CommonUuid,
        child_id: CommonUuid,
        *,
        description: str,
        main: typing.Sequence[TasksUpdateTaskRequestMainItem],
        tools: typing.Sequence[TasksTaskTool],
        inherit_tools: bool,
        input_schema: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Update an existing task (overwrite existing values)

        Parameters
        ----------
        id : CommonUuid
            ID of parent resource

        child_id : CommonUuid
            ID of the resource to be updated

        description : str

        main : typing.Sequence[TasksUpdateTaskRequestMainItem]
            The entrypoint of the task.

        tools : typing.Sequence[TasksTaskTool]
            Tools defined specifically for this task not included in the Agent itself.

        inherit_tools : bool
            Whether to inherit tools from the parent agent or not. Defaults to true.

        input_schema : typing.Optional[typing.Dict[str, typing.Any]]
            The schema for the input to the task. `null` means all inputs are valid.

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep import TasksEvaluateStep, TasksTaskTool
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tasks_route_update(
                id="id",
                child_id="child_id",
                description="description",
                main=[
                    TasksEvaluateStep(
                        evaluate={"key": "value"},
                    )
                ],
                tools=[
                    TasksTaskTool(
                        type="function",
                        name="name",
                    )
                ],
                inherit_tools=True,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tasks/{jsonable_encoder(child_id)}",
            method="PUT",
            json={
                "description": description,
                "main": main,
                "input_schema": input_schema,
                "tools": tools,
                "inherit_tools": inherit_tools,
                "metadata": metadata,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def tasks_route_delete(
        self,
        id: CommonUuid,
        child_id: CommonUuid,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceDeletedResponse:
        """
        Delete a task by its id

        Parameters
        ----------
        id : CommonUuid
            ID of parent resource

        child_id : CommonUuid
            ID of the resource to be deleted

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceDeletedResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tasks_route_delete(
                id="id",
                child_id="child_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tasks/{jsonable_encoder(child_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceDeletedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def tasks_route_patch(
        self,
        id: CommonUuid,
        child_id: CommonUuid,
        *,
        description: typing.Optional[str] = OMIT,
        main: typing.Optional[typing.Sequence[TasksPatchTaskRequestMainItem]] = OMIT,
        input_schema: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        tools: typing.Optional[typing.Sequence[TasksTaskTool]] = OMIT,
        inherit_tools: typing.Optional[bool] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Update an existing task (merges with existing values)

        Parameters
        ----------
        id : CommonUuid
            ID of parent resource

        child_id : CommonUuid
            ID of the resource to be patched

        description : typing.Optional[str]

        main : typing.Optional[typing.Sequence[TasksPatchTaskRequestMainItem]]
            The entrypoint of the task.

        input_schema : typing.Optional[typing.Dict[str, typing.Any]]
            The schema for the input to the task. `null` means all inputs are valid.

        tools : typing.Optional[typing.Sequence[TasksTaskTool]]
            Tools defined specifically for this task not included in the Agent itself.

        inherit_tools : typing.Optional[bool]
            Whether to inherit tools from the parent agent or not. Defaults to true.

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tasks_route_patch(
                id="id",
                child_id="child_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tasks/{jsonable_encoder(child_id)}",
            method="PATCH",
            json={
                "description": description,
                "main": main,
                "input_schema": input_schema,
                "tools": tools,
                "inherit_tools": inherit_tools,
                "metadata": metadata,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agent_tools_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: AgentToolsRouteListRequestSortBy,
        direction: AgentToolsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AgentToolsRouteListResponse:
        """
        List tools of the given agent

        Parameters
        ----------
        id : CommonUuid
            ID of parent

        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : AgentToolsRouteListRequestSortBy
            Sort by a field

        direction : AgentToolsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentToolsRouteListResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.agent_tools_route_list(
                id="id",
                limit=1,
                offset=1,
                sort_by="created_at",
                direction="asc",
                metadata_filter="metadata_filter",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tools",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentToolsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agent_tools_route_create(
        self,
        id: CommonUuid,
        *,
        name: CommonIdentifierSafeUnicode,
        about: str,
        model: str,
        instructions: AgentsCreateAgentRequestInstructions,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        default_settings: typing.Optional[
            AgentsCreateAgentRequestDefaultSettings
        ] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceCreatedResponse:
        """
        Create a new tool for this agent

        Parameters
        ----------
        id : CommonUuid
            ID of parent resource

        name : CommonIdentifierSafeUnicode
            Name of the agent

        about : str
            About the agent

        model : str
            Model name to use (gpt-4-turbo, gemini-nano etc)

        instructions : AgentsCreateAgentRequestInstructions
            Instructions for the agent

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        default_settings : typing.Optional[AgentsCreateAgentRequestDefaultSettings]
            Default settings for all sessions created by this agent

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceCreatedResponse
            The request has succeeded and a new resource has been created as a result.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.agent_tools_route_create(
                id="id",
                name="name",
                about="about",
                model="model",
                instructions="instructions",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tools",
            method="POST",
            json={
                "metadata": metadata,
                "name": name,
                "about": about,
                "model": model,
                "instructions": instructions,
                "default_settings": default_settings,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceCreatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agent_tools_route_update(
        self,
        id: CommonUuid,
        child_id: CommonUuid,
        *,
        type: ToolsToolType,
        name: CommonValidPythonIdentifier,
        function: typing.Optional[ToolsFunctionDef] = OMIT,
        integration: typing.Optional[typing.Any] = OMIT,
        system: typing.Optional[typing.Any] = OMIT,
        api_call: typing.Optional[typing.Any] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Update an existing tool (overwrite existing values)

        Parameters
        ----------
        id : CommonUuid
            ID of parent resource

        child_id : CommonUuid
            ID of the resource to be updated

        type : ToolsToolType
            Whether this tool is a `function`, `api_call`, `system` etc. (Only `function` tool supported right now)

        name : CommonValidPythonIdentifier
            Name of the tool (must be unique for this agent and a valid python identifier string )

        function : typing.Optional[ToolsFunctionDef]

        integration : typing.Optional[typing.Any]

        system : typing.Optional[typing.Any]

        api_call : typing.Optional[typing.Any]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.agent_tools_route_update(
                id="id",
                child_id="child_id",
                type="function",
                name="name",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tools/{jsonable_encoder(child_id)}",
            method="PUT",
            json={
                "type": type,
                "name": name,
                "function": function,
                "integration": integration,
                "system": system,
                "api_call": api_call,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agent_tools_route_delete(
        self,
        id: CommonUuid,
        child_id: CommonUuid,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceDeletedResponse:
        """
        Delete an existing tool by id

        Parameters
        ----------
        id : CommonUuid
            ID of parent resource

        child_id : CommonUuid
            ID of the resource to be deleted

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceDeletedResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.agent_tools_route_delete(
                id="id",
                child_id="child_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tools/{jsonable_encoder(child_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceDeletedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agent_tools_route_patch(
        self,
        id: CommonUuid,
        child_id: CommonUuid,
        *,
        type: typing.Optional[ToolsToolType] = OMIT,
        name: typing.Optional[CommonValidPythonIdentifier] = OMIT,
        function: typing.Optional[ToolsFunctionDefUpdate] = OMIT,
        integration: typing.Optional[typing.Any] = OMIT,
        system: typing.Optional[typing.Any] = OMIT,
        api_call: typing.Optional[typing.Any] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Update an existing tool (merges with existing values)

        Parameters
        ----------
        id : CommonUuid
            ID of parent resource

        child_id : CommonUuid
            ID of the resource to be patched

        type : typing.Optional[ToolsToolType]
            Whether this tool is a `function`, `api_call`, `system` etc. (Only `function` tool supported right now)

        name : typing.Optional[CommonValidPythonIdentifier]
            Name of the tool (must be unique for this agent and a valid python identifier string )

        function : typing.Optional[ToolsFunctionDefUpdate]

        integration : typing.Optional[typing.Any]

        system : typing.Optional[typing.Any]

        api_call : typing.Optional[typing.Any]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.agent_tools_route_patch(
                id="id",
                child_id="child_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tools/{jsonable_encoder(child_id)}",
            method="PATCH",
            json={
                "type": type,
                "name": name,
                "function": function,
                "integration": integration,
                "system": system,
                "api_call": api_call,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def tasks_create_or_update_route_create_or_update(
        self,
        parent_id: CommonUuid,
        id: CommonUuid,
        *,
        name: str,
        description: str,
        main: typing.Sequence[TasksCreateTaskRequestMainItem],
        tools: typing.Sequence[TasksTaskTool],
        inherit_tools: bool,
        input_schema: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Create or update a task

        Parameters
        ----------
        parent_id : CommonUuid
            ID of parent resource

        id : CommonUuid

        name : str

        description : str

        main : typing.Sequence[TasksCreateTaskRequestMainItem]
            The entrypoint of the task.

        tools : typing.Sequence[TasksTaskTool]
            Tools defined specifically for this task not included in the Agent itself.

        inherit_tools : bool
            Whether to inherit tools from the parent agent or not. Defaults to true.

        input_schema : typing.Optional[typing.Dict[str, typing.Any]]
            The schema for the input to the task. `null` means all inputs are valid.

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep import TasksEvaluateStep, TasksTaskTool
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tasks_create_or_update_route_create_or_update(
                parent_id="parent_id",
                id="id",
                name="name",
                description="description",
                main=[
                    TasksEvaluateStep(
                        evaluate={"key": "value"},
                    )
                ],
                tools=[
                    TasksTaskTool(
                        type="function",
                        name="name",
                    )
                ],
                inherit_tools=True,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(parent_id)}/tasks/{jsonable_encoder(id)}",
            method="POST",
            json={
                "name": name,
                "description": description,
                "main": main,
                "input_schema": input_schema,
                "tools": tools,
                "inherit_tools": inherit_tools,
                "metadata": metadata,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def individual_docs_route_get(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> DocsDoc:
        """
        Get Doc by id

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DocsDoc
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.individual_docs_route_get(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"docs/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(DocsDoc, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def individual_docs_route_delete(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> CommonResourceDeletedResponse:
        """
        Delete an existing Doc by id

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceDeletedResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.individual_docs_route_delete(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"docs/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceDeletedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def embed_route_embed(
        self,
        *,
        body: DocsEmbedQueryRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> DocsEmbedQueryResponse:
        """
        Embed a query for search

        Parameters
        ----------
        body : DocsEmbedQueryRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DocsEmbedQueryResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep import DocsEmbedQueryRequest
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.embed_route_embed(
                body=DocsEmbedQueryRequest(
                    text="text",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "embed",
            method="POST",
            json={"body": body},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(DocsEmbedQueryResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def executions_route_get(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ExecutionsExecution:
        """
        Get an Execution by id

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ExecutionsExecution
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.executions_route_get(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"executions/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ExecutionsExecution, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def execution_transitions_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: ExecutionTransitionsRouteListRequestSortBy,
        direction: ExecutionTransitionsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ExecutionTransitionsRouteListResponse:
        """
        List the Transitions of an Execution by id

        Parameters
        ----------
        id : CommonUuid
            ID of parent

        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : ExecutionTransitionsRouteListRequestSortBy
            Sort by a field

        direction : ExecutionTransitionsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ExecutionTransitionsRouteListResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.execution_transitions_route_list(
                id="id",
                limit=1,
                offset=1,
                sort_by="created_at",
                direction="asc",
                metadata_filter="metadata_filter",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"executions/{jsonable_encoder(id)}/transitions",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ExecutionTransitionsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def job_route_get(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> JobsJobStatus:
        """
        Get the status of an existing Job by its id

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        JobsJobStatus
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.job_route_get(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"jobs/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(JobsJobStatus, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def sessions_route_list(
        self,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: SessionsRouteListRequestSortBy,
        direction: SessionsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SessionsRouteListResponse:
        """
        List sessions (paginated)

        Parameters
        ----------
        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : SessionsRouteListRequestSortBy
            Sort by a field

        direction : SessionsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SessionsRouteListResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.sessions_route_list(
                limit=1,
                offset=1,
                sort_by="created_at",
                direction="asc",
                metadata_filter="metadata_filter",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "sessions",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(SessionsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def sessions_route_create(
        self,
        *,
        situation: str,
        render_templates: bool,
        user: typing.Optional[CommonUuid] = OMIT,
        users: typing.Optional[typing.Sequence[CommonUuid]] = OMIT,
        agent: typing.Optional[CommonUuid] = OMIT,
        agents: typing.Optional[typing.Sequence[CommonUuid]] = OMIT,
        token_budget: typing.Optional[int] = OMIT,
        context_overflow: typing.Optional[SessionsContextOverflowType] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceCreatedResponse:
        """
        Create a new session

        Parameters
        ----------
        situation : str
            A specific situation that sets the background for this session

        render_templates : bool
            Render system and assistant message content as jinja templates

        user : typing.Optional[CommonUuid]
            User ID of user associated with this session

        users : typing.Optional[typing.Sequence[CommonUuid]]

        agent : typing.Optional[CommonUuid]
            Agent ID of agent associated with this session

        agents : typing.Optional[typing.Sequence[CommonUuid]]

        token_budget : typing.Optional[int]
            Threshold value for the adaptive context functionality

        context_overflow : typing.Optional[SessionsContextOverflowType]
            Action to start on context window overflow

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceCreatedResponse
            The request has succeeded and a new resource has been created as a result.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.sessions_route_create(
                situation="situation",
                render_templates=True,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "sessions",
            method="POST",
            json={
                "user": user,
                "users": users,
                "agent": agent,
                "agents": agents,
                "situation": situation,
                "render_templates": render_templates,
                "token_budget": token_budget,
                "context_overflow": context_overflow,
                "metadata": metadata,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceCreatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def sessions_route_get(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> SessionsSession:
        """
        Get a session by id

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SessionsSession
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.sessions_route_get(
                id="string",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sessions/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(SessionsSession, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def sessions_route_create_or_update(
        self,
        id: CommonUuid,
        *,
        situation: str,
        render_templates: bool,
        user: typing.Optional[CommonUuid] = OMIT,
        users: typing.Optional[typing.Sequence[CommonUuid]] = OMIT,
        agent: typing.Optional[CommonUuid] = OMIT,
        agents: typing.Optional[typing.Sequence[CommonUuid]] = OMIT,
        token_budget: typing.Optional[int] = OMIT,
        context_overflow: typing.Optional[SessionsContextOverflowType] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Create or update a session

        Parameters
        ----------
        id : CommonUuid

        situation : str
            A specific situation that sets the background for this session

        render_templates : bool
            Render system and assistant message content as jinja templates

        user : typing.Optional[CommonUuid]
            User ID of user associated with this session

        users : typing.Optional[typing.Sequence[CommonUuid]]

        agent : typing.Optional[CommonUuid]
            Agent ID of agent associated with this session

        agents : typing.Optional[typing.Sequence[CommonUuid]]

        token_budget : typing.Optional[int]
            Threshold value for the adaptive context functionality

        context_overflow : typing.Optional[SessionsContextOverflowType]
            Action to start on context window overflow

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.sessions_route_create_or_update(
                id="id",
                situation="situation",
                render_templates=True,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sessions/{jsonable_encoder(id)}",
            method="POST",
            json={
                "user": user,
                "users": users,
                "agent": agent,
                "agents": agents,
                "situation": situation,
                "render_templates": render_templates,
                "token_budget": token_budget,
                "context_overflow": context_overflow,
                "metadata": metadata,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def sessions_route_update(
        self,
        id: CommonUuid,
        *,
        situation: str,
        render_templates: bool,
        token_budget: typing.Optional[int] = OMIT,
        context_overflow: typing.Optional[SessionsContextOverflowType] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Update an existing session by its id (overwrites all existing values)

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        situation : str
            A specific situation that sets the background for this session

        render_templates : bool
            Render system and assistant message content as jinja templates

        token_budget : typing.Optional[int]
            Threshold value for the adaptive context functionality

        context_overflow : typing.Optional[SessionsContextOverflowType]
            Action to start on context window overflow

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.sessions_route_update(
                id="id",
                situation="situation",
                render_templates=True,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sessions/{jsonable_encoder(id)}",
            method="PUT",
            json={
                "situation": situation,
                "render_templates": render_templates,
                "token_budget": token_budget,
                "context_overflow": context_overflow,
                "metadata": metadata,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def sessions_route_delete(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> CommonResourceDeletedResponse:
        """
        Delete a session by its id

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceDeletedResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.sessions_route_delete(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sessions/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceDeletedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def sessions_route_patch(
        self,
        id: CommonUuid,
        *,
        situation: typing.Optional[str] = OMIT,
        render_templates: typing.Optional[bool] = OMIT,
        token_budget: typing.Optional[int] = OMIT,
        context_overflow: typing.Optional[SessionsContextOverflowType] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Update an existing session by its id (merges with existing values)

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        situation : typing.Optional[str]
            A specific situation that sets the background for this session

        render_templates : typing.Optional[bool]
            Render system and assistant message content as jinja templates

        token_budget : typing.Optional[int]
            Threshold value for the adaptive context functionality

        context_overflow : typing.Optional[SessionsContextOverflowType]
            Action to start on context window overflow

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.sessions_route_patch(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sessions/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "situation": situation,
                "render_templates": render_templates,
                "token_budget": token_budget,
                "context_overflow": context_overflow,
                "metadata": metadata,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def chat_route_generate(
        self,
        id: CommonUuid,
        *,
        request: ChatRouteGenerateRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ChatRouteGenerateResponse:
        """
        Generate a response from the model

        Parameters
        ----------
        id : CommonUuid
            The session ID

        request : ChatRouteGenerateRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChatRouteGenerateResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep import ChatRouteGenerateRequestPreset, EntriesInputChatMlMessage
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.chat_route_generate(
                id="id",
                request=ChatRouteGenerateRequestPreset(
                    messages=[
                        EntriesInputChatMlMessage(
                            role="user",
                            content="content",
                        )
                    ],
                    recall=True,
                    remember=True,
                    save=True,
                    stream=True,
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sessions/{jsonable_encoder(id)}/chat",
            method="POST",
            json=request,
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ChatRouteGenerateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def history_route_history(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> EntriesHistory:
        """
        Get history of a Session

        Parameters
        ----------
        id : CommonUuid
            ID of parent

        limit : CommonLimit
            Limit the number of items returned

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        EntriesHistory
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.history_route_history(
                id="id",
                limit=1,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sessions/{jsonable_encoder(id)}/history",
            method="GET",
            params={"limit": limit},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(EntriesHistory, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def history_route_delete(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> CommonResourceDeletedResponse:
        """
        Clear the history of a Session (resets the Session)

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceDeletedResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.history_route_delete(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sessions/{jsonable_encoder(id)}/history",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceDeletedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def task_executions_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: TaskExecutionsRouteListRequestSortBy,
        direction: TaskExecutionsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TaskExecutionsRouteListResponse:
        """
        List executions of the given task

        Parameters
        ----------
        id : CommonUuid
            ID of parent

        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : TaskExecutionsRouteListRequestSortBy
            Sort by a field

        direction : TaskExecutionsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TaskExecutionsRouteListResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.task_executions_route_list(
                id="id",
                limit=1,
                offset=1,
                sort_by="created_at",
                direction="asc",
                metadata_filter="metadata_filter",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(id)}/executions",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(TaskExecutionsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def task_executions_route_create(
        self,
        id: CommonUuid,
        *,
        input: typing.Dict[str, typing.Any],
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceCreatedResponse:
        """
        Create an execution for the given task

        Parameters
        ----------
        id : CommonUuid
            ID of parent resource

        input : typing.Dict[str, typing.Any]
            The input to the execution

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceCreatedResponse
            The request has succeeded and a new resource has been created as a result.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.task_executions_route_create(
                id="id",
                input={"key": "value"},
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(id)}/executions",
            method="POST",
            json={"input": input, "metadata": metadata},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceCreatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def task_executions_route_resume_with_task_token(
        self,
        id: CommonUuid,
        *,
        task_token: str,
        input: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Resume an execution with a task token

        Parameters
        ----------
        id : CommonUuid
            ID of parent Task

        task_token : str
            A Task Token is a unique identifier for a specific Task Execution.

        input : typing.Optional[typing.Dict[str, typing.Any]]
            The input to resume the execution with

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.task_executions_route_resume_with_task_token(
                id="id",
                task_token="task_token",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(id)}/executions",
            method="PUT",
            json={"task_token": task_token, "input": input, "status": "running"},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def task_executions_route_update(
        self,
        id: CommonUuid,
        child_id: CommonUuid,
        *,
        request: ExecutionsUpdateExecutionRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Update an existing Execution

        Parameters
        ----------
        id : CommonUuid
            ID of parent resource

        child_id : CommonUuid
            ID of the resource to be updated

        request : ExecutionsUpdateExecutionRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep import ExecutionsUpdateExecutionRequest_Cancelled
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.task_executions_route_update(
                id="string",
                child_id="string",
                request=ExecutionsUpdateExecutionRequest_Cancelled(
                    reason="string",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(id)}/executions/{jsonable_encoder(child_id)}",
            method="PUT",
            json=request,
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def users_route_list(
        self,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: UsersRouteListRequestSortBy,
        direction: UsersRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UsersRouteListResponse:
        """
        List users (paginated)

        Parameters
        ----------
        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : UsersRouteListRequestSortBy
            Sort by a field

        direction : UsersRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UsersRouteListResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.users_route_list(
                limit=1,
                offset=1,
                sort_by="created_at",
                direction="asc",
                metadata_filter="metadata_filter",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "users",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(UsersRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def users_route_create(
        self,
        *,
        name: CommonIdentifierSafeUnicode,
        about: str,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceCreatedResponse:
        """
        Create a new user

        Parameters
        ----------
        name : CommonIdentifierSafeUnicode
            Name of the user

        about : str
            About the user

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceCreatedResponse
            The request has succeeded and a new resource has been created as a result.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.users_route_create(
                name="name",
                about="about",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "users",
            method="POST",
            json={"metadata": metadata, "name": name, "about": about},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceCreatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def users_route_get(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> UsersUser:
        """
        Get a user by id

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UsersUser
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.users_route_get(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(UsersUser, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def users_route_create_or_update(
        self,
        id: CommonUuid,
        *,
        name: CommonIdentifierSafeUnicode,
        about: str,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Create or update a user

        Parameters
        ----------
        id : CommonUuid

        name : CommonIdentifierSafeUnicode
            Name of the user

        about : str
            About the user

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.users_route_create_or_update(
                id="id",
                name="name",
                about="about",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(id)}",
            method="POST",
            json={"metadata": metadata, "name": name, "about": about},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def users_route_update(
        self,
        id: CommonUuid,
        *,
        name: CommonIdentifierSafeUnicode,
        about: str,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Update an existing user by id (overwrite existing values)

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        name : CommonIdentifierSafeUnicode
            Name of the user

        about : str
            About the user

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.users_route_update(
                id="id",
                name="name",
                about="about",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(id)}",
            method="PUT",
            json={"metadata": metadata, "name": name, "about": about},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def users_route_delete(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> CommonResourceDeletedResponse:
        """
        Delete a user by id

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceDeletedResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.users_route_delete(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceDeletedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def users_route_patch(
        self,
        id: CommonUuid,
        *,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        name: typing.Optional[CommonIdentifierSafeUnicode] = OMIT,
        about: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CommonResourceUpdatedResponse:
        """
        Update an existing user by id (merge with existing values)

        Parameters
        ----------
        id : CommonUuid
            ID of the resource

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        name : typing.Optional[CommonIdentifierSafeUnicode]
            Name of the user

        about : typing.Optional[str]
            About the user

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CommonResourceUpdatedResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.users_route_patch(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(id)}",
            method="PATCH",
            json={"metadata": metadata, "name": name, "about": about},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(CommonResourceUpdatedResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def user_docs_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: UserDocsRouteListRequestSortBy,
        direction: UserDocsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UserDocsRouteListResponse:
        """
        List Docs owned by a User

        Parameters
        ----------
        id : CommonUuid
            ID of parent

        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : UserDocsRouteListRequestSortBy
            Sort by a field

        direction : UserDocsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UserDocsRouteListResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.user_docs_route_list(
                id="id",
                limit=1,
                offset=1,
                sort_by="created_at",
                direction="asc",
                metadata_filter="metadata_filter",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(id)}/docs",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(UserDocsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def user_docs_search_route_search(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: UserDocsSearchRouteSearchRequestSortBy,
        direction: UserDocsSearchRouteSearchRequestDirection,
        metadata_filter: str,
        body: UserDocsSearchRouteSearchRequestBody,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UserDocsSearchRouteSearchResponse:
        """
        Search Docs owned by a User

        Parameters
        ----------
        id : CommonUuid
            ID of the parent

        limit : CommonLimit
            Limit the number of items returned

        offset : CommonOffset
            Offset the items returned

        sort_by : UserDocsSearchRouteSearchRequestSortBy
            Sort by a field

        direction : UserDocsSearchRouteSearchRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        body : UserDocsSearchRouteSearchRequestBody

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UserDocsSearchRouteSearchResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep import DocsVectorDocSearchRequest
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.user_docs_search_route_search(
                id="id",
                limit=1,
                offset=1,
                sort_by="created_at",
                direction="asc",
                metadata_filter="metadata_filter",
                body=DocsVectorDocSearchRequest(
                    confidence=1.1,
                    alpha=1.1,
                    mmr=True,
                    vector=[1.1],
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(id)}/search",
            method="POST",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            json={"body": body},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(UserDocsSearchRouteSearchResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


def _get_base_url(
    *, base_url: typing.Optional[str] = None, environment: JulepApiEnvironment
) -> str:
    if base_url is not None:
        return base_url
    elif environment is not None:
        return environment.value
    else:
        raise Exception(
            "Please pass in either base_url or environment to construct the client"
        )
