# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

import httpx

from .core.api_error import ApiError
from .core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from .core.jsonable_encoder import jsonable_encoder
from .core.pydantic_utilities import pydantic_v1
from .core.request_options import RequestOptions
from .environment import JulepApiEnvironment
from .types.agent_docs_route_list_request_direction import (
    AgentDocsRouteListRequestDirection,
)
from .types.agent_docs_route_list_request_sort_by import AgentDocsRouteListRequestSortBy
from .types.agent_docs_route_list_response import AgentDocsRouteListResponse
from .types.agent_tools_route_create_response import AgentToolsRouteCreateResponse
from .types.agent_tools_route_list_request_direction import (
    AgentToolsRouteListRequestDirection,
)
from .types.agent_tools_route_list_request_sort_by import (
    AgentToolsRouteListRequestSortBy,
)
from .types.agent_tools_route_list_response import AgentToolsRouteListResponse
from .types.agents_agent import AgentsAgent
from .types.agents_create_agent_request_default_settings import (
    AgentsCreateAgentRequestDefaultSettings,
)
from .types.agents_create_agent_request_instructions import (
    AgentsCreateAgentRequestInstructions,
)
from .types.agents_create_or_update_agent_request_default_settings import (
    AgentsCreateOrUpdateAgentRequestDefaultSettings,
)
from .types.agents_create_or_update_agent_request_instructions import (
    AgentsCreateOrUpdateAgentRequestInstructions,
)
from .types.agents_docs_search_route_search_request_direction import (
    AgentsDocsSearchRouteSearchRequestDirection,
)
from .types.agents_docs_search_route_search_request_sort_by import (
    AgentsDocsSearchRouteSearchRequestSortBy,
)
from .types.agents_docs_search_route_search_response import (
    AgentsDocsSearchRouteSearchResponse,
)
from .types.agents_patch_agent_request_default_settings import (
    AgentsPatchAgentRequestDefaultSettings,
)
from .types.agents_patch_agent_request_instructions import (
    AgentsPatchAgentRequestInstructions,
)
from .types.agents_route_create_or_update_response import (
    AgentsRouteCreateOrUpdateResponse,
)
from .types.agents_route_create_response import AgentsRouteCreateResponse
from .types.agents_route_delete_response import AgentsRouteDeleteResponse
from .types.agents_route_list_request_direction import AgentsRouteListRequestDirection
from .types.agents_route_list_request_sort_by import AgentsRouteListRequestSortBy
from .types.agents_route_list_response import AgentsRouteListResponse
from .types.agents_route_patch_response import AgentsRoutePatchResponse
from .types.agents_route_update_response import AgentsRouteUpdateResponse
from .types.agents_update_agent_request_default_settings import (
    AgentsUpdateAgentRequestDefaultSettings,
)
from .types.agents_update_agent_request_instructions import (
    AgentsUpdateAgentRequestInstructions,
)
from .types.common_identifier_safe_unicode import CommonIdentifierSafeUnicode
from .types.common_limit import CommonLimit
from .types.common_offset import CommonOffset
from .types.common_uuid import CommonUuid
from .types.docs_doc import DocsDoc
from .types.docs_doc_search_request import DocsDocSearchRequest
from .types.execution_transitions_route_list_request_direction import (
    ExecutionTransitionsRouteListRequestDirection,
)
from .types.execution_transitions_route_list_request_sort_by import (
    ExecutionTransitionsRouteListRequestSortBy,
)
from .types.execution_transitions_route_list_response import (
    ExecutionTransitionsRouteListResponse,
)
from .types.executions_execution import ExecutionsExecution
from .types.executions_route_update_response import ExecutionsRouteUpdateResponse
from .types.executions_update_execution_request import ExecutionsUpdateExecutionRequest
from .types.history_route_delete_response import HistoryRouteDeleteResponse
from .types.history_route_list_request_direction import HistoryRouteListRequestDirection
from .types.history_route_list_request_sort_by import HistoryRouteListRequestSortBy
from .types.history_route_list_response import HistoryRouteListResponse
from .types.individual_docs_route_delete_response import (
    IndividualDocsRouteDeleteResponse,
)
from .types.jobs_job_status import JobsJobStatus
from .types.sessions_route_create_or_update_response import (
    SessionsRouteCreateOrUpdateResponse,
)
from .types.sessions_route_create_response import SessionsRouteCreateResponse
from .types.sessions_route_delete_response import SessionsRouteDeleteResponse
from .types.sessions_route_list_request_direction import (
    SessionsRouteListRequestDirection,
)
from .types.sessions_route_list_request_sort_by import SessionsRouteListRequestSortBy
from .types.sessions_route_list_response import SessionsRouteListResponse
from .types.sessions_route_patch_response import SessionsRoutePatchResponse
from .types.sessions_route_update_response import SessionsRouteUpdateResponse
from .types.sessions_session import SessionsSession
from .types.task_executions_route_create_response import (
    TaskExecutionsRouteCreateResponse,
)
from .types.task_executions_route_list_request_direction import (
    TaskExecutionsRouteListRequestDirection,
)
from .types.task_executions_route_list_request_sort_by import (
    TaskExecutionsRouteListRequestSortBy,
)
from .types.task_executions_route_list_response import TaskExecutionsRouteListResponse
from .types.task_executions_route_resume_with_task_token_response import (
    TaskExecutionsRouteResumeWithTaskTokenResponse,
)
from .types.tasks_route_create_or_update_response import (
    TasksRouteCreateOrUpdateResponse,
)
from .types.tasks_route_create_response import TasksRouteCreateResponse
from .types.tasks_route_delete_response import TasksRouteDeleteResponse
from .types.tasks_route_list_request_direction import TasksRouteListRequestDirection
from .types.tasks_route_list_request_sort_by import TasksRouteListRequestSortBy
from .types.tasks_route_list_response import TasksRouteListResponse
from .types.tasks_route_patch_response import TasksRoutePatchResponse
from .types.tasks_route_update_response import TasksRouteUpdateResponse
from .types.tasks_workflow_step import TasksWorkflowStep
from .types.tool_route_delete_response import ToolRouteDeleteResponse
from .types.tool_route_patch_response import ToolRoutePatchResponse
from .types.tool_route_update_response import ToolRouteUpdateResponse
from .types.tools_create_tool_request import ToolsCreateToolRequest
from .types.tools_function_def import ToolsFunctionDef
from .types.tools_function_def_update import ToolsFunctionDefUpdate
from .types.tools_tool_type import ToolsToolType
from .types.user_docs_route_list_request_direction import (
    UserDocsRouteListRequestDirection,
)
from .types.user_docs_route_list_request_sort_by import UserDocsRouteListRequestSortBy
from .types.user_docs_route_list_response import UserDocsRouteListResponse
from .types.user_docs_search_route_search_request_direction import (
    UserDocsSearchRouteSearchRequestDirection,
)
from .types.user_docs_search_route_search_request_sort_by import (
    UserDocsSearchRouteSearchRequestSortBy,
)
from .types.user_docs_search_route_search_response import (
    UserDocsSearchRouteSearchResponse,
)
from .types.users_route_create_or_update_response import (
    UsersRouteCreateOrUpdateResponse,
)
from .types.users_route_create_response import UsersRouteCreateResponse
from .types.users_route_delete_response import UsersRouteDeleteResponse
from .types.users_route_list_request_direction import UsersRouteListRequestDirection
from .types.users_route_list_request_sort_by import UsersRouteListRequestSortBy
from .types.users_route_list_response import UsersRouteListResponse
from .types.users_route_patch_response import UsersRoutePatchResponse
from .types.users_route_update_response import UsersRouteUpdateResponse
from .types.users_user import UsersUser

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class JulepApi:
    """
    Use this class to access the different functions within the SDK. You can instantiate any number of clients with different configuration that will propagate to these functions.

    Parameters
    ----------
    base_url : typing.Optional[str]
        The base url to use for requests from the client.

    environment : JulepApiEnvironment
        The environment to use for requests from the client. from .environment import JulepApiEnvironment



        Defaults to JulepApiEnvironment.DEFAULT



    auth_key : str
    api_key : str
    timeout : typing.Optional[float]
        The timeout to be used, in seconds, for requests. By default the timeout is 300 seconds, unless a custom httpx client is used, in which case this default is not enforced.

    follow_redirects : typing.Optional[bool]
        Whether the default httpx client follows redirects or not, this is irrelevant if a custom httpx client is passed in.

    httpx_client : typing.Optional[httpx.Client]
        The httpx client to use for making requests, a preconfigured client is used by default, however this is useful should you want to pass in any custom httpx configuration.

    Examples
    --------
    from julep.client import JulepApi

    client = JulepApi(
        auth_key="YOUR_AUTH_KEY",
        api_key="YOUR_API_KEY",
    )
    """

    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: JulepApiEnvironment = JulepApiEnvironment.DEFAULT,
        auth_key: str,
        api_key: str,
        timeout: typing.Optional[float] = None,
        follow_redirects: typing.Optional[bool] = True,
        httpx_client: typing.Optional[httpx.Client] = None,
    ):
        _defaulted_timeout = (
            timeout if timeout is not None else 300 if httpx_client is None else None
        )
        self._client_wrapper = SyncClientWrapper(
            base_url=_get_base_url(base_url=base_url, environment=environment),
            auth_key=auth_key,
            api_key=api_key,
            httpx_client=(
                httpx_client
                if httpx_client is not None
                else (
                    httpx.Client(
                        timeout=_defaulted_timeout, follow_redirects=follow_redirects
                    )
                    if follow_redirects is not None
                    else httpx.Client(timeout=_defaulted_timeout)
                )
            ),
            timeout=_defaulted_timeout,
        )

    def agents_route_list(
        self,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: AgentsRouteListRequestSortBy,
        direction: AgentsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AgentsRouteListResponse:
        """
        List undefined items

        Parameters
        ----------
        limit : CommonLimit
            Limit the number of undefined items returned

        offset : CommonOffset
            Offset the undefined items returned

        sort_by : AgentsRouteListRequestSortBy
            Sort by a field

        direction : AgentsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentsRouteListResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agents_route_list(
            limit=1,
            offset=1,
            sort_by="created_at",
            direction="asc",
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "agents",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agents_route_create(
        self,
        *,
        name: CommonIdentifierSafeUnicode,
        about: str,
        model: str,
        instructions: AgentsCreateAgentRequestInstructions,
        docs: typing.Sequence[typing.Any],
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        default_settings: typing.Optional[
            AgentsCreateAgentRequestDefaultSettings
        ] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AgentsRouteCreateResponse:
        """
        Create new undefined

        Parameters
        ----------
        name : CommonIdentifierSafeUnicode
            Name of the agent

        about : str
            About the agent

        model : str
            Model name to use (gpt-4-turbo, gemini-nano etc)

        instructions : AgentsCreateAgentRequestInstructions
            Instructions for the agent

        docs : typing.Sequence[typing.Any]
            Documents to index for this agent. (Max: 100 items)

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        default_settings : typing.Optional[AgentsCreateAgentRequestDefaultSettings]
            Default settings for all sessions created by this agent

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentsRouteCreateResponse
            The request has succeeded and a new resource has been created as a result.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agents_route_create(
            name="name",
            about="about",
            model="model",
            instructions="instructions",
            docs=[],
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "agents",
            method="POST",
            json={
                "metadata": metadata,
                "name": name,
                "about": about,
                "model": model,
                "instructions": instructions,
                "default_settings": default_settings,
                "docs": docs,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentsRouteCreateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agents_route_create_or_update(
        self,
        *,
        id: CommonUuid,
        name: CommonIdentifierSafeUnicode,
        about: str,
        model: str,
        instructions: AgentsCreateOrUpdateAgentRequestInstructions,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        default_settings: typing.Optional[
            AgentsCreateOrUpdateAgentRequestDefaultSettings
        ] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AgentsRouteCreateOrUpdateResponse:
        """
        Create or update undefined (ID is required in payload; existing resource will be overwritten)

        Parameters
        ----------
        id : CommonUuid

        name : CommonIdentifierSafeUnicode
            Name of the agent

        about : str
            About the agent

        model : str
            Model name to use (gpt-4-turbo, gemini-nano etc)

        instructions : AgentsCreateOrUpdateAgentRequestInstructions
            Instructions for the agent

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        default_settings : typing.Optional[AgentsCreateOrUpdateAgentRequestDefaultSettings]
            Default settings for all sessions created by this agent

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentsRouteCreateOrUpdateResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agents_route_create_or_update(
            id="id",
            name="name",
            about="about",
            model="model",
            instructions="instructions",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "agents",
            method="PUT",
            json={
                "id": id,
                "metadata": metadata,
                "name": name,
                "about": about,
                "model": model,
                "instructions": instructions,
                "default_settings": default_settings,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentsRouteCreateOrUpdateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agents_route_get(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AgentsAgent:
        """
        Get undefined by id

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentsAgent
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agents_route_get(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentsAgent, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agents_route_update(
        self,
        id: CommonUuid,
        *,
        name: CommonIdentifierSafeUnicode,
        about: str,
        model: str,
        instructions: AgentsUpdateAgentRequestInstructions,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        default_settings: typing.Optional[
            AgentsUpdateAgentRequestDefaultSettings
        ] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AgentsRouteUpdateResponse:
        """
        Update undefined by id (overwrite)

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        name : CommonIdentifierSafeUnicode
            Name of the agent

        about : str
            About the agent

        model : str
            Model name to use (gpt-4-turbo, gemini-nano etc)

        instructions : AgentsUpdateAgentRequestInstructions
            Instructions for the agent

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        default_settings : typing.Optional[AgentsUpdateAgentRequestDefaultSettings]
            Default settings for all sessions created by this agent

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentsRouteUpdateResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agents_route_update(
            id="id",
            name="name",
            about="about",
            model="model",
            instructions="instructions",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}",
            method="PUT",
            json={
                "metadata": metadata,
                "name": name,
                "about": about,
                "model": model,
                "instructions": instructions,
                "default_settings": default_settings,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentsRouteUpdateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agents_route_delete(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AgentsRouteDeleteResponse:
        """
        Delete undefined by id

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentsRouteDeleteResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agents_route_delete(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentsRouteDeleteResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agents_route_patch(
        self,
        id: CommonUuid,
        *,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        name: typing.Optional[CommonIdentifierSafeUnicode] = OMIT,
        about: typing.Optional[str] = OMIT,
        model: typing.Optional[str] = OMIT,
        instructions: typing.Optional[AgentsPatchAgentRequestInstructions] = OMIT,
        default_settings: typing.Optional[
            AgentsPatchAgentRequestDefaultSettings
        ] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AgentsRoutePatchResponse:
        """
        Patch undefined by id (merge changes)

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        name : typing.Optional[CommonIdentifierSafeUnicode]
            Name of the agent

        about : typing.Optional[str]
            About the agent

        model : typing.Optional[str]
            Model name to use (gpt-4-turbo, gemini-nano etc)

        instructions : typing.Optional[AgentsPatchAgentRequestInstructions]
            Instructions for the agent

        default_settings : typing.Optional[AgentsPatchAgentRequestDefaultSettings]
            Default settings for all sessions created by this agent

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentsRoutePatchResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agents_route_patch(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "metadata": metadata,
                "name": name,
                "about": about,
                "model": model,
                "instructions": instructions,
                "default_settings": default_settings,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentsRoutePatchResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agent_docs_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: AgentDocsRouteListRequestSortBy,
        direction: AgentDocsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AgentDocsRouteListResponse:
        """
        List undefined items of parent undefined

        Parameters
        ----------
        id : CommonUuid
            ID of parent undefined

        limit : CommonLimit
            Limit the number of undefined items returned

        offset : CommonOffset
            Offset the undefined items returned

        sort_by : AgentDocsRouteListRequestSortBy
            Sort by a field

        direction : AgentDocsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentDocsRouteListResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agent_docs_route_list(
            id="id",
            limit=1,
            offset=1,
            sort_by="created_at",
            direction="asc",
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/docs",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentDocsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agents_docs_search_route_search(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: AgentsDocsSearchRouteSearchRequestSortBy,
        direction: AgentsDocsSearchRouteSearchRequestDirection,
        metadata_filter: str,
        body: DocsDocSearchRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AgentsDocsSearchRouteSearchResponse:
        """
        Search for documents owned by undefined

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        limit : CommonLimit
            Limit the number of undefined items returned

        offset : CommonOffset
            Offset the undefined items returned

        sort_by : AgentsDocsSearchRouteSearchRequestSortBy
            Sort by a field

        direction : AgentsDocsSearchRouteSearchRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        body : DocsDocSearchRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentsDocsSearchRouteSearchResponse
            The request has succeeded.

        Examples
        --------
        from julep import DocsDocSearchRequest_Vector
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agents_docs_search_route_search(
            id="string",
            limit=1,
            offset=1,
            sort_by="created_at",
            direction="asc",
            metadata_filter="string",
            body=DocsDocSearchRequest_Vector(
                text="string",
                vector=[1.1],
                confidence=1.1,
                alpha=1.1,
                mmr=True,
                vector=[1.1],
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/search",
            method="POST",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            json={"body": body},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentsDocsSearchRouteSearchResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agent_tools_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: AgentToolsRouteListRequestSortBy,
        direction: AgentToolsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AgentToolsRouteListResponse:
        """
        List undefined items of parent undefined

        Parameters
        ----------
        id : CommonUuid
            ID of parent undefined

        limit : CommonLimit
            Limit the number of undefined items returned

        offset : CommonOffset
            Offset the undefined items returned

        sort_by : AgentToolsRouteListRequestSortBy
            Sort by a field

        direction : AgentToolsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentToolsRouteListResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agent_tools_route_list(
            id="id",
            limit=1,
            offset=1,
            sort_by="created_at",
            direction="asc",
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tools",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentToolsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def agent_tools_route_create(
        self,
        id: CommonUuid,
        *,
        name: CommonIdentifierSafeUnicode,
        about: str,
        model: str,
        instructions: AgentsCreateAgentRequestInstructions,
        docs: typing.Sequence[typing.Any],
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        default_settings: typing.Optional[
            AgentsCreateAgentRequestDefaultSettings
        ] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AgentToolsRouteCreateResponse:
        """
        Create new undefined

        Parameters
        ----------
        id : CommonUuid
            ID of parent undefined

        name : CommonIdentifierSafeUnicode
            Name of the agent

        about : str
            About the agent

        model : str
            Model name to use (gpt-4-turbo, gemini-nano etc)

        instructions : AgentsCreateAgentRequestInstructions
            Instructions for the agent

        docs : typing.Sequence[typing.Any]
            Documents to index for this agent. (Max: 100 items)

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        default_settings : typing.Optional[AgentsCreateAgentRequestDefaultSettings]
            Default settings for all sessions created by this agent

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentToolsRouteCreateResponse
            The request has succeeded and a new resource has been created as a result.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.agent_tools_route_create(
            id="id",
            name="name",
            about="about",
            model="model",
            instructions="instructions",
            docs=[],
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tools",
            method="POST",
            json={
                "metadata": metadata,
                "name": name,
                "about": about,
                "model": model,
                "instructions": instructions,
                "default_settings": default_settings,
                "docs": docs,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentToolsRouteCreateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def individual_docs_route_get(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> DocsDoc:
        """
        Get undefined by id

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DocsDoc
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.individual_docs_route_get(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"docs/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(DocsDoc, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def individual_docs_route_delete(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> IndividualDocsRouteDeleteResponse:
        """
        Delete undefined by id

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        IndividualDocsRouteDeleteResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.individual_docs_route_delete(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"docs/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(IndividualDocsRouteDeleteResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def executions_route_get(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ExecutionsExecution:
        """
        Get undefined by id

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ExecutionsExecution
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.executions_route_get(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"executions/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ExecutionsExecution, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def executions_route_update(
        self,
        id: CommonUuid,
        *,
        request: ExecutionsUpdateExecutionRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ExecutionsRouteUpdateResponse:
        """
        Update undefined by id (overwrite)

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        request : ExecutionsUpdateExecutionRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ExecutionsRouteUpdateResponse
            The request has succeeded.

        Examples
        --------
        from julep import ExecutionsUpdateExecutionRequest_Cancelled
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.executions_route_update(
            id="string",
            request=ExecutionsUpdateExecutionRequest_Cancelled(
                reason="string",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"executions/{jsonable_encoder(id)}",
            method="PUT",
            json=request,
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ExecutionsRouteUpdateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def execution_transitions_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: ExecutionTransitionsRouteListRequestSortBy,
        direction: ExecutionTransitionsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ExecutionTransitionsRouteListResponse:
        """
        List undefined items of parent undefined

        Parameters
        ----------
        id : CommonUuid
            ID of parent undefined

        limit : CommonLimit
            Limit the number of undefined items returned

        offset : CommonOffset
            Offset the undefined items returned

        sort_by : ExecutionTransitionsRouteListRequestSortBy
            Sort by a field

        direction : ExecutionTransitionsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ExecutionTransitionsRouteListResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.execution_transitions_route_list(
            id="id",
            limit=1,
            offset=1,
            sort_by="created_at",
            direction="asc",
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"executions/{jsonable_encoder(id)}/transitions",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ExecutionTransitionsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def job_route_get(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> JobsJobStatus:
        """
        Get undefined by id

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        JobsJobStatus
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.job_route_get(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"jobs/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(JobsJobStatus, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def sessions_route_list(
        self,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: SessionsRouteListRequestSortBy,
        direction: SessionsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SessionsRouteListResponse:
        """
        List undefined items

        Parameters
        ----------
        limit : CommonLimit
            Limit the number of undefined items returned

        offset : CommonOffset
            Offset the undefined items returned

        sort_by : SessionsRouteListRequestSortBy
            Sort by a field

        direction : SessionsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SessionsRouteListResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.sessions_route_list(
            limit=1,
            offset=1,
            sort_by="created_at",
            direction="asc",
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "sessions",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(SessionsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def sessions_route_create(
        self,
        *,
        situation: str,
        render_templates: bool,
        user: typing.Optional[CommonUuid] = OMIT,
        users: typing.Optional[typing.Sequence[CommonUuid]] = OMIT,
        agent: typing.Optional[CommonUuid] = OMIT,
        agents: typing.Optional[typing.Sequence[CommonUuid]] = OMIT,
        token_budget: typing.Optional[int] = OMIT,
        context_overflow: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SessionsRouteCreateResponse:
        """
        Create new undefined

        Parameters
        ----------
        situation : str
            A specific situation that sets the background for this session

        render_templates : bool
            Render system and assistant message content as jinja templates

        user : typing.Optional[CommonUuid]
            User ID of user associated with this session

        users : typing.Optional[typing.Sequence[CommonUuid]]

        agent : typing.Optional[CommonUuid]
            Agent ID of agent associated with this session

        agents : typing.Optional[typing.Sequence[CommonUuid]]

        token_budget : typing.Optional[int]
            Threshold value for the adaptive context functionality

        context_overflow : typing.Optional[str]
            Action to start on context window overflow

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SessionsRouteCreateResponse
            The request has succeeded and a new resource has been created as a result.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.sessions_route_create(
            situation="situation",
            render_templates=True,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "sessions",
            method="POST",
            json={
                "user": user,
                "users": users,
                "agent": agent,
                "agents": agents,
                "situation": situation,
                "render_templates": render_templates,
                "token_budget": token_budget,
                "context_overflow": context_overflow,
                "metadata": metadata,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(SessionsRouteCreateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def sessions_route_create_or_update(
        self,
        *,
        id: CommonUuid,
        situation: str,
        render_templates: bool,
        user: typing.Optional[CommonUuid] = OMIT,
        users: typing.Optional[typing.Sequence[CommonUuid]] = OMIT,
        agent: typing.Optional[CommonUuid] = OMIT,
        agents: typing.Optional[typing.Sequence[CommonUuid]] = OMIT,
        token_budget: typing.Optional[int] = OMIT,
        context_overflow: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SessionsRouteCreateOrUpdateResponse:
        """
        Create or update undefined (ID is required in payload; existing resource will be overwritten)

        Parameters
        ----------
        id : CommonUuid

        situation : str
            A specific situation that sets the background for this session

        render_templates : bool
            Render system and assistant message content as jinja templates

        user : typing.Optional[CommonUuid]
            User ID of user associated with this session

        users : typing.Optional[typing.Sequence[CommonUuid]]

        agent : typing.Optional[CommonUuid]
            Agent ID of agent associated with this session

        agents : typing.Optional[typing.Sequence[CommonUuid]]

        token_budget : typing.Optional[int]
            Threshold value for the adaptive context functionality

        context_overflow : typing.Optional[str]
            Action to start on context window overflow

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SessionsRouteCreateOrUpdateResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.sessions_route_create_or_update(
            id="id",
            situation="situation",
            render_templates=True,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "sessions",
            method="PUT",
            json={
                "id": id,
                "user": user,
                "users": users,
                "agent": agent,
                "agents": agents,
                "situation": situation,
                "render_templates": render_templates,
                "token_budget": token_budget,
                "context_overflow": context_overflow,
                "metadata": metadata,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(SessionsRouteCreateOrUpdateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def history_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: HistoryRouteListRequestSortBy,
        direction: HistoryRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HistoryRouteListResponse:
        """
        List undefined items of parent undefined

        Parameters
        ----------
        id : CommonUuid
            ID of parent undefined

        limit : CommonLimit
            Limit the number of undefined items returned

        offset : CommonOffset
            Offset the undefined items returned

        sort_by : HistoryRouteListRequestSortBy
            Sort by a field

        direction : HistoryRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HistoryRouteListResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.history_route_list(
            id="id",
            limit=1,
            offset=1,
            sort_by="created_at",
            direction="asc",
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sessions/history/{jsonable_encoder(id)}",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(HistoryRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def history_route_delete(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HistoryRouteDeleteResponse:
        """
        Delete undefined by id

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HistoryRouteDeleteResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.history_route_delete(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sessions/history/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(HistoryRouteDeleteResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def sessions_route_get(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> SessionsSession:
        """
        Get undefined by id

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SessionsSession
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.sessions_route_get(
            id="string",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sessions/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(SessionsSession, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def sessions_route_update(
        self,
        id: CommonUuid,
        *,
        situation: str,
        render_templates: bool,
        token_budget: typing.Optional[int] = OMIT,
        context_overflow: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SessionsRouteUpdateResponse:
        """
        Update undefined by id (overwrite)

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        situation : str
            A specific situation that sets the background for this session

        render_templates : bool
            Render system and assistant message content as jinja templates

        token_budget : typing.Optional[int]
            Threshold value for the adaptive context functionality

        context_overflow : typing.Optional[str]
            Action to start on context window overflow

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SessionsRouteUpdateResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.sessions_route_update(
            id="id",
            situation="situation",
            render_templates=True,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sessions/{jsonable_encoder(id)}",
            method="PUT",
            json={
                "situation": situation,
                "render_templates": render_templates,
                "token_budget": token_budget,
                "context_overflow": context_overflow,
                "metadata": metadata,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(SessionsRouteUpdateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def sessions_route_delete(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> SessionsRouteDeleteResponse:
        """
        Delete undefined by id

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SessionsRouteDeleteResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.sessions_route_delete(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sessions/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(SessionsRouteDeleteResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def sessions_route_patch(
        self,
        id: CommonUuid,
        *,
        situation: typing.Optional[str] = OMIT,
        render_templates: typing.Optional[bool] = OMIT,
        token_budget: typing.Optional[int] = OMIT,
        context_overflow: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SessionsRoutePatchResponse:
        """
        Patch undefined by id (merge changes)

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        situation : typing.Optional[str]
            A specific situation that sets the background for this session

        render_templates : typing.Optional[bool]
            Render system and assistant message content as jinja templates

        token_budget : typing.Optional[int]
            Threshold value for the adaptive context functionality

        context_overflow : typing.Optional[str]
            Action to start on context window overflow

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SessionsRoutePatchResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.sessions_route_patch(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sessions/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "situation": situation,
                "render_templates": render_templates,
                "token_budget": token_budget,
                "context_overflow": context_overflow,
                "metadata": metadata,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(SessionsRoutePatchResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def tasks_route_list(
        self,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: TasksRouteListRequestSortBy,
        direction: TasksRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TasksRouteListResponse:
        """
        List undefined items

        Parameters
        ----------
        limit : CommonLimit
            Limit the number of undefined items returned

        offset : CommonOffset
            Offset the undefined items returned

        sort_by : TasksRouteListRequestSortBy
            Sort by a field

        direction : TasksRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TasksRouteListResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.tasks_route_list(
            limit=1,
            offset=1,
            sort_by="created_at",
            direction="asc",
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "tasks",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(TasksRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def tasks_route_create(
        self,
        *,
        name: str,
        description: str,
        main: typing.Sequence[TasksWorkflowStep],
        tools: typing.Sequence[ToolsCreateToolRequest],
        inherit_tools: bool,
        input_schema: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TasksRouteCreateResponse:
        """
        Create new undefined

        Parameters
        ----------
        name : str

        description : str

        main : typing.Sequence[TasksWorkflowStep]
            The entrypoint of the task.

        tools : typing.Sequence[ToolsCreateToolRequest]
            Tools defined specifically for this task not included in the Agent itself.

        inherit_tools : bool
            Whether to inherit tools from the parent agent or not. Defaults to true.

        input_schema : typing.Optional[typing.Dict[str, typing.Any]]
            The schema for the input to the task. `null` means all inputs are valid.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TasksRouteCreateResponse
            The request has succeeded and a new resource has been created as a result.

        Examples
        --------
        from julep import ToolsCreateToolRequest
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.tasks_route_create(
            name="name",
            description="description",
            main=[],
            tools=[
                ToolsCreateToolRequest(
                    type="function",
                    background=True,
                    interactive=True,
                )
            ],
            inherit_tools=True,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "tasks",
            method="POST",
            json={
                "name": name,
                "description": description,
                "main": main,
                "input_schema": input_schema,
                "tools": tools,
                "inherit_tools": inherit_tools,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(TasksRouteCreateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def tasks_route_create_or_update(
        self,
        *,
        id: CommonUuid,
        name: str,
        description: str,
        main: typing.Sequence[TasksWorkflowStep],
        tools: typing.Sequence[ToolsCreateToolRequest],
        inherit_tools: bool,
        input_schema: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TasksRouteCreateOrUpdateResponse:
        """
        Create or update undefined (ID is required in payload; existing resource will be overwritten)

        Parameters
        ----------
        id : CommonUuid

        name : str

        description : str

        main : typing.Sequence[TasksWorkflowStep]
            The entrypoint of the task.

        tools : typing.Sequence[ToolsCreateToolRequest]
            Tools defined specifically for this task not included in the Agent itself.

        inherit_tools : bool
            Whether to inherit tools from the parent agent or not. Defaults to true.

        input_schema : typing.Optional[typing.Dict[str, typing.Any]]
            The schema for the input to the task. `null` means all inputs are valid.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TasksRouteCreateOrUpdateResponse
            The request has succeeded.

        Examples
        --------
        from julep import ToolsCreateToolRequest
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.tasks_route_create_or_update(
            id="id",
            name="name",
            description="description",
            main=[],
            tools=[
                ToolsCreateToolRequest(
                    type="function",
                    background=True,
                    interactive=True,
                )
            ],
            inherit_tools=True,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "tasks",
            method="PUT",
            json={
                "id": id,
                "name": name,
                "description": description,
                "main": main,
                "input_schema": input_schema,
                "tools": tools,
                "inherit_tools": inherit_tools,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(TasksRouteCreateOrUpdateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def tasks_route_update(
        self,
        id: CommonUuid,
        *,
        description: str,
        main: typing.Sequence[TasksWorkflowStep],
        tools: typing.Sequence[ToolsCreateToolRequest],
        inherit_tools: bool,
        input_schema: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TasksRouteUpdateResponse:
        """
        Update undefined by id (overwrite)

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        description : str

        main : typing.Sequence[TasksWorkflowStep]
            The entrypoint of the task.

        tools : typing.Sequence[ToolsCreateToolRequest]
            Tools defined specifically for this task not included in the Agent itself.

        inherit_tools : bool
            Whether to inherit tools from the parent agent or not. Defaults to true.

        input_schema : typing.Optional[typing.Dict[str, typing.Any]]
            The schema for the input to the task. `null` means all inputs are valid.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TasksRouteUpdateResponse
            The request has succeeded.

        Examples
        --------
        from julep import ToolsCreateToolRequest
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.tasks_route_update(
            id="id",
            description="description",
            main=[],
            tools=[
                ToolsCreateToolRequest(
                    type="function",
                    background=True,
                    interactive=True,
                )
            ],
            inherit_tools=True,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(id)}",
            method="PUT",
            json={
                "description": description,
                "main": main,
                "input_schema": input_schema,
                "tools": tools,
                "inherit_tools": inherit_tools,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(TasksRouteUpdateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def tasks_route_delete(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> TasksRouteDeleteResponse:
        """
        Delete undefined by id

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TasksRouteDeleteResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.tasks_route_delete(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(TasksRouteDeleteResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def tasks_route_patch(
        self,
        id: CommonUuid,
        *,
        description: typing.Optional[str] = OMIT,
        main: typing.Optional[typing.Sequence[TasksWorkflowStep]] = OMIT,
        input_schema: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        tools: typing.Optional[typing.Sequence[ToolsCreateToolRequest]] = OMIT,
        inherit_tools: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TasksRoutePatchResponse:
        """
        Patch undefined by id (merge changes)

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        description : typing.Optional[str]

        main : typing.Optional[typing.Sequence[TasksWorkflowStep]]
            The entrypoint of the task.

        input_schema : typing.Optional[typing.Dict[str, typing.Any]]
            The schema for the input to the task. `null` means all inputs are valid.

        tools : typing.Optional[typing.Sequence[ToolsCreateToolRequest]]
            Tools defined specifically for this task not included in the Agent itself.

        inherit_tools : typing.Optional[bool]
            Whether to inherit tools from the parent agent or not. Defaults to true.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TasksRoutePatchResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.tasks_route_patch(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "description": description,
                "main": main,
                "input_schema": input_schema,
                "tools": tools,
                "inherit_tools": inherit_tools,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(TasksRoutePatchResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def task_executions_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: TaskExecutionsRouteListRequestSortBy,
        direction: TaskExecutionsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TaskExecutionsRouteListResponse:
        """
        List undefined items of parent undefined

        Parameters
        ----------
        id : CommonUuid
            ID of parent undefined

        limit : CommonLimit
            Limit the number of undefined items returned

        offset : CommonOffset
            Offset the undefined items returned

        sort_by : TaskExecutionsRouteListRequestSortBy
            Sort by a field

        direction : TaskExecutionsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TaskExecutionsRouteListResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.task_executions_route_list(
            id="id",
            limit=1,
            offset=1,
            sort_by="created_at",
            direction="asc",
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(id)}/executions",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(TaskExecutionsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def task_executions_route_create(
        self,
        id: CommonUuid,
        *,
        input: typing.Dict[str, typing.Any],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TaskExecutionsRouteCreateResponse:
        """
        Create new undefined

        Parameters
        ----------
        id : CommonUuid
            ID of parent undefined

        input : typing.Dict[str, typing.Any]
            The input to the execution

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TaskExecutionsRouteCreateResponse
            The request has succeeded and a new resource has been created as a result.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.task_executions_route_create(
            id="id",
            input={},
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(id)}/executions",
            method="POST",
            json={"input": input},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(TaskExecutionsRouteCreateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def task_executions_route_resume_with_task_token(
        self,
        id: CommonUuid,
        *,
        task_token: str,
        input: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TaskExecutionsRouteResumeWithTaskTokenResponse:
        """
        Resume an execution with a task token

        Parameters
        ----------
        id : CommonUuid
            ID of parent Task

        task_token : str
            A Task Token is a unique identifier for a specific Task Execution.

        input : typing.Optional[typing.Dict[str, typing.Any]]
            The input to resume the execution with

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TaskExecutionsRouteResumeWithTaskTokenResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.task_executions_route_resume_with_task_token(
            id="id",
            task_token="task_token",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(id)}/executions",
            method="PUT",
            json={"task_token": task_token, "input": input, "status": "running"},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(TaskExecutionsRouteResumeWithTaskTokenResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def tool_route_update(
        self,
        id: CommonUuid,
        *,
        type: ToolsToolType,
        background: bool,
        interactive: bool,
        function: typing.Optional[ToolsFunctionDef] = OMIT,
        integration: typing.Optional[typing.Any] = OMIT,
        system: typing.Optional[typing.Any] = OMIT,
        api_call: typing.Optional[typing.Any] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ToolRouteUpdateResponse:
        """
        Update undefined by id (overwrite)

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        type : ToolsToolType
            Whether this tool is a `function`, `api_call`, `system` etc. (Only `function` tool supported right now)

        background : bool
            The tool should be run in the background (not supported at the moment)

        interactive : bool
            Whether the tool that can be run interactively (response should contain "stop" boolean field)

        function : typing.Optional[ToolsFunctionDef]

        integration : typing.Optional[typing.Any]

        system : typing.Optional[typing.Any]

        api_call : typing.Optional[typing.Any]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ToolRouteUpdateResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.tool_route_update(
            id="id",
            type="function",
            background=True,
            interactive=True,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(id)}",
            method="PUT",
            json={
                "type": type,
                "background": background,
                "interactive": interactive,
                "function": function,
                "integration": integration,
                "system": system,
                "api_call": api_call,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ToolRouteUpdateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def tool_route_delete(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ToolRouteDeleteResponse:
        """
        Delete undefined by id

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ToolRouteDeleteResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.tool_route_delete(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ToolRouteDeleteResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def tool_route_patch(
        self,
        id: CommonUuid,
        *,
        type: typing.Optional[ToolsToolType] = OMIT,
        background: typing.Optional[bool] = OMIT,
        interactive: typing.Optional[bool] = OMIT,
        function: typing.Optional[ToolsFunctionDefUpdate] = OMIT,
        integration: typing.Optional[typing.Any] = OMIT,
        system: typing.Optional[typing.Any] = OMIT,
        api_call: typing.Optional[typing.Any] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ToolRoutePatchResponse:
        """
        Patch undefined by id (merge changes)

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        type : typing.Optional[ToolsToolType]
            Whether this tool is a `function`, `api_call`, `system` etc. (Only `function` tool supported right now)

        background : typing.Optional[bool]
            The tool should be run in the background (not supported at the moment)

        interactive : typing.Optional[bool]
            Whether the tool that can be run interactively (response should contain "stop" boolean field)

        function : typing.Optional[ToolsFunctionDefUpdate]

        integration : typing.Optional[typing.Any]

        system : typing.Optional[typing.Any]

        api_call : typing.Optional[typing.Any]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ToolRoutePatchResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.tool_route_patch(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "type": type,
                "background": background,
                "interactive": interactive,
                "function": function,
                "integration": integration,
                "system": system,
                "api_call": api_call,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ToolRoutePatchResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def users_route_list(
        self,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: UsersRouteListRequestSortBy,
        direction: UsersRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UsersRouteListResponse:
        """
        List undefined items

        Parameters
        ----------
        limit : CommonLimit
            Limit the number of undefined items returned

        offset : CommonOffset
            Offset the undefined items returned

        sort_by : UsersRouteListRequestSortBy
            Sort by a field

        direction : UsersRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UsersRouteListResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.users_route_list(
            limit=1,
            offset=1,
            sort_by="created_at",
            direction="asc",
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "users",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(UsersRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def users_route_create(
        self,
        *,
        name: CommonIdentifierSafeUnicode,
        about: str,
        docs: typing.Sequence[typing.Any],
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UsersRouteCreateResponse:
        """
        Create new undefined

        Parameters
        ----------
        name : CommonIdentifierSafeUnicode
            Name of the user

        about : str
            About the user

        docs : typing.Sequence[typing.Any]
            Documents to index for this user. (Max: 100 items)

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UsersRouteCreateResponse
            The request has succeeded and a new resource has been created as a result.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.users_route_create(
            name="name",
            about="about",
            docs=[],
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "users",
            method="POST",
            json={"metadata": metadata, "name": name, "about": about, "docs": docs},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(UsersRouteCreateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def users_route_create_or_update(
        self,
        *,
        id: CommonUuid,
        name: CommonIdentifierSafeUnicode,
        about: str,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UsersRouteCreateOrUpdateResponse:
        """
        Create or update undefined (ID is required in payload; existing resource will be overwritten)

        Parameters
        ----------
        id : CommonUuid

        name : CommonIdentifierSafeUnicode
            Name of the user

        about : str
            About the user

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UsersRouteCreateOrUpdateResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.users_route_create_or_update(
            id="id",
            name="name",
            about="about",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "users",
            method="PUT",
            json={"id": id, "metadata": metadata, "name": name, "about": about},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(UsersRouteCreateOrUpdateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def users_route_get(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> UsersUser:
        """
        Get undefined by id

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UsersUser
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.users_route_get(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(UsersUser, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def users_route_update(
        self,
        id: CommonUuid,
        *,
        name: CommonIdentifierSafeUnicode,
        about: str,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UsersRouteUpdateResponse:
        """
        Update undefined by id (overwrite)

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        name : CommonIdentifierSafeUnicode
            Name of the user

        about : str
            About the user

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UsersRouteUpdateResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.users_route_update(
            id="id",
            name="name",
            about="about",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(id)}",
            method="PUT",
            json={"metadata": metadata, "name": name, "about": about},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(UsersRouteUpdateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def users_route_delete(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> UsersRouteDeleteResponse:
        """
        Delete undefined by id

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UsersRouteDeleteResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.users_route_delete(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(UsersRouteDeleteResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def users_route_patch(
        self,
        id: CommonUuid,
        *,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        name: typing.Optional[CommonIdentifierSafeUnicode] = OMIT,
        about: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UsersRoutePatchResponse:
        """
        Patch undefined by id (merge changes)

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        name : typing.Optional[CommonIdentifierSafeUnicode]
            Name of the user

        about : typing.Optional[str]
            About the user

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UsersRoutePatchResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.users_route_patch(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(id)}",
            method="PATCH",
            json={"metadata": metadata, "name": name, "about": about},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(UsersRoutePatchResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def user_docs_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: UserDocsRouteListRequestSortBy,
        direction: UserDocsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UserDocsRouteListResponse:
        """
        List undefined items of parent undefined

        Parameters
        ----------
        id : CommonUuid
            ID of parent undefined

        limit : CommonLimit
            Limit the number of undefined items returned

        offset : CommonOffset
            Offset the undefined items returned

        sort_by : UserDocsRouteListRequestSortBy
            Sort by a field

        direction : UserDocsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UserDocsRouteListResponse
            The request has succeeded.

        Examples
        --------
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.user_docs_route_list(
            id="id",
            limit=1,
            offset=1,
            sort_by="created_at",
            direction="asc",
            metadata_filter="metadata_filter",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(id)}/docs",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(UserDocsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def user_docs_search_route_search(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: UserDocsSearchRouteSearchRequestSortBy,
        direction: UserDocsSearchRouteSearchRequestDirection,
        metadata_filter: str,
        body: DocsDocSearchRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UserDocsSearchRouteSearchResponse:
        """
        Search for documents owned by undefined

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        limit : CommonLimit
            Limit the number of undefined items returned

        offset : CommonOffset
            Offset the undefined items returned

        sort_by : UserDocsSearchRouteSearchRequestSortBy
            Sort by a field

        direction : UserDocsSearchRouteSearchRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        body : DocsDocSearchRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UserDocsSearchRouteSearchResponse
            The request has succeeded.

        Examples
        --------
        from julep import DocsDocSearchRequest_Vector
        from julep.client import JulepApi

        client = JulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )
        client.user_docs_search_route_search(
            id="string",
            limit=1,
            offset=1,
            sort_by="created_at",
            direction="asc",
            metadata_filter="string",
            body=DocsDocSearchRequest_Vector(
                text="string",
                vector=[1.1],
                confidence=1.1,
                alpha=1.1,
                mmr=True,
                vector=[1.1],
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(id)}/search",
            method="POST",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            json={"body": body},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(UserDocsSearchRouteSearchResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncJulepApi:
    """
    Use this class to access the different functions within the SDK. You can instantiate any number of clients with different configuration that will propagate to these functions.

    Parameters
    ----------
    base_url : typing.Optional[str]
        The base url to use for requests from the client.

    environment : JulepApiEnvironment
        The environment to use for requests from the client. from .environment import JulepApiEnvironment



        Defaults to JulepApiEnvironment.DEFAULT



    auth_key : str
    api_key : str
    timeout : typing.Optional[float]
        The timeout to be used, in seconds, for requests. By default the timeout is 300 seconds, unless a custom httpx client is used, in which case this default is not enforced.

    follow_redirects : typing.Optional[bool]
        Whether the default httpx client follows redirects or not, this is irrelevant if a custom httpx client is passed in.

    httpx_client : typing.Optional[httpx.AsyncClient]
        The httpx client to use for making requests, a preconfigured client is used by default, however this is useful should you want to pass in any custom httpx configuration.

    Examples
    --------
    from julep.client import AsyncJulepApi

    client = AsyncJulepApi(
        auth_key="YOUR_AUTH_KEY",
        api_key="YOUR_API_KEY",
    )
    """

    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: JulepApiEnvironment = JulepApiEnvironment.DEFAULT,
        auth_key: str,
        api_key: str,
        timeout: typing.Optional[float] = None,
        follow_redirects: typing.Optional[bool] = True,
        httpx_client: typing.Optional[httpx.AsyncClient] = None,
    ):
        _defaulted_timeout = (
            timeout if timeout is not None else 300 if httpx_client is None else None
        )
        self._client_wrapper = AsyncClientWrapper(
            base_url=_get_base_url(base_url=base_url, environment=environment),
            auth_key=auth_key,
            api_key=api_key,
            httpx_client=(
                httpx_client
                if httpx_client is not None
                else (
                    httpx.AsyncClient(
                        timeout=_defaulted_timeout, follow_redirects=follow_redirects
                    )
                    if follow_redirects is not None
                    else httpx.AsyncClient(timeout=_defaulted_timeout)
                )
            ),
            timeout=_defaulted_timeout,
        )

    async def agents_route_list(
        self,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: AgentsRouteListRequestSortBy,
        direction: AgentsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AgentsRouteListResponse:
        """
        List undefined items

        Parameters
        ----------
        limit : CommonLimit
            Limit the number of undefined items returned

        offset : CommonOffset
            Offset the undefined items returned

        sort_by : AgentsRouteListRequestSortBy
            Sort by a field

        direction : AgentsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentsRouteListResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.agents_route_list(
                limit=1,
                offset=1,
                sort_by="created_at",
                direction="asc",
                metadata_filter="metadata_filter",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "agents",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agents_route_create(
        self,
        *,
        name: CommonIdentifierSafeUnicode,
        about: str,
        model: str,
        instructions: AgentsCreateAgentRequestInstructions,
        docs: typing.Sequence[typing.Any],
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        default_settings: typing.Optional[
            AgentsCreateAgentRequestDefaultSettings
        ] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AgentsRouteCreateResponse:
        """
        Create new undefined

        Parameters
        ----------
        name : CommonIdentifierSafeUnicode
            Name of the agent

        about : str
            About the agent

        model : str
            Model name to use (gpt-4-turbo, gemini-nano etc)

        instructions : AgentsCreateAgentRequestInstructions
            Instructions for the agent

        docs : typing.Sequence[typing.Any]
            Documents to index for this agent. (Max: 100 items)

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        default_settings : typing.Optional[AgentsCreateAgentRequestDefaultSettings]
            Default settings for all sessions created by this agent

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentsRouteCreateResponse
            The request has succeeded and a new resource has been created as a result.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.agents_route_create(
                name="name",
                about="about",
                model="model",
                instructions="instructions",
                docs=[],
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "agents",
            method="POST",
            json={
                "metadata": metadata,
                "name": name,
                "about": about,
                "model": model,
                "instructions": instructions,
                "default_settings": default_settings,
                "docs": docs,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentsRouteCreateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agents_route_create_or_update(
        self,
        *,
        id: CommonUuid,
        name: CommonIdentifierSafeUnicode,
        about: str,
        model: str,
        instructions: AgentsCreateOrUpdateAgentRequestInstructions,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        default_settings: typing.Optional[
            AgentsCreateOrUpdateAgentRequestDefaultSettings
        ] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AgentsRouteCreateOrUpdateResponse:
        """
        Create or update undefined (ID is required in payload; existing resource will be overwritten)

        Parameters
        ----------
        id : CommonUuid

        name : CommonIdentifierSafeUnicode
            Name of the agent

        about : str
            About the agent

        model : str
            Model name to use (gpt-4-turbo, gemini-nano etc)

        instructions : AgentsCreateOrUpdateAgentRequestInstructions
            Instructions for the agent

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        default_settings : typing.Optional[AgentsCreateOrUpdateAgentRequestDefaultSettings]
            Default settings for all sessions created by this agent

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentsRouteCreateOrUpdateResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.agents_route_create_or_update(
                id="id",
                name="name",
                about="about",
                model="model",
                instructions="instructions",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "agents",
            method="PUT",
            json={
                "id": id,
                "metadata": metadata,
                "name": name,
                "about": about,
                "model": model,
                "instructions": instructions,
                "default_settings": default_settings,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentsRouteCreateOrUpdateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agents_route_get(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AgentsAgent:
        """
        Get undefined by id

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentsAgent
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.agents_route_get(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentsAgent, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agents_route_update(
        self,
        id: CommonUuid,
        *,
        name: CommonIdentifierSafeUnicode,
        about: str,
        model: str,
        instructions: AgentsUpdateAgentRequestInstructions,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        default_settings: typing.Optional[
            AgentsUpdateAgentRequestDefaultSettings
        ] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AgentsRouteUpdateResponse:
        """
        Update undefined by id (overwrite)

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        name : CommonIdentifierSafeUnicode
            Name of the agent

        about : str
            About the agent

        model : str
            Model name to use (gpt-4-turbo, gemini-nano etc)

        instructions : AgentsUpdateAgentRequestInstructions
            Instructions for the agent

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        default_settings : typing.Optional[AgentsUpdateAgentRequestDefaultSettings]
            Default settings for all sessions created by this agent

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentsRouteUpdateResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.agents_route_update(
                id="id",
                name="name",
                about="about",
                model="model",
                instructions="instructions",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}",
            method="PUT",
            json={
                "metadata": metadata,
                "name": name,
                "about": about,
                "model": model,
                "instructions": instructions,
                "default_settings": default_settings,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentsRouteUpdateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agents_route_delete(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AgentsRouteDeleteResponse:
        """
        Delete undefined by id

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentsRouteDeleteResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.agents_route_delete(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentsRouteDeleteResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agents_route_patch(
        self,
        id: CommonUuid,
        *,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        name: typing.Optional[CommonIdentifierSafeUnicode] = OMIT,
        about: typing.Optional[str] = OMIT,
        model: typing.Optional[str] = OMIT,
        instructions: typing.Optional[AgentsPatchAgentRequestInstructions] = OMIT,
        default_settings: typing.Optional[
            AgentsPatchAgentRequestDefaultSettings
        ] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AgentsRoutePatchResponse:
        """
        Patch undefined by id (merge changes)

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        name : typing.Optional[CommonIdentifierSafeUnicode]
            Name of the agent

        about : typing.Optional[str]
            About the agent

        model : typing.Optional[str]
            Model name to use (gpt-4-turbo, gemini-nano etc)

        instructions : typing.Optional[AgentsPatchAgentRequestInstructions]
            Instructions for the agent

        default_settings : typing.Optional[AgentsPatchAgentRequestDefaultSettings]
            Default settings for all sessions created by this agent

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentsRoutePatchResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.agents_route_patch(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "metadata": metadata,
                "name": name,
                "about": about,
                "model": model,
                "instructions": instructions,
                "default_settings": default_settings,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentsRoutePatchResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agent_docs_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: AgentDocsRouteListRequestSortBy,
        direction: AgentDocsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AgentDocsRouteListResponse:
        """
        List undefined items of parent undefined

        Parameters
        ----------
        id : CommonUuid
            ID of parent undefined

        limit : CommonLimit
            Limit the number of undefined items returned

        offset : CommonOffset
            Offset the undefined items returned

        sort_by : AgentDocsRouteListRequestSortBy
            Sort by a field

        direction : AgentDocsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentDocsRouteListResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.agent_docs_route_list(
                id="id",
                limit=1,
                offset=1,
                sort_by="created_at",
                direction="asc",
                metadata_filter="metadata_filter",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/docs",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentDocsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agents_docs_search_route_search(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: AgentsDocsSearchRouteSearchRequestSortBy,
        direction: AgentsDocsSearchRouteSearchRequestDirection,
        metadata_filter: str,
        body: DocsDocSearchRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AgentsDocsSearchRouteSearchResponse:
        """
        Search for documents owned by undefined

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        limit : CommonLimit
            Limit the number of undefined items returned

        offset : CommonOffset
            Offset the undefined items returned

        sort_by : AgentsDocsSearchRouteSearchRequestSortBy
            Sort by a field

        direction : AgentsDocsSearchRouteSearchRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        body : DocsDocSearchRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentsDocsSearchRouteSearchResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep import DocsDocSearchRequest_Vector
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.agents_docs_search_route_search(
                id="string",
                limit=1,
                offset=1,
                sort_by="created_at",
                direction="asc",
                metadata_filter="string",
                body=DocsDocSearchRequest_Vector(
                    text="string",
                    vector=[1.1],
                    confidence=1.1,
                    alpha=1.1,
                    mmr=True,
                    vector=[1.1],
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/search",
            method="POST",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            json={"body": body},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentsDocsSearchRouteSearchResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agent_tools_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: AgentToolsRouteListRequestSortBy,
        direction: AgentToolsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AgentToolsRouteListResponse:
        """
        List undefined items of parent undefined

        Parameters
        ----------
        id : CommonUuid
            ID of parent undefined

        limit : CommonLimit
            Limit the number of undefined items returned

        offset : CommonOffset
            Offset the undefined items returned

        sort_by : AgentToolsRouteListRequestSortBy
            Sort by a field

        direction : AgentToolsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentToolsRouteListResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.agent_tools_route_list(
                id="id",
                limit=1,
                offset=1,
                sort_by="created_at",
                direction="asc",
                metadata_filter="metadata_filter",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tools",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentToolsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def agent_tools_route_create(
        self,
        id: CommonUuid,
        *,
        name: CommonIdentifierSafeUnicode,
        about: str,
        model: str,
        instructions: AgentsCreateAgentRequestInstructions,
        docs: typing.Sequence[typing.Any],
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        default_settings: typing.Optional[
            AgentsCreateAgentRequestDefaultSettings
        ] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AgentToolsRouteCreateResponse:
        """
        Create new undefined

        Parameters
        ----------
        id : CommonUuid
            ID of parent undefined

        name : CommonIdentifierSafeUnicode
            Name of the agent

        about : str
            About the agent

        model : str
            Model name to use (gpt-4-turbo, gemini-nano etc)

        instructions : AgentsCreateAgentRequestInstructions
            Instructions for the agent

        docs : typing.Sequence[typing.Any]
            Documents to index for this agent. (Max: 100 items)

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        default_settings : typing.Optional[AgentsCreateAgentRequestDefaultSettings]
            Default settings for all sessions created by this agent

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentToolsRouteCreateResponse
            The request has succeeded and a new resource has been created as a result.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.agent_tools_route_create(
                id="id",
                name="name",
                about="about",
                model="model",
                instructions="instructions",
                docs=[],
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(id)}/tools",
            method="POST",
            json={
                "metadata": metadata,
                "name": name,
                "about": about,
                "model": model,
                "instructions": instructions,
                "default_settings": default_settings,
                "docs": docs,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(AgentToolsRouteCreateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def individual_docs_route_get(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> DocsDoc:
        """
        Get undefined by id

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DocsDoc
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.individual_docs_route_get(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"docs/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(DocsDoc, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def individual_docs_route_delete(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> IndividualDocsRouteDeleteResponse:
        """
        Delete undefined by id

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        IndividualDocsRouteDeleteResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.individual_docs_route_delete(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"docs/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(IndividualDocsRouteDeleteResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def executions_route_get(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ExecutionsExecution:
        """
        Get undefined by id

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ExecutionsExecution
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.executions_route_get(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"executions/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ExecutionsExecution, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def executions_route_update(
        self,
        id: CommonUuid,
        *,
        request: ExecutionsUpdateExecutionRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ExecutionsRouteUpdateResponse:
        """
        Update undefined by id (overwrite)

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        request : ExecutionsUpdateExecutionRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ExecutionsRouteUpdateResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep import ExecutionsUpdateExecutionRequest_Cancelled
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.executions_route_update(
                id="string",
                request=ExecutionsUpdateExecutionRequest_Cancelled(
                    reason="string",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"executions/{jsonable_encoder(id)}",
            method="PUT",
            json=request,
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ExecutionsRouteUpdateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def execution_transitions_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: ExecutionTransitionsRouteListRequestSortBy,
        direction: ExecutionTransitionsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ExecutionTransitionsRouteListResponse:
        """
        List undefined items of parent undefined

        Parameters
        ----------
        id : CommonUuid
            ID of parent undefined

        limit : CommonLimit
            Limit the number of undefined items returned

        offset : CommonOffset
            Offset the undefined items returned

        sort_by : ExecutionTransitionsRouteListRequestSortBy
            Sort by a field

        direction : ExecutionTransitionsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ExecutionTransitionsRouteListResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.execution_transitions_route_list(
                id="id",
                limit=1,
                offset=1,
                sort_by="created_at",
                direction="asc",
                metadata_filter="metadata_filter",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"executions/{jsonable_encoder(id)}/transitions",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ExecutionTransitionsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def job_route_get(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> JobsJobStatus:
        """
        Get undefined by id

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        JobsJobStatus
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.job_route_get(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"jobs/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(JobsJobStatus, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def sessions_route_list(
        self,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: SessionsRouteListRequestSortBy,
        direction: SessionsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SessionsRouteListResponse:
        """
        List undefined items

        Parameters
        ----------
        limit : CommonLimit
            Limit the number of undefined items returned

        offset : CommonOffset
            Offset the undefined items returned

        sort_by : SessionsRouteListRequestSortBy
            Sort by a field

        direction : SessionsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SessionsRouteListResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.sessions_route_list(
                limit=1,
                offset=1,
                sort_by="created_at",
                direction="asc",
                metadata_filter="metadata_filter",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "sessions",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(SessionsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def sessions_route_create(
        self,
        *,
        situation: str,
        render_templates: bool,
        user: typing.Optional[CommonUuid] = OMIT,
        users: typing.Optional[typing.Sequence[CommonUuid]] = OMIT,
        agent: typing.Optional[CommonUuid] = OMIT,
        agents: typing.Optional[typing.Sequence[CommonUuid]] = OMIT,
        token_budget: typing.Optional[int] = OMIT,
        context_overflow: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SessionsRouteCreateResponse:
        """
        Create new undefined

        Parameters
        ----------
        situation : str
            A specific situation that sets the background for this session

        render_templates : bool
            Render system and assistant message content as jinja templates

        user : typing.Optional[CommonUuid]
            User ID of user associated with this session

        users : typing.Optional[typing.Sequence[CommonUuid]]

        agent : typing.Optional[CommonUuid]
            Agent ID of agent associated with this session

        agents : typing.Optional[typing.Sequence[CommonUuid]]

        token_budget : typing.Optional[int]
            Threshold value for the adaptive context functionality

        context_overflow : typing.Optional[str]
            Action to start on context window overflow

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SessionsRouteCreateResponse
            The request has succeeded and a new resource has been created as a result.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.sessions_route_create(
                situation="situation",
                render_templates=True,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "sessions",
            method="POST",
            json={
                "user": user,
                "users": users,
                "agent": agent,
                "agents": agents,
                "situation": situation,
                "render_templates": render_templates,
                "token_budget": token_budget,
                "context_overflow": context_overflow,
                "metadata": metadata,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(SessionsRouteCreateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def sessions_route_create_or_update(
        self,
        *,
        id: CommonUuid,
        situation: str,
        render_templates: bool,
        user: typing.Optional[CommonUuid] = OMIT,
        users: typing.Optional[typing.Sequence[CommonUuid]] = OMIT,
        agent: typing.Optional[CommonUuid] = OMIT,
        agents: typing.Optional[typing.Sequence[CommonUuid]] = OMIT,
        token_budget: typing.Optional[int] = OMIT,
        context_overflow: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SessionsRouteCreateOrUpdateResponse:
        """
        Create or update undefined (ID is required in payload; existing resource will be overwritten)

        Parameters
        ----------
        id : CommonUuid

        situation : str
            A specific situation that sets the background for this session

        render_templates : bool
            Render system and assistant message content as jinja templates

        user : typing.Optional[CommonUuid]
            User ID of user associated with this session

        users : typing.Optional[typing.Sequence[CommonUuid]]

        agent : typing.Optional[CommonUuid]
            Agent ID of agent associated with this session

        agents : typing.Optional[typing.Sequence[CommonUuid]]

        token_budget : typing.Optional[int]
            Threshold value for the adaptive context functionality

        context_overflow : typing.Optional[str]
            Action to start on context window overflow

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SessionsRouteCreateOrUpdateResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.sessions_route_create_or_update(
                id="id",
                situation="situation",
                render_templates=True,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "sessions",
            method="PUT",
            json={
                "id": id,
                "user": user,
                "users": users,
                "agent": agent,
                "agents": agents,
                "situation": situation,
                "render_templates": render_templates,
                "token_budget": token_budget,
                "context_overflow": context_overflow,
                "metadata": metadata,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(SessionsRouteCreateOrUpdateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def history_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: HistoryRouteListRequestSortBy,
        direction: HistoryRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HistoryRouteListResponse:
        """
        List undefined items of parent undefined

        Parameters
        ----------
        id : CommonUuid
            ID of parent undefined

        limit : CommonLimit
            Limit the number of undefined items returned

        offset : CommonOffset
            Offset the undefined items returned

        sort_by : HistoryRouteListRequestSortBy
            Sort by a field

        direction : HistoryRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HistoryRouteListResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.history_route_list(
                id="id",
                limit=1,
                offset=1,
                sort_by="created_at",
                direction="asc",
                metadata_filter="metadata_filter",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sessions/history/{jsonable_encoder(id)}",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(HistoryRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def history_route_delete(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HistoryRouteDeleteResponse:
        """
        Delete undefined by id

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HistoryRouteDeleteResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.history_route_delete(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sessions/history/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(HistoryRouteDeleteResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def sessions_route_get(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> SessionsSession:
        """
        Get undefined by id

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SessionsSession
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.sessions_route_get(
                id="string",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sessions/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(SessionsSession, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def sessions_route_update(
        self,
        id: CommonUuid,
        *,
        situation: str,
        render_templates: bool,
        token_budget: typing.Optional[int] = OMIT,
        context_overflow: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SessionsRouteUpdateResponse:
        """
        Update undefined by id (overwrite)

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        situation : str
            A specific situation that sets the background for this session

        render_templates : bool
            Render system and assistant message content as jinja templates

        token_budget : typing.Optional[int]
            Threshold value for the adaptive context functionality

        context_overflow : typing.Optional[str]
            Action to start on context window overflow

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SessionsRouteUpdateResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.sessions_route_update(
                id="id",
                situation="situation",
                render_templates=True,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sessions/{jsonable_encoder(id)}",
            method="PUT",
            json={
                "situation": situation,
                "render_templates": render_templates,
                "token_budget": token_budget,
                "context_overflow": context_overflow,
                "metadata": metadata,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(SessionsRouteUpdateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def sessions_route_delete(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> SessionsRouteDeleteResponse:
        """
        Delete undefined by id

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SessionsRouteDeleteResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.sessions_route_delete(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sessions/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(SessionsRouteDeleteResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def sessions_route_patch(
        self,
        id: CommonUuid,
        *,
        situation: typing.Optional[str] = OMIT,
        render_templates: typing.Optional[bool] = OMIT,
        token_budget: typing.Optional[int] = OMIT,
        context_overflow: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SessionsRoutePatchResponse:
        """
        Patch undefined by id (merge changes)

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        situation : typing.Optional[str]
            A specific situation that sets the background for this session

        render_templates : typing.Optional[bool]
            Render system and assistant message content as jinja templates

        token_budget : typing.Optional[int]
            Threshold value for the adaptive context functionality

        context_overflow : typing.Optional[str]
            Action to start on context window overflow

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SessionsRoutePatchResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.sessions_route_patch(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sessions/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "situation": situation,
                "render_templates": render_templates,
                "token_budget": token_budget,
                "context_overflow": context_overflow,
                "metadata": metadata,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(SessionsRoutePatchResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def tasks_route_list(
        self,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: TasksRouteListRequestSortBy,
        direction: TasksRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TasksRouteListResponse:
        """
        List undefined items

        Parameters
        ----------
        limit : CommonLimit
            Limit the number of undefined items returned

        offset : CommonOffset
            Offset the undefined items returned

        sort_by : TasksRouteListRequestSortBy
            Sort by a field

        direction : TasksRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TasksRouteListResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tasks_route_list(
                limit=1,
                offset=1,
                sort_by="created_at",
                direction="asc",
                metadata_filter="metadata_filter",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "tasks",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(TasksRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def tasks_route_create(
        self,
        *,
        name: str,
        description: str,
        main: typing.Sequence[TasksWorkflowStep],
        tools: typing.Sequence[ToolsCreateToolRequest],
        inherit_tools: bool,
        input_schema: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TasksRouteCreateResponse:
        """
        Create new undefined

        Parameters
        ----------
        name : str

        description : str

        main : typing.Sequence[TasksWorkflowStep]
            The entrypoint of the task.

        tools : typing.Sequence[ToolsCreateToolRequest]
            Tools defined specifically for this task not included in the Agent itself.

        inherit_tools : bool
            Whether to inherit tools from the parent agent or not. Defaults to true.

        input_schema : typing.Optional[typing.Dict[str, typing.Any]]
            The schema for the input to the task. `null` means all inputs are valid.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TasksRouteCreateResponse
            The request has succeeded and a new resource has been created as a result.

        Examples
        --------
        import asyncio

        from julep import ToolsCreateToolRequest
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tasks_route_create(
                name="name",
                description="description",
                main=[],
                tools=[
                    ToolsCreateToolRequest(
                        type="function",
                        background=True,
                        interactive=True,
                    )
                ],
                inherit_tools=True,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "tasks",
            method="POST",
            json={
                "name": name,
                "description": description,
                "main": main,
                "input_schema": input_schema,
                "tools": tools,
                "inherit_tools": inherit_tools,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(TasksRouteCreateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def tasks_route_create_or_update(
        self,
        *,
        id: CommonUuid,
        name: str,
        description: str,
        main: typing.Sequence[TasksWorkflowStep],
        tools: typing.Sequence[ToolsCreateToolRequest],
        inherit_tools: bool,
        input_schema: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TasksRouteCreateOrUpdateResponse:
        """
        Create or update undefined (ID is required in payload; existing resource will be overwritten)

        Parameters
        ----------
        id : CommonUuid

        name : str

        description : str

        main : typing.Sequence[TasksWorkflowStep]
            The entrypoint of the task.

        tools : typing.Sequence[ToolsCreateToolRequest]
            Tools defined specifically for this task not included in the Agent itself.

        inherit_tools : bool
            Whether to inherit tools from the parent agent or not. Defaults to true.

        input_schema : typing.Optional[typing.Dict[str, typing.Any]]
            The schema for the input to the task. `null` means all inputs are valid.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TasksRouteCreateOrUpdateResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep import ToolsCreateToolRequest
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tasks_route_create_or_update(
                id="id",
                name="name",
                description="description",
                main=[],
                tools=[
                    ToolsCreateToolRequest(
                        type="function",
                        background=True,
                        interactive=True,
                    )
                ],
                inherit_tools=True,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "tasks",
            method="PUT",
            json={
                "id": id,
                "name": name,
                "description": description,
                "main": main,
                "input_schema": input_schema,
                "tools": tools,
                "inherit_tools": inherit_tools,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(TasksRouteCreateOrUpdateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def tasks_route_update(
        self,
        id: CommonUuid,
        *,
        description: str,
        main: typing.Sequence[TasksWorkflowStep],
        tools: typing.Sequence[ToolsCreateToolRequest],
        inherit_tools: bool,
        input_schema: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TasksRouteUpdateResponse:
        """
        Update undefined by id (overwrite)

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        description : str

        main : typing.Sequence[TasksWorkflowStep]
            The entrypoint of the task.

        tools : typing.Sequence[ToolsCreateToolRequest]
            Tools defined specifically for this task not included in the Agent itself.

        inherit_tools : bool
            Whether to inherit tools from the parent agent or not. Defaults to true.

        input_schema : typing.Optional[typing.Dict[str, typing.Any]]
            The schema for the input to the task. `null` means all inputs are valid.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TasksRouteUpdateResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep import ToolsCreateToolRequest
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tasks_route_update(
                id="id",
                description="description",
                main=[],
                tools=[
                    ToolsCreateToolRequest(
                        type="function",
                        background=True,
                        interactive=True,
                    )
                ],
                inherit_tools=True,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(id)}",
            method="PUT",
            json={
                "description": description,
                "main": main,
                "input_schema": input_schema,
                "tools": tools,
                "inherit_tools": inherit_tools,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(TasksRouteUpdateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def tasks_route_delete(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> TasksRouteDeleteResponse:
        """
        Delete undefined by id

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TasksRouteDeleteResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tasks_route_delete(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(TasksRouteDeleteResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def tasks_route_patch(
        self,
        id: CommonUuid,
        *,
        description: typing.Optional[str] = OMIT,
        main: typing.Optional[typing.Sequence[TasksWorkflowStep]] = OMIT,
        input_schema: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        tools: typing.Optional[typing.Sequence[ToolsCreateToolRequest]] = OMIT,
        inherit_tools: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TasksRoutePatchResponse:
        """
        Patch undefined by id (merge changes)

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        description : typing.Optional[str]

        main : typing.Optional[typing.Sequence[TasksWorkflowStep]]
            The entrypoint of the task.

        input_schema : typing.Optional[typing.Dict[str, typing.Any]]
            The schema for the input to the task. `null` means all inputs are valid.

        tools : typing.Optional[typing.Sequence[ToolsCreateToolRequest]]
            Tools defined specifically for this task not included in the Agent itself.

        inherit_tools : typing.Optional[bool]
            Whether to inherit tools from the parent agent or not. Defaults to true.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TasksRoutePatchResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tasks_route_patch(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "description": description,
                "main": main,
                "input_schema": input_schema,
                "tools": tools,
                "inherit_tools": inherit_tools,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(TasksRoutePatchResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def task_executions_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: TaskExecutionsRouteListRequestSortBy,
        direction: TaskExecutionsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TaskExecutionsRouteListResponse:
        """
        List undefined items of parent undefined

        Parameters
        ----------
        id : CommonUuid
            ID of parent undefined

        limit : CommonLimit
            Limit the number of undefined items returned

        offset : CommonOffset
            Offset the undefined items returned

        sort_by : TaskExecutionsRouteListRequestSortBy
            Sort by a field

        direction : TaskExecutionsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TaskExecutionsRouteListResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.task_executions_route_list(
                id="id",
                limit=1,
                offset=1,
                sort_by="created_at",
                direction="asc",
                metadata_filter="metadata_filter",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(id)}/executions",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(TaskExecutionsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def task_executions_route_create(
        self,
        id: CommonUuid,
        *,
        input: typing.Dict[str, typing.Any],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TaskExecutionsRouteCreateResponse:
        """
        Create new undefined

        Parameters
        ----------
        id : CommonUuid
            ID of parent undefined

        input : typing.Dict[str, typing.Any]
            The input to the execution

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TaskExecutionsRouteCreateResponse
            The request has succeeded and a new resource has been created as a result.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.task_executions_route_create(
                id="id",
                input={},
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(id)}/executions",
            method="POST",
            json={"input": input},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(TaskExecutionsRouteCreateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def task_executions_route_resume_with_task_token(
        self,
        id: CommonUuid,
        *,
        task_token: str,
        input: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TaskExecutionsRouteResumeWithTaskTokenResponse:
        """
        Resume an execution with a task token

        Parameters
        ----------
        id : CommonUuid
            ID of parent Task

        task_token : str
            A Task Token is a unique identifier for a specific Task Execution.

        input : typing.Optional[typing.Dict[str, typing.Any]]
            The input to resume the execution with

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TaskExecutionsRouteResumeWithTaskTokenResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.task_executions_route_resume_with_task_token(
                id="id",
                task_token="task_token",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(id)}/executions",
            method="PUT",
            json={"task_token": task_token, "input": input, "status": "running"},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(TaskExecutionsRouteResumeWithTaskTokenResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def tool_route_update(
        self,
        id: CommonUuid,
        *,
        type: ToolsToolType,
        background: bool,
        interactive: bool,
        function: typing.Optional[ToolsFunctionDef] = OMIT,
        integration: typing.Optional[typing.Any] = OMIT,
        system: typing.Optional[typing.Any] = OMIT,
        api_call: typing.Optional[typing.Any] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ToolRouteUpdateResponse:
        """
        Update undefined by id (overwrite)

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        type : ToolsToolType
            Whether this tool is a `function`, `api_call`, `system` etc. (Only `function` tool supported right now)

        background : bool
            The tool should be run in the background (not supported at the moment)

        interactive : bool
            Whether the tool that can be run interactively (response should contain "stop" boolean field)

        function : typing.Optional[ToolsFunctionDef]

        integration : typing.Optional[typing.Any]

        system : typing.Optional[typing.Any]

        api_call : typing.Optional[typing.Any]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ToolRouteUpdateResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tool_route_update(
                id="id",
                type="function",
                background=True,
                interactive=True,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(id)}",
            method="PUT",
            json={
                "type": type,
                "background": background,
                "interactive": interactive,
                "function": function,
                "integration": integration,
                "system": system,
                "api_call": api_call,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ToolRouteUpdateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def tool_route_delete(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ToolRouteDeleteResponse:
        """
        Delete undefined by id

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ToolRouteDeleteResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tool_route_delete(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ToolRouteDeleteResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def tool_route_patch(
        self,
        id: CommonUuid,
        *,
        type: typing.Optional[ToolsToolType] = OMIT,
        background: typing.Optional[bool] = OMIT,
        interactive: typing.Optional[bool] = OMIT,
        function: typing.Optional[ToolsFunctionDefUpdate] = OMIT,
        integration: typing.Optional[typing.Any] = OMIT,
        system: typing.Optional[typing.Any] = OMIT,
        api_call: typing.Optional[typing.Any] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ToolRoutePatchResponse:
        """
        Patch undefined by id (merge changes)

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        type : typing.Optional[ToolsToolType]
            Whether this tool is a `function`, `api_call`, `system` etc. (Only `function` tool supported right now)

        background : typing.Optional[bool]
            The tool should be run in the background (not supported at the moment)

        interactive : typing.Optional[bool]
            Whether the tool that can be run interactively (response should contain "stop" boolean field)

        function : typing.Optional[ToolsFunctionDefUpdate]

        integration : typing.Optional[typing.Any]

        system : typing.Optional[typing.Any]

        api_call : typing.Optional[typing.Any]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ToolRoutePatchResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.tool_route_patch(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "type": type,
                "background": background,
                "interactive": interactive,
                "function": function,
                "integration": integration,
                "system": system,
                "api_call": api_call,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(ToolRoutePatchResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def users_route_list(
        self,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: UsersRouteListRequestSortBy,
        direction: UsersRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UsersRouteListResponse:
        """
        List undefined items

        Parameters
        ----------
        limit : CommonLimit
            Limit the number of undefined items returned

        offset : CommonOffset
            Offset the undefined items returned

        sort_by : UsersRouteListRequestSortBy
            Sort by a field

        direction : UsersRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UsersRouteListResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.users_route_list(
                limit=1,
                offset=1,
                sort_by="created_at",
                direction="asc",
                metadata_filter="metadata_filter",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "users",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(UsersRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def users_route_create(
        self,
        *,
        name: CommonIdentifierSafeUnicode,
        about: str,
        docs: typing.Sequence[typing.Any],
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UsersRouteCreateResponse:
        """
        Create new undefined

        Parameters
        ----------
        name : CommonIdentifierSafeUnicode
            Name of the user

        about : str
            About the user

        docs : typing.Sequence[typing.Any]
            Documents to index for this user. (Max: 100 items)

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UsersRouteCreateResponse
            The request has succeeded and a new resource has been created as a result.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.users_route_create(
                name="name",
                about="about",
                docs=[],
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "users",
            method="POST",
            json={"metadata": metadata, "name": name, "about": about, "docs": docs},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(UsersRouteCreateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def users_route_create_or_update(
        self,
        *,
        id: CommonUuid,
        name: CommonIdentifierSafeUnicode,
        about: str,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UsersRouteCreateOrUpdateResponse:
        """
        Create or update undefined (ID is required in payload; existing resource will be overwritten)

        Parameters
        ----------
        id : CommonUuid

        name : CommonIdentifierSafeUnicode
            Name of the user

        about : str
            About the user

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UsersRouteCreateOrUpdateResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.users_route_create_or_update(
                id="id",
                name="name",
                about="about",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "users",
            method="PUT",
            json={"id": id, "metadata": metadata, "name": name, "about": about},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(UsersRouteCreateOrUpdateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def users_route_get(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> UsersUser:
        """
        Get undefined by id

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UsersUser
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.users_route_get(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(UsersUser, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def users_route_update(
        self,
        id: CommonUuid,
        *,
        name: CommonIdentifierSafeUnicode,
        about: str,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UsersRouteUpdateResponse:
        """
        Update undefined by id (overwrite)

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        name : CommonIdentifierSafeUnicode
            Name of the user

        about : str
            About the user

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UsersRouteUpdateResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.users_route_update(
                id="id",
                name="name",
                about="about",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(id)}",
            method="PUT",
            json={"metadata": metadata, "name": name, "about": about},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(UsersRouteUpdateResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def users_route_delete(
        self, id: CommonUuid, *, request_options: typing.Optional[RequestOptions] = None
    ) -> UsersRouteDeleteResponse:
        """
        Delete undefined by id

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UsersRouteDeleteResponse
            The request has been accepted for processing, but processing has not yet completed.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.users_route_delete(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(UsersRouteDeleteResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def users_route_patch(
        self,
        id: CommonUuid,
        *,
        metadata: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        name: typing.Optional[CommonIdentifierSafeUnicode] = OMIT,
        about: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UsersRoutePatchResponse:
        """
        Patch undefined by id (merge changes)

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        metadata : typing.Optional[typing.Dict[str, typing.Any]]

        name : typing.Optional[CommonIdentifierSafeUnicode]
            Name of the user

        about : typing.Optional[str]
            About the user

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UsersRoutePatchResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.users_route_patch(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(id)}",
            method="PATCH",
            json={"metadata": metadata, "name": name, "about": about},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(UsersRoutePatchResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def user_docs_route_list(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: UserDocsRouteListRequestSortBy,
        direction: UserDocsRouteListRequestDirection,
        metadata_filter: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UserDocsRouteListResponse:
        """
        List undefined items of parent undefined

        Parameters
        ----------
        id : CommonUuid
            ID of parent undefined

        limit : CommonLimit
            Limit the number of undefined items returned

        offset : CommonOffset
            Offset the undefined items returned

        sort_by : UserDocsRouteListRequestSortBy
            Sort by a field

        direction : UserDocsRouteListRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UserDocsRouteListResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.user_docs_route_list(
                id="id",
                limit=1,
                offset=1,
                sort_by="created_at",
                direction="asc",
                metadata_filter="metadata_filter",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(id)}/docs",
            method="GET",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(UserDocsRouteListResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def user_docs_search_route_search(
        self,
        id: CommonUuid,
        *,
        limit: CommonLimit,
        offset: CommonOffset,
        sort_by: UserDocsSearchRouteSearchRequestSortBy,
        direction: UserDocsSearchRouteSearchRequestDirection,
        metadata_filter: str,
        body: DocsDocSearchRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UserDocsSearchRouteSearchResponse:
        """
        Search for documents owned by undefined

        Parameters
        ----------
        id : CommonUuid
            ID of the undefined

        limit : CommonLimit
            Limit the number of undefined items returned

        offset : CommonOffset
            Offset the undefined items returned

        sort_by : UserDocsSearchRouteSearchRequestSortBy
            Sort by a field

        direction : UserDocsSearchRouteSearchRequestDirection
            Sort direction

        metadata_filter : str
            JSON string of object that should be used to filter objects by metadata

        body : DocsDocSearchRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UserDocsSearchRouteSearchResponse
            The request has succeeded.

        Examples
        --------
        import asyncio

        from julep import DocsDocSearchRequest_Vector
        from julep.client import AsyncJulepApi

        client = AsyncJulepApi(
            auth_key="YOUR_AUTH_KEY",
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.user_docs_search_route_search(
                id="string",
                limit=1,
                offset=1,
                sort_by="created_at",
                direction="asc",
                metadata_filter="string",
                body=DocsDocSearchRequest_Vector(
                    text="string",
                    vector=[1.1],
                    confidence=1.1,
                    alpha=1.1,
                    mmr=True,
                    vector=[1.1],
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"users/{jsonable_encoder(id)}/search",
            method="POST",
            params={
                "limit": limit,
                "offset": offset,
                "sort_by": sort_by,
                "direction": direction,
                "metadata_filter": metadata_filter,
            },
            json={"body": body},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return pydantic_v1.parse_obj_as(UserDocsSearchRouteSearchResponse, _response.json())  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


def _get_base_url(
    *, base_url: typing.Optional[str] = None, environment: JulepApiEnvironment
) -> str:
    if base_url is not None:
        return base_url
    elif environment is not None:
        return environment.value
    else:
        raise Exception(
            "Please pass in either base_url or environment to construct the client"
        )
