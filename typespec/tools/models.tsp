import "../common";

using Common;

namespace Tools;

//
// TOOL MODELS
//

enum ToolType {
    /** A tool that emulates a function call */
    function,

    /** A tool that uses one of the Julep integrations */
    integration,

    /** A tool that uses a system resource */
    system,

    /** A tool that makes an API call */
    api_call,
}

/** The parameters the functions accepts, described as a JSON Schema object. */
alias FunctionParameters = Record<unknown>;

alias ToolOutput = Record<unknown>;

alias ToolChoiceOption = "auto" | "none" | NamedToolChoice;

/** Function definition */
model FunctionDef {
    /** DO NOT USE: This will be overriden by the tool name. Here only for compatibility reasons. */
    name?: null = null;

    /** Description of the function  */
    description?: string;

    /** The parameters the function accepts */
    parameters?: FunctionParameters;

}

/** Integration definition */
model IntegrationDef {
    /** The provider of the integration */
    provider: integrationProvider;

    /** The specific method of the integration to call */
    method?: string;

    /** Optional description of the integration */
    description?: string;

    /** The setup parameters the integration accepts */
    setup?: FunctionParameters;

    /** The arguments to pre-apply to the integration call */
    arguments?: FunctionParameters;
}

/** System definition */
model SystemDef {
    /** The name of the system call */
    call: string;

    /** Optional description of the system call */
    description?: string;

    /** The arguments to pre-apply to the system call */
    arguments?: FunctionParameters;
}

// TODO: We should use this model for all tools, not just functions and discriminate on the type
model Tool {
    /** Whether this tool is a `function`, `api_call`, `system` etc. (Only `function` tool supported right now) */
    type: ToolType = ToolType.function;

    /** Name of the tool (must be unique for this agent and a valid python identifier string )*/
    name: validPythonIdentifier;

    /** The function to call */
    function?: FunctionDef;
    integration?: IntegrationDef;
    system?: SystemDef;
    api_call?: never; // TODO: Implement

    ...HasTimestamps;
    ...HasId;
}

model FunctionCallOption {
    /** The name of the function */
    name: string;
}

@discriminator("type")
model NamedToolChoice {
    /** Whether this tool is a `function`, `api_call`, `system` etc. (Only `function` tool supported right now) */
    type: ToolType;

    function?: FunctionCallOption;
    integration?: never; // TODO: Implement
    system?: never; // TODO: Implement
    api_call?: never; // TODO: Implement
}

model NamedFunctionChoice extends NamedToolChoice {
    type: ToolType.function;

    /** The function to call */
    function: FunctionCallOption;
}

model ToolResponse {
    @key id: uuid;

    /** The output of the tool */
    output: ToolOutput;
}

/** Payload for creating a tool */
@withVisibility("create")
model CreateToolRequest {
    ...Tool;
}

/** Payload for updating a tool */
@withVisibility("update")
model UpdateToolRequest {
    ...Tool;
}

/** Payload for patching a tool */
model PatchToolRequest is UpdateToolRequest {}

/** The response tool value generated by the model */
@discriminator("type")
model ChosenToolCall {
    /** Whether this tool is a `function`, `api_call`, `system` etc. (Only `function` tool supported right now) */
    type: ToolType;

    function?: FunctionCallOption;
    integration?: never; // TODO: Implement
    system?: never; // TODO: Implement
    api_call?: never; // TODO: Implement

    ...HasId;
}

model ChosenFunctionCall extends ChosenToolCall {
    type: ToolType.function;

    /** The function to call */
    function: FunctionCallOption;
}
