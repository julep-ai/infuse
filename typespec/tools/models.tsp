import "../common";

using Common;

namespace Tools;

//
// TOOL MODELS
//

enum ToolType {
    /** A tool that emulates a function call */
    function,

    /** A tool that uses one of the Julep integrations */
    integration,

    /** A tool that uses a system resource */
    system,

    /** A tool that makes an API call */
    api_call,
}

/** The parameters the functions accepts, described as a JSON Schema object. */
alias FunctionParameters = Record<unknown>;

alias ToolOutput = Record<unknown>;

alias ToolChoiceOption = "auto" | "none" | NamedToolChoice;

/** Function definition */
model FunctionDef {
    /** DO NOT USE: This will be overriden by the tool name. Here only for compatibility reasons. */
    name?: null = null;

    /** DO NOT USE: This will be overriden by the tool description. Here only for compatibility reasons. */
    description?: null = null;

    /** The parameters the function accepts */
    parameters?: FunctionParameters;

}

/** Integration definition */
model IntegrationDef {
    /** The provider of the integration */
    provider: integrationProvider | string;

    /** The specific method of the integration to call */
    method?: string;

    /** The setup parameters the integration accepts */
    setup?: FunctionParameters;

    /** The arguments to pre-apply to the integration call */
    arguments?: FunctionParameters;
}

//
// SYSTEM TOOL MODELS
//

alias resourceType = (
    | "agent"
    | "user"
    | "task"
    | "execution"
    | "doc"
    | "session"
    | "job"
);

alias subresourceType = (
    | "tool"
    | "doc"
    | "execution"
    | "transition"
);

alias operationType = (
    | "create"
    | "update"
    | "patch"
    | "create_or_update"
    | "embed"
    | "change_status"
    | "search"
    | "chat"
    | "history"
    | "delete"
    | "get"
    | "list"
);

/** System definition */
model SystemDef {
    /** Resource is the name of the resource to use */
    resource: resourceType;

    /** Operation is the name of the operation to perform */
    operation: operationType;

    /** Resource id (if applicable) */
    resource_id?: uuid;

    /** Sub-resource type (if applicable) */
    subresource?: subresourceType;

    /** The arguments to pre-apply to the system call */
    arguments?: FunctionParameters;
}

/** API call definition */
model ApiCallDef {
    /** The HTTP method to use */
    method: httpMethod;

    /** The URL to call */
    url: url;

    /** The headers to send with the request */
    headers?: Record<string>;

    /** The content as base64 to send with the request */
    content?: string;

    /** The data to send as form data */
    data?: Record<unknown>;

    /** JSON body to send with the request */
    json?: Record<unknown>;

    /** Cookies */
    cookies?: Record<string>;

    /** The parameters to send with the request */
    params?: string | Record<unknown>;

    /** Follow redirects */
    follow_redirects?: boolean;

    /** The timeout for the request */
    timeout?: uint8;
}


model Tool {
    /** Name of the tool (must be unique for this agent and a valid python identifier string )*/
    name: validPythonIdentifier;

    /** Description of the tool */
    description?: string;

    /** The function to call */
    function?: FunctionDef;

    /** The integration to call */
    integration?: IntegrationDef;

    /** The system to call */
    system?: SystemDef;

    /** The API call to make */
    api_call?: ApiCallDef;

    ...HasTimestamps;
    ...HasId;
}

model FunctionCallOption {
    /** The name of the function */
    name: string;
}

model NamedToolChoice {
    function?: FunctionCallOption;
    integration?: never;
    system?: never;
    api_call?: never;
}

model ToolResponse {
    @key id: uuid;

    /** The output of the tool */
    output: ToolOutput;
}

/** Payload for creating a tool */
@withVisibility("create")
model CreateToolRequest {
    ...Tool;
}

/** Payload for updating a tool */
@withVisibility("update")
model UpdateToolRequest {
    ...Tool;
}

/** Payload for patching a tool */
model PatchToolRequest is UpdateToolRequest {}

/** The response tool value generated by the model */
@discriminator("type")
model ChosenToolCall {
    /** Whether this tool is a `function`, `api_call`, `system` etc. (Only `function` tool supported right now) */
    type: ToolType;

    function?: FunctionCallOption;
    integration?: never;
    system?: never;
    api_call?: never;

    ...HasId;
}

model ChosenFunctionCall extends ChosenToolCall {
    type: ToolType.function;

    /** The function to call */
    function: FunctionCallOption;
}
