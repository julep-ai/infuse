# generated by datamodel-codegen:
#   filename:  openapi-0.4.0.yaml
#   timestamp: 2024-07-15T21:10:09+00:00

from __future__ import annotations

from enum import Enum
from typing import Annotated, Any, Dict, List, Literal
from uuid import UUID

from pydantic import AwareDatetime, BaseModel, Field


class CreateExecutionRequest(BaseModel):
    """
    Payload for creating an execution
    """

    input: Dict[str, Any]
    """
    The input to the execution
    """


class Status(str, Enum):
    """
    The status of the execution
    """

    queued = "queued"
    starting = "starting"
    running = "running"
    awaiting_input = "awaiting_input"
    succeeded = "succeeded"
    failed = "failed"
    cancelled = "cancelled"


class Execution(BaseModel):
    task_id: Annotated[UUID, Field(json_schema_extra={"readOnly": True})]
    """
    The ID of the task that the execution is running
    """
    status: Annotated[Status, Field(json_schema_extra={"readOnly": True})]
    """
    The status of the execution
    """
    input: Dict[str, Any]
    """
    The input to the execution
    """
    created_at: Annotated[AwareDatetime, Field(json_schema_extra={"readOnly": True})]
    """
    When this resource was created as UTC date-time
    """
    updated_at: Annotated[AwareDatetime, Field(json_schema_extra={"readOnly": True})]
    """
    When this resource was updated as UTC date-time
    """
    id: Annotated[UUID, Field(json_schema_extra={"readOnly": True})]


class TaskTokenResumeExecutionRequest(BaseModel):
    status: Literal["running"] = "running"
    task_token: str
    """
    A Task Token is a unique identifier for a specific Task Execution.
    """
    input: Dict[str, Any] | None = None
    """
    The input to resume the execution with
    """


class Type(str, Enum):
    finish = "finish"
    wait = "wait"
    error = "error"
    step = "step"
    cancelled = "cancelled"


class Transition(BaseModel):
    type: Annotated[Type, Field(json_schema_extra={"readOnly": True})]
    execution_id: Annotated[UUID, Field(json_schema_extra={"readOnly": True})]
    outputs: Annotated[Dict[str, Any], Field(json_schema_extra={"readOnly": True})]
    current: Annotated[List, Field(json_schema_extra={"readOnly": True})]
    next: Annotated[List, Field(json_schema_extra={"readOnly": True})]
    id: Annotated[UUID, Field(json_schema_extra={"readOnly": True})]
    created_at: Annotated[AwareDatetime, Field(json_schema_extra={"readOnly": True})]
    """
    When this resource was created as UTC date-time
    """
    updated_at: Annotated[AwareDatetime, Field(json_schema_extra={"readOnly": True})]
    """
    When this resource was updated as UTC date-time
    """


class StatusModel(str, Enum):
    queued = "queued"
    starting = "starting"
    running = "running"
    awaiting_input = "awaiting_input"
    succeeded = "succeeded"
    failed = "failed"
    cancelled = "cancelled"


class UpdateExecutionRequest(BaseModel):
    status: StatusModel


class ResumeExecutionRequest(UpdateExecutionRequest):
    status: Literal["running"] = "running"
    input: Dict[str, Any] | None = None
    """
    The input to resume the execution with
    """


class StopExecutionRequest(UpdateExecutionRequest):
    status: Literal["cancelled"] = "cancelled"
    reason: str
    """
    The reason for stopping the execution
    """
